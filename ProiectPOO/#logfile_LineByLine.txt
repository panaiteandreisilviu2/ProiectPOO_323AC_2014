

1 / 129

10    #ifndef cimg_plugin_matlab     #ifndef cimg_use_tiff    
25    #ifndef cimg_plugin_matlab     error cimg_use_tiff not defined    
22    #ifndef cimg_plugin_matlab     #endif    
9    #ifndef cimg_plugin_matlab     #ifndef cimg_plugin_tiff_stream    
14    #ifndef cimg_plugin_matlab     #define cimg_plugin_tiff_stream    
20    #ifndef cimg_plugin_matlab     #include <ios>    
86    #ifndef cimg_plugin_matlab     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25    #ifndef cimg_plugin_matlab      if (!tiffOutStream->good())    
35    #ifndef cimg_plugin_matlab      throw CImgArgumentException(_cimg_instance    
34    #ifndef cimg_plugin_matlab      "save_tiff(): tiffstream is not good!",    
18    #ifndef cimg_plugin_matlab      cimg_instance);    
20    #ifndef cimg_plugin_matlab      if (is_empty())    
35    #ifndef cimg_plugin_matlab      throw CImgArgumentException(_cimg_instance    
40    #ifndef cimg_plugin_matlab      "Not allowed to write empty images to stream",    
17    #ifndef cimg_plugin_matlab      cimg_instance    
25    #ifndef cimg_plugin_matlab      );    
47    #ifndef cimg_plugin_matlab      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
22    #ifndef cimg_plugin_matlab      if (tif)    
59    #ifndef cimg_plugin_matlab      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
24    #ifndef cimg_plugin_matlab      tiffOutStream->flush();    
24    #ifndef cimg_plugin_matlab      TIFFClose(tif);    
24    #ifndef cimg_plugin_matlab      else    
30    #ifndef cimg_plugin_matlab      throw CImgIOException(_cimg_instance    
40    #ifndef cimg_plugin_matlab      "save_tiff(): Failed to stream for writing.",    
18    #ifndef cimg_plugin_matlab      cimg_instance);    
23    #ifndef cimg_plugin_matlab      return *this;    
40    #ifndef cimg_plugin_matlab     CImg<T>& load_tiff(std::istream* tiffInStream,    
56    #ifndef cimg_plugin_matlab      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #ifndef cimg_plugin_matlab      const unsigned int step_frame=1)    
21    #ifndef cimg_plugin_matlab      const unsigned int    
49    #ifndef cimg_plugin_matlab      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33    #ifndef cimg_plugin_matlab      nstep_frame = step_frame?step_frame:1;    
62    #ifndef cimg_plugin_matlab      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46    #ifndef cimg_plugin_matlab      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
22    #ifndef cimg_plugin_matlab      if (tif)    
25    #ifndef cimg_plugin_matlab      unsigned int nb_images = 0;    
24    #ifndef cimg_plugin_matlab      do     
21    #ifndef cimg_plugin_matlab      ++nb_images;    
30    #ifndef cimg_plugin_matlab       while (TIFFReadDirectory(tif));    
63    #ifndef cimg_plugin_matlab      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97    #ifndef cimg_plugin_matlab      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40    #ifndef cimg_plugin_matlab      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
22    #ifndef cimg_plugin_matlab      if (nfirst_frame>=nb_images)    
23    #ifndef cimg_plugin_matlab      return assign();    
22    #ifndef cimg_plugin_matlab      if (nlast_frame>=nb_images)    
25    #ifndef cimg_plugin_matlab      nlast_frame = nb_images-1;    
25    #ifndef cimg_plugin_matlab      TIFFSetDirectory(tif,0);    
22    #ifndef cimg_plugin_matlab      CImg<T> frame;    
58    #ifndef cimg_plugin_matlab      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    #ifndef cimg_plugin_matlab      frame._load_tiff(tif,l);    
99    #ifndef cimg_plugin_matlab      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68    #ifndef cimg_plugin_matlab      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
104    #ifndef cimg_plugin_matlab      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44    #ifndef cimg_plugin_matlab      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24    #ifndef cimg_plugin_matlab      TIFFClose(tif);    
24    #ifndef cimg_plugin_matlab      else    
30    #ifndef cimg_plugin_matlab      throw CImgIOException(_cimg_instance    
41    #ifndef cimg_plugin_matlab      "load_tiff(): Failed to read data from stream",    
18    #ifndef cimg_plugin_matlab      cimg_instance);    
23    #ifndef cimg_plugin_matlab      return *this;    
49    #ifndef cimg_plugin_matlab     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56    #ifndef cimg_plugin_matlab      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #ifndef cimg_plugin_matlab      const unsigned int step_frame=1)    
65    #ifndef cimg_plugin_matlab      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
22    #ifndef cimg_plugin_matlab     #endif    
26    #ifndef cimg_plugin_matlab         


2 / 129

15    #define cimg_plugin_matlab     #ifndef cimg_use_tiff    
24    #define cimg_plugin_matlab     error cimg_use_tiff not defined    
22    #define cimg_plugin_matlab     #endif    
14    #define cimg_plugin_matlab     #ifndef cimg_plugin_tiff_stream    
9    #define cimg_plugin_matlab     #define cimg_plugin_tiff_stream    
20    #define cimg_plugin_matlab     #include <ios>    
87    #define cimg_plugin_matlab     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27    #define cimg_plugin_matlab      if (!tiffOutStream->good())    
35    #define cimg_plugin_matlab      throw CImgArgumentException(_cimg_instance    
34    #define cimg_plugin_matlab      "save_tiff(): tiffstream is not good!",    
18    #define cimg_plugin_matlab      cimg_instance);    
21    #define cimg_plugin_matlab      if (is_empty())    
35    #define cimg_plugin_matlab      throw CImgArgumentException(_cimg_instance    
40    #define cimg_plugin_matlab      "Not allowed to write empty images to stream",    
17    #define cimg_plugin_matlab      cimg_instance    
25    #define cimg_plugin_matlab      );    
48    #define cimg_plugin_matlab      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23    #define cimg_plugin_matlab      if (tif)    
59    #define cimg_plugin_matlab      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25    #define cimg_plugin_matlab      tiffOutStream->flush();    
24    #define cimg_plugin_matlab      TIFFClose(tif);    
24    #define cimg_plugin_matlab      else    
30    #define cimg_plugin_matlab      throw CImgIOException(_cimg_instance    
40    #define cimg_plugin_matlab      "save_tiff(): Failed to stream for writing.",    
18    #define cimg_plugin_matlab      cimg_instance);    
23    #define cimg_plugin_matlab      return *this;    
40    #define cimg_plugin_matlab     CImg<T>& load_tiff(std::istream* tiffInStream,    
56    #define cimg_plugin_matlab      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
29    #define cimg_plugin_matlab      const unsigned int step_frame=1)    
22    #define cimg_plugin_matlab      const unsigned int    
50    #define cimg_plugin_matlab      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32    #define cimg_plugin_matlab      nstep_frame = step_frame?step_frame:1;    
62    #define cimg_plugin_matlab      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47    #define cimg_plugin_matlab      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23    #define cimg_plugin_matlab      if (tif)    
24    #define cimg_plugin_matlab      unsigned int nb_images = 0;    
24    #define cimg_plugin_matlab      do     
21    #define cimg_plugin_matlab      ++nb_images;    
28    #define cimg_plugin_matlab       while (TIFFReadDirectory(tif));    
64    #define cimg_plugin_matlab      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
98    #define cimg_plugin_matlab      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41    #define cimg_plugin_matlab      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24    #define cimg_plugin_matlab      if (nfirst_frame>=nb_images)    
22    #define cimg_plugin_matlab      return assign();    
23    #define cimg_plugin_matlab      if (nlast_frame>=nb_images)    
25    #define cimg_plugin_matlab      nlast_frame = nb_images-1;    
24    #define cimg_plugin_matlab      TIFFSetDirectory(tif,0);    
22    #define cimg_plugin_matlab      CImg<T> frame;    
58    #define cimg_plugin_matlab      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
24    #define cimg_plugin_matlab      frame._load_tiff(tif,l);    
100    #define cimg_plugin_matlab      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    #define cimg_plugin_matlab      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
103    #define cimg_plugin_matlab      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43    #define cimg_plugin_matlab      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24    #define cimg_plugin_matlab      TIFFClose(tif);    
24    #define cimg_plugin_matlab      else    
30    #define cimg_plugin_matlab      throw CImgIOException(_cimg_instance    
40    #define cimg_plugin_matlab      "load_tiff(): Failed to read data from stream",    
18    #define cimg_plugin_matlab      cimg_instance);    
23    #define cimg_plugin_matlab      return *this;    
48    #define cimg_plugin_matlab     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56    #define cimg_plugin_matlab      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
29    #define cimg_plugin_matlab      const unsigned int step_frame=1)    
64    #define cimg_plugin_matlab      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
22    #define cimg_plugin_matlab     #endif    
26    #define cimg_plugin_matlab         


3 / 129

23    #define CIMGMATLAB_VER 0102     #ifndef cimg_use_tiff    
30    #define CIMGMATLAB_VER 0102     error cimg_use_tiff not defined    
24    #define CIMGMATLAB_VER 0102     #endif    
27    #define CIMGMATLAB_VER 0102     #ifndef cimg_plugin_tiff_stream    
22    #define CIMGMATLAB_VER 0102     #define cimg_plugin_tiff_stream    
24    #define CIMGMATLAB_VER 0102     #include <ios>    
90    #define CIMGMATLAB_VER 0102     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
28    #define CIMGMATLAB_VER 0102      if (!tiffOutStream->good())    
40    #define CIMGMATLAB_VER 0102      throw CImgArgumentException(_cimg_instance    
36    #define CIMGMATLAB_VER 0102      "save_tiff(): tiffstream is not good!",    
26    #define CIMGMATLAB_VER 0102      cimg_instance);    
24    #define CIMGMATLAB_VER 0102      if (is_empty())    
40    #define CIMGMATLAB_VER 0102      throw CImgArgumentException(_cimg_instance    
42    #define CIMGMATLAB_VER 0102      "Not allowed to write empty images to stream",    
25    #define CIMGMATLAB_VER 0102      cimg_instance    
26    #define CIMGMATLAB_VER 0102      );    
49    #define CIMGMATLAB_VER 0102      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
25    #define CIMGMATLAB_VER 0102      if (tif)    
64    #define CIMGMATLAB_VER 0102      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
26    #define CIMGMATLAB_VER 0102      tiffOutStream->flush();    
25    #define CIMGMATLAB_VER 0102      TIFFClose(tif);    
25    #define CIMGMATLAB_VER 0102      else    
34    #define CIMGMATLAB_VER 0102      throw CImgIOException(_cimg_instance    
41    #define CIMGMATLAB_VER 0102      "save_tiff(): Failed to stream for writing.",    
26    #define CIMGMATLAB_VER 0102      cimg_instance);    
25    #define CIMGMATLAB_VER 0102      return *this;    
44    #define CIMGMATLAB_VER 0102     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #define CIMGMATLAB_VER 0102      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    #define CIMGMATLAB_VER 0102      const unsigned int step_frame=1)    
25    #define CIMGMATLAB_VER 0102      const unsigned int    
57    #define CIMGMATLAB_VER 0102      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34    #define CIMGMATLAB_VER 0102      nstep_frame = step_frame?step_frame:1;    
68    #define CIMGMATLAB_VER 0102      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48    #define CIMGMATLAB_VER 0102      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
25    #define CIMGMATLAB_VER 0102      if (tif)    
23    #define CIMGMATLAB_VER 0102      unsigned int nb_images = 0;    
25    #define CIMGMATLAB_VER 0102      do     
25    #define CIMGMATLAB_VER 0102      ++nb_images;    
29    #define CIMGMATLAB_VER 0102       while (TIFFReadDirectory(tif));    
71    #define CIMGMATLAB_VER 0102      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
105    #define CIMGMATLAB_VER 0102      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
45    #define CIMGMATLAB_VER 0102      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27    #define CIMGMATLAB_VER 0102      if (nfirst_frame>=nb_images)    
25    #define CIMGMATLAB_VER 0102      return assign();    
27    #define CIMGMATLAB_VER 0102      if (nlast_frame>=nb_images)    
27    #define CIMGMATLAB_VER 0102      nlast_frame = nb_images-1;    
25    #define CIMGMATLAB_VER 0102      TIFFSetDirectory(tif,0);    
23    #define CIMGMATLAB_VER 0102      CImg<T> frame;    
63    #define CIMGMATLAB_VER 0102      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
26    #define CIMGMATLAB_VER 0102      frame._load_tiff(tif,l);    
107    #define CIMGMATLAB_VER 0102      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73    #define CIMGMATLAB_VER 0102      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
111    #define CIMGMATLAB_VER 0102      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    #define CIMGMATLAB_VER 0102      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
25    #define CIMGMATLAB_VER 0102      TIFFClose(tif);    
25    #define CIMGMATLAB_VER 0102      else    
34    #define CIMGMATLAB_VER 0102      throw CImgIOException(_cimg_instance    
42    #define CIMGMATLAB_VER 0102      "load_tiff(): Failed to read data from stream",    
26    #define CIMGMATLAB_VER 0102      cimg_instance);    
25    #define CIMGMATLAB_VER 0102      return *this;    
51    #define CIMGMATLAB_VER 0102     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #define CIMGMATLAB_VER 0102      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    #define CIMGMATLAB_VER 0102      const unsigned int step_frame=1)    
70    #define CIMGMATLAB_VER 0102      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
24    #define CIMGMATLAB_VER 0102     #endif    
27    #define CIMGMATLAB_VER 0102         


4 / 129

11    #ifndef mex_h     #ifndef cimg_use_tiff    
26    #ifndef mex_h     error cimg_use_tiff not defined    
9    #ifndef mex_h     #endif    
21    #ifndef mex_h     #ifndef cimg_plugin_tiff_stream    
26    #ifndef mex_h     #define cimg_plugin_tiff_stream    
10    #ifndef mex_h     #include <ios>    
90    #ifndef mex_h     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24    #ifndef mex_h      if (!tiffOutStream->good())    
39    #ifndef mex_h      throw CImgArgumentException(_cimg_instance    
36    #ifndef mex_h      "save_tiff(): tiffstream is not good!",    
14    #ifndef mex_h      cimg_instance);    
13    #ifndef mex_h      if (is_empty())    
39    #ifndef mex_h      throw CImgArgumentException(_cimg_instance    
42    #ifndef mex_h      "Not allowed to write empty images to stream",    
13    #ifndef mex_h      cimg_instance    
12    #ifndef mex_h      );    
47    #ifndef mex_h      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
10    #ifndef mex_h      if (tif)    
61    #ifndef mex_h      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20    #ifndef mex_h      tiffOutStream->flush();    
15    #ifndef mex_h      TIFFClose(tif);    
11    #ifndef mex_h      else    
34    #ifndef mex_h      throw CImgIOException(_cimg_instance    
40    #ifndef mex_h      "save_tiff(): Failed to stream for writing.",    
14    #ifndef mex_h      cimg_instance);    
13    #ifndef mex_h      return *this;    
40    #ifndef mex_h     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #ifndef mex_h      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26    #ifndef mex_h      const unsigned int step_frame=1)    
17    #ifndef mex_h      const unsigned int    
55    #ifndef mex_h      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33    #ifndef mex_h      nstep_frame = step_frame?step_frame:1;    
66    #ifndef mex_h      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46    #ifndef mex_h      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
10    #ifndef mex_h      if (tif)    
22    #ifndef mex_h      unsigned int nb_images = 0;    
11    #ifndef mex_h      do     
12    #ifndef mex_h      ++nb_images;    
30    #ifndef mex_h       while (TIFFReadDirectory(tif));    
68    #ifndef mex_h      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
104    #ifndef mex_h      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41    #ifndef mex_h      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
22    #ifndef mex_h      if (nfirst_frame>=nb_images)    
16    #ifndef mex_h      return assign();    
21    #ifndef mex_h      if (nlast_frame>=nb_images)    
22    #ifndef mex_h      nlast_frame = nb_images-1;    
23    #ifndef mex_h      TIFFSetDirectory(tif,0);    
14    #ifndef mex_h      CImg<T> frame;    
61    #ifndef mex_h      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    #ifndef mex_h      frame._load_tiff(tif,l);    
105    #ifndef mex_h      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
71    #ifndef mex_h      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109    #ifndef mex_h      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45    #ifndef mex_h      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
15    #ifndef mex_h      TIFFClose(tif);    
11    #ifndef mex_h      else    
34    #ifndef mex_h      throw CImgIOException(_cimg_instance    
41    #ifndef mex_h      "load_tiff(): Failed to read data from stream",    
14    #ifndef mex_h      cimg_instance);    
13    #ifndef mex_h      return *this;    
50    #ifndef mex_h     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #ifndef mex_h      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26    #ifndef mex_h      const unsigned int step_frame=1)    
68    #ifndef mex_h      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
9    #ifndef mex_h     #endif    
13    #ifndef mex_h         


5 / 129

63    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #ifndef cimg_use_tiff    
56    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     error cimg_use_tiff not defined    
67    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #endif    
60    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #ifndef cimg_plugin_tiff_stream    
59    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #define cimg_plugin_tiff_stream    
61    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #include <ios>    
81    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (!tiffOutStream->good())    
56    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      throw CImgArgumentException(_cimg_instance    
60    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      "save_tiff(): tiffstream is not good!",    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg_instance);    
66    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (is_empty())    
56    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      throw CImgArgumentException(_cimg_instance    
56    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      "Not allowed to write empty images to stream",    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg_instance    
72    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      );    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
67    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (tif)    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      tiffOutStream->flush();    
66    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      TIFFClose(tif);    
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      else    
57    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      throw CImgIOException(_cimg_instance    
59    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      "save_tiff(): Failed to stream for writing.",    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg_instance);    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      return *this;    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
59    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      const unsigned int step_frame=1)    
61    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      const unsigned int    
61    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
60    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      nstep_frame = step_frame?step_frame:1;    
67    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
67    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (tif)    
61    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      unsigned int nb_images = 0;    
69    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      do     
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      ++nb_images;    
60    #error the file mex.h must be included prior to inclusion of cimgmatlab.h       while (TIFFReadDirectory(tif));    
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
87    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
59    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (nfirst_frame>=nb_images)    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      return assign();    
63    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (nlast_frame>=nb_images)    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      nlast_frame = nb_images-1;    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      TIFFSetDirectory(tif,0);    
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      CImg<T> frame;    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
61    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      frame._load_tiff(tif,l);    
98    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
64    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
66    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      TIFFClose(tif);    
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      else    
57    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      throw CImgIOException(_cimg_instance    
58    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      "load_tiff(): Failed to read data from stream",    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      cimg_instance);    
65    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      return *this;    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
59    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      const unsigned int step_frame=1)    
68    #error the file mex.h must be included prior to inclusion of cimgmatlab.h      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
67    #error the file mex.h must be included prior to inclusion of cimgmatlab.h     #endif    
73    #error the file mex.h must be included prior to inclusion of cimgmatlab.h         


6 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


7 / 129

6    #ifndef cimg_version     #ifndef cimg_use_tiff    
23    #ifndef cimg_version     error cimg_use_tiff not defined    
16    #ifndef cimg_version     #endif    
17    #ifndef cimg_version     #ifndef cimg_plugin_tiff_stream    
22    #ifndef cimg_version     #define cimg_plugin_tiff_stream    
14    #ifndef cimg_version     #include <ios>    
86    #ifndef cimg_version     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
23    #ifndef cimg_version      if (!tiffOutStream->good())    
35    #ifndef cimg_version      throw CImgArgumentException(_cimg_instance    
33    #ifndef cimg_version      "save_tiff(): tiffstream is not good!",    
16    #ifndef cimg_version      cimg_instance);    
16    #ifndef cimg_version      if (is_empty())    
35    #ifndef cimg_version      throw CImgArgumentException(_cimg_instance    
41    #ifndef cimg_version      "Not allowed to write empty images to stream",    
14    #ifndef cimg_version      cimg_instance    
19    #ifndef cimg_version      );    
46    #ifndef cimg_version      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
16    #ifndef cimg_version      if (tif)    
56    #ifndef cimg_version      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20    #ifndef cimg_version      tiffOutStream->flush();    
19    #ifndef cimg_version      TIFFClose(tif);    
17    #ifndef cimg_version      else    
30    #ifndef cimg_version      throw CImgIOException(_cimg_instance    
38    #ifndef cimg_version      "save_tiff(): Failed to stream for writing.",    
16    #ifndef cimg_version      cimg_instance);    
18    #ifndef cimg_version      return *this;    
39    #ifndef cimg_version     CImg<T>& load_tiff(std::istream* tiffInStream,    
59    #ifndef cimg_version      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #ifndef cimg_version      const unsigned int step_frame=1)    
16    #ifndef cimg_version      const unsigned int    
52    #ifndef cimg_version      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33    #ifndef cimg_version      nstep_frame = step_frame?step_frame:1;    
63    #ifndef cimg_version      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45    #ifndef cimg_version      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
16    #ifndef cimg_version      if (tif)    
22    #ifndef cimg_version      unsigned int nb_images = 0;    
18    #ifndef cimg_version      do     
15    #ifndef cimg_version      ++nb_images;    
28    #ifndef cimg_version       while (TIFFReadDirectory(tif));    
66    #ifndef cimg_version      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99    #ifndef cimg_version      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42    #ifndef cimg_version      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24    #ifndef cimg_version      if (nfirst_frame>=nb_images)    
19    #ifndef cimg_version      return assign();    
23    #ifndef cimg_version      if (nlast_frame>=nb_images)    
22    #ifndef cimg_version      nlast_frame = nb_images-1;    
22    #ifndef cimg_version      TIFFSetDirectory(tif,0);    
18    #ifndef cimg_version      CImg<T> frame;    
60    #ifndef cimg_version      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22    #ifndef cimg_version      frame._load_tiff(tif,l);    
101    #ifndef cimg_version      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    #ifndef cimg_version      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
105    #ifndef cimg_version      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45    #ifndef cimg_version      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19    #ifndef cimg_version      TIFFClose(tif);    
17    #ifndef cimg_version      else    
30    #ifndef cimg_version      throw CImgIOException(_cimg_instance    
41    #ifndef cimg_version      "load_tiff(): Failed to read data from stream",    
16    #ifndef cimg_version      cimg_instance);    
18    #ifndef cimg_version      return *this;    
49    #ifndef cimg_version     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59    #ifndef cimg_version      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #ifndef cimg_version      const unsigned int step_frame=1)    
67    #ifndef cimg_version      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
16    #ifndef cimg_version     #endif    
20    #ifndef cimg_version         


8 / 129

44    #error cimgmatlab.h requires that CImg.h is included!     #ifndef cimg_use_tiff    
34    #error cimgmatlab.h requires that CImg.h is included!     error cimg_use_tiff not defined    
49    #error cimgmatlab.h requires that CImg.h is included!     #endif    
43    #error cimgmatlab.h requires that CImg.h is included!     #ifndef cimg_plugin_tiff_stream    
42    #error cimgmatlab.h requires that CImg.h is included!     #define cimg_plugin_tiff_stream    
46    #error cimgmatlab.h requires that CImg.h is included!     #include <ios>    
80    #error cimgmatlab.h requires that CImg.h is included!     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
45    #error cimgmatlab.h requires that CImg.h is included!      if (!tiffOutStream->good())    
41    #error cimgmatlab.h requires that CImg.h is included!      throw CImgArgumentException(_cimg_instance    
43    #error cimgmatlab.h requires that CImg.h is included!      "save_tiff(): tiffstream is not good!",    
41    #error cimgmatlab.h requires that CImg.h is included!      cimg_instance);    
47    #error cimgmatlab.h requires that CImg.h is included!      if (is_empty())    
41    #error cimgmatlab.h requires that CImg.h is included!      throw CImgArgumentException(_cimg_instance    
42    #error cimgmatlab.h requires that CImg.h is included!      "Not allowed to write empty images to stream",    
41    #error cimgmatlab.h requires that CImg.h is included!      cimg_instance    
52    #error cimgmatlab.h requires that CImg.h is included!      );    
49    #error cimgmatlab.h requires that CImg.h is included!      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
48    #error cimgmatlab.h requires that CImg.h is included!      if (tif)    
57    #error cimgmatlab.h requires that CImg.h is included!      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
45    #error cimgmatlab.h requires that CImg.h is included!      tiffOutStream->flush();    
48    #error cimgmatlab.h requires that CImg.h is included!      TIFFClose(tif);    
49    #error cimgmatlab.h requires that CImg.h is included!      else    
40    #error cimgmatlab.h requires that CImg.h is included!      throw CImgIOException(_cimg_instance    
45    #error cimgmatlab.h requires that CImg.h is included!      "save_tiff(): Failed to stream for writing.",    
41    #error cimgmatlab.h requires that CImg.h is included!      cimg_instance);    
43    #error cimgmatlab.h requires that CImg.h is included!      return *this;    
47    #error cimgmatlab.h requires that CImg.h is included!     CImg<T>& load_tiff(std::istream* tiffInStream,    
56    #error cimgmatlab.h requires that CImg.h is included!      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
45    #error cimgmatlab.h requires that CImg.h is included!      const unsigned int step_frame=1)    
43    #error cimgmatlab.h requires that CImg.h is included!      const unsigned int    
53    #error cimgmatlab.h requires that CImg.h is included!      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
47    #error cimgmatlab.h requires that CImg.h is included!      nstep_frame = step_frame?step_frame:1;    
62    #error cimgmatlab.h requires that CImg.h is included!      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48    #error cimgmatlab.h requires that CImg.h is included!      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
48    #error cimgmatlab.h requires that CImg.h is included!      if (tif)    
45    #error cimgmatlab.h requires that CImg.h is included!      unsigned int nb_images = 0;    
51    #error cimgmatlab.h requires that CImg.h is included!      do     
47    #error cimgmatlab.h requires that CImg.h is included!      ++nb_images;    
47    #error cimgmatlab.h requires that CImg.h is included!       while (TIFFReadDirectory(tif));    
65    #error cimgmatlab.h requires that CImg.h is included!      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93    #error cimgmatlab.h requires that CImg.h is included!      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
46    #error cimgmatlab.h requires that CImg.h is included!      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
43    #error cimgmatlab.h requires that CImg.h is included!      if (nfirst_frame>=nb_images)    
44    #error cimgmatlab.h requires that CImg.h is included!      return assign();    
44    #error cimgmatlab.h requires that CImg.h is included!      if (nlast_frame>=nb_images)    
45    #error cimgmatlab.h requires that CImg.h is included!      nlast_frame = nb_images-1;    
46    #error cimgmatlab.h requires that CImg.h is included!      TIFFSetDirectory(tif,0);    
45    #error cimgmatlab.h requires that CImg.h is included!      CImg<T> frame;    
56    #error cimgmatlab.h requires that CImg.h is included!      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
46    #error cimgmatlab.h requires that CImg.h is included!      frame._load_tiff(tif,l);    
97    #error cimgmatlab.h requires that CImg.h is included!      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66    #error cimgmatlab.h requires that CImg.h is included!      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
96    #error cimgmatlab.h requires that CImg.h is included!      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
48    #error cimgmatlab.h requires that CImg.h is included!      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
48    #error cimgmatlab.h requires that CImg.h is included!      TIFFClose(tif);    
49    #error cimgmatlab.h requires that CImg.h is included!      else    
40    #error cimgmatlab.h requires that CImg.h is included!      throw CImgIOException(_cimg_instance    
46    #error cimgmatlab.h requires that CImg.h is included!      "load_tiff(): Failed to read data from stream",    
41    #error cimgmatlab.h requires that CImg.h is included!      cimg_instance);    
43    #error cimgmatlab.h requires that CImg.h is included!      return *this;    
48    #error cimgmatlab.h requires that CImg.h is included!     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56    #error cimgmatlab.h requires that CImg.h is included!      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
45    #error cimgmatlab.h requires that CImg.h is included!      const unsigned int step_frame=1)    
63    #error cimgmatlab.h requires that CImg.h is included!      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
49    #error cimgmatlab.h requires that CImg.h is included!     #endif    
53    #error cimgmatlab.h requires that CImg.h is included!         


9 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


10 / 129

41    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #ifndef cimg_use_tiff    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     error cimg_use_tiff not defined    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #endif    
42    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #ifndef cimg_plugin_tiff_stream    
41    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #define cimg_plugin_tiff_stream    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #include <ios>    
90    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (!tiffOutStream->good())    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      throw CImgArgumentException(_cimg_instance    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      "save_tiff(): tiffstream is not good!",    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg_instance);    
44    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (is_empty())    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      throw CImgArgumentException(_cimg_instance    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      "Not allowed to write empty images to stream",    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg_instance    
48    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      );    
52    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (tif)    
62    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      tiffOutStream->flush();    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      TIFFClose(tif);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      else    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      throw CImgIOException(_cimg_instance    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      "save_tiff(): Failed to stream for writing.",    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg_instance);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      return *this;    
49    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     CImg<T>& load_tiff(std::istream* tiffInStream,    
60    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      const unsigned int step_frame=1)    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      const unsigned int    
56    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      nstep_frame = step_frame?step_frame:1;    
67    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
51    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
45    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (tif)    
41    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      unsigned int nb_images = 0;    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      do     
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      ++nb_images;    
44    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000       while (TIFFReadDirectory(tif));    
65    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
48    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
43    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (nfirst_frame>=nb_images)    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      return assign();    
44    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (nlast_frame>=nb_images)    
44    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      nlast_frame = nb_images-1;    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      TIFFSetDirectory(tif,0);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      CImg<T> frame;    
61    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      frame._load_tiff(tif,l);    
101    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
106    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
51    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      TIFFClose(tif);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      else    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      throw CImgIOException(_cimg_instance    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      "load_tiff(): Failed to read data from stream",    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      cimg_instance);    
47    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      return *this;    
51    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      const unsigned int step_frame=1)    
69    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
46    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000     #endif    
50    #if !defined(MX_API_VER) || MX_API_VER < 0x7030000         


11 / 129

16    typedef int mwSize;     #ifndef cimg_use_tiff    
24    typedef int mwSize;     error cimg_use_tiff not defined    
16    typedef int mwSize;     #endif    
23    typedef int mwSize;     #ifndef cimg_plugin_tiff_stream    
26    typedef int mwSize;     #define cimg_plugin_tiff_stream    
17    typedef int mwSize;     #include <ios>    
86    typedef int mwSize;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25    typedef int mwSize;      if (!tiffOutStream->good())    
36    typedef int mwSize;      throw CImgArgumentException(_cimg_instance    
33    typedef int mwSize;      "save_tiff(): tiffstream is not good!",    
16    typedef int mwSize;      cimg_instance);    
16    typedef int mwSize;      if (is_empty())    
36    typedef int mwSize;      throw CImgArgumentException(_cimg_instance    
38    typedef int mwSize;      "Not allowed to write empty images to stream",    
16    typedef int mwSize;      cimg_instance    
17    typedef int mwSize;      );    
44    typedef int mwSize;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
15    typedef int mwSize;      if (tif)    
59    typedef int mwSize;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
21    typedef int mwSize;      tiffOutStream->flush();    
17    typedef int mwSize;      TIFFClose(tif);    
17    typedef int mwSize;      else    
31    typedef int mwSize;      throw CImgIOException(_cimg_instance    
37    typedef int mwSize;      "save_tiff(): Failed to stream for writing.",    
16    typedef int mwSize;      cimg_instance);    
14    typedef int mwSize;      return *this;    
39    typedef int mwSize;     CImg<T>& load_tiff(std::istream* tiffInStream,    
59    typedef int mwSize;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25    typedef int mwSize;      const unsigned int step_frame=1)    
18    typedef int mwSize;      const unsigned int    
54    typedef int mwSize;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31    typedef int mwSize;      nstep_frame = step_frame?step_frame:1;    
64    typedef int mwSize;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44    typedef int mwSize;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
15    typedef int mwSize;      if (tif)    
19    typedef int mwSize;      unsigned int nb_images = 0;    
17    typedef int mwSize;      do     
16    typedef int mwSize;      ++nb_images;    
27    typedef int mwSize;       while (TIFFReadDirectory(tif));    
67    typedef int mwSize;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
101    typedef int mwSize;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40    typedef int mwSize;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24    typedef int mwSize;      if (nfirst_frame>=nb_images)    
16    typedef int mwSize;      return assign();    
25    typedef int mwSize;      if (nlast_frame>=nb_images)    
22    typedef int mwSize;      nlast_frame = nb_images-1;    
20    typedef int mwSize;      TIFFSetDirectory(tif,0);    
16    typedef int mwSize;      CImg<T> frame;    
60    typedef int mwSize;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
21    typedef int mwSize;      frame._load_tiff(tif,l);    
103    typedef int mwSize;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
71    typedef int mwSize;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109    typedef int mwSize;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45    typedef int mwSize;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
17    typedef int mwSize;      TIFFClose(tif);    
17    typedef int mwSize;      else    
31    typedef int mwSize;      throw CImgIOException(_cimg_instance    
39    typedef int mwSize;      "load_tiff(): Failed to read data from stream",    
16    typedef int mwSize;      cimg_instance);    
14    typedef int mwSize;      return *this;    
47    typedef int mwSize;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59    typedef int mwSize;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25    typedef int mwSize;      const unsigned int step_frame=1)    
66    typedef int mwSize;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
16    typedef int mwSize;     #endif    
19    typedef int mwSize;         


12 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


13 / 129

19    private:     #ifndef cimg_use_tiff    
27    private:     error cimg_use_tiff not defined    
8    private:     #endif    
27    private:     #ifndef cimg_plugin_tiff_stream    
27    private:     #define cimg_plugin_tiff_stream    
13    private:     #include <ios>    
94    private:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25    private:      if (!tiffOutStream->good())    
40    private:      throw CImgArgumentException(_cimg_instance    
37    private:      "save_tiff(): tiffstream is not good!",    
13    private:      cimg_instance);    
14    private:      if (is_empty())    
40    private:      throw CImgArgumentException(_cimg_instance    
42    private:      "Not allowed to write empty images to stream",    
12    private:      cimg_instance    
8    private:      );    
50    private:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
8    private:      if (tif)    
63    private:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
21    private:      tiffOutStream->flush();    
15    private:      TIFFClose(tif);    
7    private:      else    
34    private:      throw CImgIOException(_cimg_instance    
42    private:      "save_tiff(): Failed to stream for writing.",    
13    private:      cimg_instance);    
12    private:      return *this;    
42    private:     CImg<T>& load_tiff(std::istream* tiffInStream,    
64    private:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    private:      const unsigned int step_frame=1)    
17    private:      const unsigned int    
56    private:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33    private:      nstep_frame = step_frame?step_frame:1;    
68    private:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
49    private:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
8    private:      if (tif)    
25    private:      unsigned int nb_images = 0;    
8    private:      do     
10    private:      ++nb_images;    
30    private:       while (TIFFReadDirectory(tif));    
72    private:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
107    private:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44    private:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25    private:      if (nfirst_frame>=nb_images)    
15    private:      return assign();    
24    private:      if (nlast_frame>=nb_images)    
23    private:      nlast_frame = nb_images-1;    
23    private:      TIFFSetDirectory(tif,0);    
13    private:      CImg<T> frame;    
64    private:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22    private:      frame._load_tiff(tif,l);    
109    private:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
74    private:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
111    private:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    private:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
15    private:      TIFFClose(tif);    
7    private:      else    
34    private:      throw CImgIOException(_cimg_instance    
44    private:      "load_tiff(): Failed to read data from stream",    
13    private:      cimg_instance);    
12    private:      return *this;    
52    private:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64    private:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    private:      const unsigned int step_frame=1)    
71    private:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
8    private:     #endif    
8    private:         


14 / 129

37    static int isNumericalClassID(mxClassID id)      #ifndef cimg_use_tiff    
39    static int isNumericalClassID(mxClassID id)      error cimg_use_tiff not defined    
42    static int isNumericalClassID(mxClassID id)      #endif    
39    static int isNumericalClassID(mxClassID id)      #ifndef cimg_plugin_tiff_stream    
38    static int isNumericalClassID(mxClassID id)      #define cimg_plugin_tiff_stream    
39    static int isNumericalClassID(mxClassID id)      #include <ios>    
82    static int isNumericalClassID(mxClassID id)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
37    static int isNumericalClassID(mxClassID id)       if (!tiffOutStream->good())    
38    static int isNumericalClassID(mxClassID id)       throw CImgArgumentException(_cimg_instance    
41    static int isNumericalClassID(mxClassID id)       "save_tiff(): tiffstream is not good!",    
37    static int isNumericalClassID(mxClassID id)       cimg_instance);    
37    static int isNumericalClassID(mxClassID id)       if (is_empty())    
38    static int isNumericalClassID(mxClassID id)       throw CImgArgumentException(_cimg_instance    
43    static int isNumericalClassID(mxClassID id)       "Not allowed to write empty images to stream",    
38    static int isNumericalClassID(mxClassID id)       cimg_instance    
42    static int isNumericalClassID(mxClassID id)       );    
48    static int isNumericalClassID(mxClassID id)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
38    static int isNumericalClassID(mxClassID id)       if (tif)    
57    static int isNumericalClassID(mxClassID id)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
36    static int isNumericalClassID(mxClassID id)       tiffOutStream->flush();    
37    static int isNumericalClassID(mxClassID id)       TIFFClose(tif);    
40    static int isNumericalClassID(mxClassID id)       else    
39    static int isNumericalClassID(mxClassID id)       throw CImgIOException(_cimg_instance    
42    static int isNumericalClassID(mxClassID id)       "save_tiff(): Failed to stream for writing.",    
37    static int isNumericalClassID(mxClassID id)       cimg_instance);    
39    static int isNumericalClassID(mxClassID id)       return *this;    
43    static int isNumericalClassID(mxClassID id)      CImg<T>& load_tiff(std::istream* tiffInStream,    
52    static int isNumericalClassID(mxClassID id)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37    static int isNumericalClassID(mxClassID id)       const unsigned int step_frame=1)    
37    static int isNumericalClassID(mxClassID id)       const unsigned int    
49    static int isNumericalClassID(mxClassID id)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
40    static int isNumericalClassID(mxClassID id)       nstep_frame = step_frame?step_frame:1;    
55    static int isNumericalClassID(mxClassID id)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47    static int isNumericalClassID(mxClassID id)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
38    static int isNumericalClassID(mxClassID id)       if (tif)    
37    static int isNumericalClassID(mxClassID id)       unsigned int nb_images = 0;    
41    static int isNumericalClassID(mxClassID id)       do     
39    static int isNumericalClassID(mxClassID id)       ++nb_images;    
39    static int isNumericalClassID(mxClassID id)        while (TIFFReadDirectory(tif));    
63    static int isNumericalClassID(mxClassID id)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94    static int isNumericalClassID(mxClassID id)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44    static int isNumericalClassID(mxClassID id)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
35    static int isNumericalClassID(mxClassID id)       if (nfirst_frame>=nb_images)    
36    static int isNumericalClassID(mxClassID id)       return assign();    
35    static int isNumericalClassID(mxClassID id)       if (nlast_frame>=nb_images)    
37    static int isNumericalClassID(mxClassID id)       nlast_frame = nb_images-1;    
38    static int isNumericalClassID(mxClassID id)       TIFFSetDirectory(tif,0);    
40    static int isNumericalClassID(mxClassID id)       CImg<T> frame;    
51    static int isNumericalClassID(mxClassID id)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
38    static int isNumericalClassID(mxClassID id)       frame._load_tiff(tif,l);    
96    static int isNumericalClassID(mxClassID id)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68    static int isNumericalClassID(mxClassID id)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102    static int isNumericalClassID(mxClassID id)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46    static int isNumericalClassID(mxClassID id)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
37    static int isNumericalClassID(mxClassID id)       TIFFClose(tif);    
40    static int isNumericalClassID(mxClassID id)       else    
39    static int isNumericalClassID(mxClassID id)       throw CImgIOException(_cimg_instance    
42    static int isNumericalClassID(mxClassID id)       "load_tiff(): Failed to read data from stream",    
37    static int isNumericalClassID(mxClassID id)       cimg_instance);    
39    static int isNumericalClassID(mxClassID id)       return *this;    
43    static int isNumericalClassID(mxClassID id)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
52    static int isNumericalClassID(mxClassID id)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37    static int isNumericalClassID(mxClassID id)       const unsigned int step_frame=1)    
62    static int isNumericalClassID(mxClassID id)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
42    static int isNumericalClassID(mxClassID id)      #endif    
44    static int isNumericalClassID(mxClassID id)          


15 / 129

19     switch (id)      #ifndef cimg_use_tiff    
26     switch (id)      error cimg_use_tiff not defined    
12     switch (id)      #endif    
28     switch (id)      #ifndef cimg_plugin_tiff_stream    
28     switch (id)      #define cimg_plugin_tiff_stream    
12     switch (id)      #include <ios>    
89     switch (id)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
23     switch (id)       if (!tiffOutStream->good())    
37     switch (id)       throw CImgArgumentException(_cimg_instance    
34     switch (id)       "save_tiff(): tiffstream is not good!",    
13     switch (id)       cimg_instance);    
13     switch (id)       if (is_empty())    
37     switch (id)       throw CImgArgumentException(_cimg_instance    
41     switch (id)       "Not allowed to write empty images to stream",    
13     switch (id)       cimg_instance    
11     switch (id)       );    
48     switch (id)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
8     switch (id)       if (tif)    
61     switch (id)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
21     switch (id)       tiffOutStream->flush();    
12     switch (id)       TIFFClose(tif);    
12     switch (id)       else    
32     switch (id)       throw CImgIOException(_cimg_instance    
39     switch (id)       "save_tiff(): Failed to stream for writing.",    
13     switch (id)       cimg_instance);    
12     switch (id)       return *this;    
40     switch (id)      CImg<T>& load_tiff(std::istream* tiffInStream,    
60     switch (id)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (id)       const unsigned int step_frame=1)    
15     switch (id)       const unsigned int    
57     switch (id)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
36     switch (id)       nstep_frame = step_frame?step_frame:1;    
68     switch (id)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     switch (id)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
8     switch (id)       if (tif)    
22     switch (id)       unsigned int nb_images = 0;    
10     switch (id)       do     
12     switch (id)       ++nb_images;    
26     switch (id)        while (TIFFReadDirectory(tif));    
70     switch (id)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
105     switch (id)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     switch (id)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     switch (id)       if (nfirst_frame>=nb_images)    
13     switch (id)       return assign();    
25     switch (id)       if (nlast_frame>=nb_images)    
23     switch (id)       nlast_frame = nb_images-1;    
19     switch (id)       TIFFSetDirectory(tif,0);    
13     switch (id)       CImg<T> frame;    
61     switch (id)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     switch (id)       frame._load_tiff(tif,l);    
105     switch (id)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
71     switch (id)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
108     switch (id)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     switch (id)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
12     switch (id)       TIFFClose(tif);    
12     switch (id)       else    
32     switch (id)       throw CImgIOException(_cimg_instance    
42     switch (id)       "load_tiff(): Failed to read data from stream",    
13     switch (id)       cimg_instance);    
12     switch (id)       return *this;    
50     switch (id)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     switch (id)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (id)       const unsigned int step_frame=1)    
71     switch (id)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
12     switch (id)      #endif    
13     switch (id)          


16 / 129

21     case mxLOGICAL_CLASS:     #ifndef cimg_use_tiff    
27     case mxLOGICAL_CLASS:     error cimg_use_tiff not defined    
21     case mxLOGICAL_CLASS:     #endif    
27     case mxLOGICAL_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxLOGICAL_CLASS:     #define cimg_plugin_tiff_stream    
22     case mxLOGICAL_CLASS:     #include <ios>    
92     case mxLOGICAL_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     case mxLOGICAL_CLASS:      if (!tiffOutStream->good())    
38     case mxLOGICAL_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxLOGICAL_CLASS:      "save_tiff(): tiffstream is not good!",    
19     case mxLOGICAL_CLASS:      cimg_instance);    
20     case mxLOGICAL_CLASS:      if (is_empty())    
38     case mxLOGICAL_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxLOGICAL_CLASS:      "Not allowed to write empty images to stream",    
19     case mxLOGICAL_CLASS:      cimg_instance    
21     case mxLOGICAL_CLASS:      );    
49     case mxLOGICAL_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
20     case mxLOGICAL_CLASS:      if (tif)    
62     case mxLOGICAL_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxLOGICAL_CLASS:      tiffOutStream->flush();    
21     case mxLOGICAL_CLASS:      TIFFClose(tif);    
19     case mxLOGICAL_CLASS:      else    
32     case mxLOGICAL_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxLOGICAL_CLASS:      "save_tiff(): Failed to stream for writing.",    
19     case mxLOGICAL_CLASS:      cimg_instance);    
20     case mxLOGICAL_CLASS:      return *this;    
41     case mxLOGICAL_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxLOGICAL_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     case mxLOGICAL_CLASS:      const unsigned int step_frame=1)    
19     case mxLOGICAL_CLASS:      const unsigned int    
55     case mxLOGICAL_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     case mxLOGICAL_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxLOGICAL_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxLOGICAL_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
20     case mxLOGICAL_CLASS:      if (tif)    
24     case mxLOGICAL_CLASS:      unsigned int nb_images = 0;    
20     case mxLOGICAL_CLASS:      do     
21     case mxLOGICAL_CLASS:      ++nb_images;    
30     case mxLOGICAL_CLASS:       while (TIFFReadDirectory(tif));    
71     case mxLOGICAL_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxLOGICAL_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxLOGICAL_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxLOGICAL_CLASS:      if (nfirst_frame>=nb_images)    
20     case mxLOGICAL_CLASS:      return assign();    
24     case mxLOGICAL_CLASS:      if (nlast_frame>=nb_images)    
23     case mxLOGICAL_CLASS:      nlast_frame = nb_images-1;    
23     case mxLOGICAL_CLASS:      TIFFSetDirectory(tif,0);    
20     case mxLOGICAL_CLASS:      CImg<T> frame;    
63     case mxLOGICAL_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxLOGICAL_CLASS:      frame._load_tiff(tif,l);    
108     case mxLOGICAL_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxLOGICAL_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxLOGICAL_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxLOGICAL_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
21     case mxLOGICAL_CLASS:      TIFFClose(tif);    
19     case mxLOGICAL_CLASS:      else    
32     case mxLOGICAL_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxLOGICAL_CLASS:      "load_tiff(): Failed to read data from stream",    
19     case mxLOGICAL_CLASS:      cimg_instance);    
20     case mxLOGICAL_CLASS:      return *this;    
51     case mxLOGICAL_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxLOGICAL_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     case mxLOGICAL_CLASS:      const unsigned int step_frame=1)    
71     case mxLOGICAL_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
21     case mxLOGICAL_CLASS:     #endif    
22     case mxLOGICAL_CLASS:         


17 / 129

20     case mxDOUBLE_CLASS:     #ifndef cimg_use_tiff    
27     case mxDOUBLE_CLASS:     error cimg_use_tiff not defined    
20     case mxDOUBLE_CLASS:     #endif    
27     case mxDOUBLE_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxDOUBLE_CLASS:     #define cimg_plugin_tiff_stream    
21     case mxDOUBLE_CLASS:     #include <ios>    
92     case mxDOUBLE_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     case mxDOUBLE_CLASS:      if (!tiffOutStream->good())    
38     case mxDOUBLE_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxDOUBLE_CLASS:      "save_tiff(): tiffstream is not good!",    
18     case mxDOUBLE_CLASS:      cimg_instance);    
19     case mxDOUBLE_CLASS:      if (is_empty())    
38     case mxDOUBLE_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxDOUBLE_CLASS:      "Not allowed to write empty images to stream",    
18     case mxDOUBLE_CLASS:      cimg_instance    
20     case mxDOUBLE_CLASS:      );    
49     case mxDOUBLE_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     case mxDOUBLE_CLASS:      if (tif)    
62     case mxDOUBLE_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxDOUBLE_CLASS:      tiffOutStream->flush();    
20     case mxDOUBLE_CLASS:      TIFFClose(tif);    
18     case mxDOUBLE_CLASS:      else    
32     case mxDOUBLE_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxDOUBLE_CLASS:      "save_tiff(): Failed to stream for writing.",    
18     case mxDOUBLE_CLASS:      cimg_instance);    
19     case mxDOUBLE_CLASS:      return *this;    
41     case mxDOUBLE_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxDOUBLE_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxDOUBLE_CLASS:      const unsigned int step_frame=1)    
18     case mxDOUBLE_CLASS:      const unsigned int    
55     case mxDOUBLE_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     case mxDOUBLE_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxDOUBLE_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxDOUBLE_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     case mxDOUBLE_CLASS:      if (tif)    
24     case mxDOUBLE_CLASS:      unsigned int nb_images = 0;    
19     case mxDOUBLE_CLASS:      do     
20     case mxDOUBLE_CLASS:      ++nb_images;    
29     case mxDOUBLE_CLASS:       while (TIFFReadDirectory(tif));    
70     case mxDOUBLE_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxDOUBLE_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxDOUBLE_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxDOUBLE_CLASS:      if (nfirst_frame>=nb_images)    
19     case mxDOUBLE_CLASS:      return assign();    
24     case mxDOUBLE_CLASS:      if (nlast_frame>=nb_images)    
23     case mxDOUBLE_CLASS:      nlast_frame = nb_images-1;    
23     case mxDOUBLE_CLASS:      TIFFSetDirectory(tif,0);    
19     case mxDOUBLE_CLASS:      CImg<T> frame;    
63     case mxDOUBLE_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxDOUBLE_CLASS:      frame._load_tiff(tif,l);    
108     case mxDOUBLE_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxDOUBLE_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxDOUBLE_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxDOUBLE_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
20     case mxDOUBLE_CLASS:      TIFFClose(tif);    
18     case mxDOUBLE_CLASS:      else    
32     case mxDOUBLE_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxDOUBLE_CLASS:      "load_tiff(): Failed to read data from stream",    
18     case mxDOUBLE_CLASS:      cimg_instance);    
19     case mxDOUBLE_CLASS:      return *this;    
51     case mxDOUBLE_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxDOUBLE_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxDOUBLE_CLASS:      const unsigned int step_frame=1)    
71     case mxDOUBLE_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
20     case mxDOUBLE_CLASS:     #endif    
21     case mxDOUBLE_CLASS:         


18 / 129

20     case mxSINGLE_CLASS:     #ifndef cimg_use_tiff    
27     case mxSINGLE_CLASS:     error cimg_use_tiff not defined    
20     case mxSINGLE_CLASS:     #endif    
27     case mxSINGLE_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxSINGLE_CLASS:     #define cimg_plugin_tiff_stream    
21     case mxSINGLE_CLASS:     #include <ios>    
92     case mxSINGLE_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     case mxSINGLE_CLASS:      if (!tiffOutStream->good())    
38     case mxSINGLE_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxSINGLE_CLASS:      "save_tiff(): tiffstream is not good!",    
18     case mxSINGLE_CLASS:      cimg_instance);    
19     case mxSINGLE_CLASS:      if (is_empty())    
38     case mxSINGLE_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxSINGLE_CLASS:      "Not allowed to write empty images to stream",    
18     case mxSINGLE_CLASS:      cimg_instance    
20     case mxSINGLE_CLASS:      );    
49     case mxSINGLE_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     case mxSINGLE_CLASS:      if (tif)    
62     case mxSINGLE_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22     case mxSINGLE_CLASS:      tiffOutStream->flush();    
20     case mxSINGLE_CLASS:      TIFFClose(tif);    
18     case mxSINGLE_CLASS:      else    
32     case mxSINGLE_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxSINGLE_CLASS:      "save_tiff(): Failed to stream for writing.",    
18     case mxSINGLE_CLASS:      cimg_instance);    
19     case mxSINGLE_CLASS:      return *this;    
41     case mxSINGLE_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxSINGLE_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxSINGLE_CLASS:      const unsigned int step_frame=1)    
18     case mxSINGLE_CLASS:      const unsigned int    
55     case mxSINGLE_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     case mxSINGLE_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxSINGLE_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxSINGLE_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     case mxSINGLE_CLASS:      if (tif)    
24     case mxSINGLE_CLASS:      unsigned int nb_images = 0;    
19     case mxSINGLE_CLASS:      do     
20     case mxSINGLE_CLASS:      ++nb_images;    
30     case mxSINGLE_CLASS:       while (TIFFReadDirectory(tif));    
71     case mxSINGLE_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxSINGLE_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxSINGLE_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxSINGLE_CLASS:      if (nfirst_frame>=nb_images)    
19     case mxSINGLE_CLASS:      return assign();    
24     case mxSINGLE_CLASS:      if (nlast_frame>=nb_images)    
23     case mxSINGLE_CLASS:      nlast_frame = nb_images-1;    
23     case mxSINGLE_CLASS:      TIFFSetDirectory(tif,0);    
19     case mxSINGLE_CLASS:      CImg<T> frame;    
63     case mxSINGLE_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxSINGLE_CLASS:      frame._load_tiff(tif,l);    
108     case mxSINGLE_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxSINGLE_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxSINGLE_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxSINGLE_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
20     case mxSINGLE_CLASS:      TIFFClose(tif);    
18     case mxSINGLE_CLASS:      else    
32     case mxSINGLE_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxSINGLE_CLASS:      "load_tiff(): Failed to read data from stream",    
18     case mxSINGLE_CLASS:      cimg_instance);    
19     case mxSINGLE_CLASS:      return *this;    
51     case mxSINGLE_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxSINGLE_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxSINGLE_CLASS:      const unsigned int step_frame=1)    
71     case mxSINGLE_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
20     case mxSINGLE_CLASS:     #endif    
21     case mxSINGLE_CLASS:         


19 / 129

19     case mxINT8_CLASS:     #ifndef cimg_use_tiff    
27     case mxINT8_CLASS:     error cimg_use_tiff not defined    
18     case mxINT8_CLASS:     #endif    
27     case mxINT8_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxINT8_CLASS:     #define cimg_plugin_tiff_stream    
19     case mxINT8_CLASS:     #include <ios>    
92     case mxINT8_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxINT8_CLASS:      if (!tiffOutStream->good())    
38     case mxINT8_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxINT8_CLASS:      "save_tiff(): tiffstream is not good!",    
16     case mxINT8_CLASS:      cimg_instance);    
17     case mxINT8_CLASS:      if (is_empty())    
38     case mxINT8_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxINT8_CLASS:      "Not allowed to write empty images to stream",    
16     case mxINT8_CLASS:      cimg_instance    
18     case mxINT8_CLASS:      );    
49     case mxINT8_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
17     case mxINT8_CLASS:      if (tif)    
62     case mxINT8_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxINT8_CLASS:      tiffOutStream->flush();    
18     case mxINT8_CLASS:      TIFFClose(tif);    
16     case mxINT8_CLASS:      else    
32     case mxINT8_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxINT8_CLASS:      "save_tiff(): Failed to stream for writing.",    
16     case mxINT8_CLASS:      cimg_instance);    
17     case mxINT8_CLASS:      return *this;    
41     case mxINT8_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxINT8_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT8_CLASS:      const unsigned int step_frame=1)    
16     case mxINT8_CLASS:      const unsigned int    
55     case mxINT8_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     case mxINT8_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxINT8_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxINT8_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
17     case mxINT8_CLASS:      if (tif)    
23     case mxINT8_CLASS:      unsigned int nb_images = 0;    
17     case mxINT8_CLASS:      do     
18     case mxINT8_CLASS:      ++nb_images;    
29     case mxINT8_CLASS:       while (TIFFReadDirectory(tif));    
70     case mxINT8_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxINT8_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxINT8_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     case mxINT8_CLASS:      if (nfirst_frame>=nb_images)    
17     case mxINT8_CLASS:      return assign();    
23     case mxINT8_CLASS:      if (nlast_frame>=nb_images)    
22     case mxINT8_CLASS:      nlast_frame = nb_images-1;    
23     case mxINT8_CLASS:      TIFFSetDirectory(tif,0);    
16     case mxINT8_CLASS:      CImg<T> frame;    
63     case mxINT8_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxINT8_CLASS:      frame._load_tiff(tif,l);    
108     case mxINT8_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxINT8_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxINT8_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxINT8_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
18     case mxINT8_CLASS:      TIFFClose(tif);    
16     case mxINT8_CLASS:      else    
32     case mxINT8_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxINT8_CLASS:      "load_tiff(): Failed to read data from stream",    
16     case mxINT8_CLASS:      cimg_instance);    
17     case mxINT8_CLASS:      return *this;    
51     case mxINT8_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxINT8_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT8_CLASS:      const unsigned int step_frame=1)    
70     case mxINT8_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
18     case mxINT8_CLASS:     #endif    
19     case mxINT8_CLASS:         


20 / 129

20     case mxUINT8_CLASS:     #ifndef cimg_use_tiff    
27     case mxUINT8_CLASS:     error cimg_use_tiff not defined    
19     case mxUINT8_CLASS:     #endif    
27     case mxUINT8_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxUINT8_CLASS:     #define cimg_plugin_tiff_stream    
20     case mxUINT8_CLASS:     #include <ios>    
92     case mxUINT8_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxUINT8_CLASS:      if (!tiffOutStream->good())    
38     case mxUINT8_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxUINT8_CLASS:      "save_tiff(): tiffstream is not good!",    
17     case mxUINT8_CLASS:      cimg_instance);    
18     case mxUINT8_CLASS:      if (is_empty())    
38     case mxUINT8_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxUINT8_CLASS:      "Not allowed to write empty images to stream",    
17     case mxUINT8_CLASS:      cimg_instance    
19     case mxUINT8_CLASS:      );    
49     case mxUINT8_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
18     case mxUINT8_CLASS:      if (tif)    
62     case mxUINT8_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxUINT8_CLASS:      tiffOutStream->flush();    
19     case mxUINT8_CLASS:      TIFFClose(tif);    
17     case mxUINT8_CLASS:      else    
32     case mxUINT8_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxUINT8_CLASS:      "save_tiff(): Failed to stream for writing.",    
17     case mxUINT8_CLASS:      cimg_instance);    
18     case mxUINT8_CLASS:      return *this;    
41     case mxUINT8_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxUINT8_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT8_CLASS:      const unsigned int step_frame=1)    
17     case mxUINT8_CLASS:      const unsigned int    
55     case mxUINT8_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     case mxUINT8_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxUINT8_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxUINT8_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
18     case mxUINT8_CLASS:      if (tif)    
24     case mxUINT8_CLASS:      unsigned int nb_images = 0;    
18     case mxUINT8_CLASS:      do     
19     case mxUINT8_CLASS:      ++nb_images;    
30     case mxUINT8_CLASS:       while (TIFFReadDirectory(tif));    
70     case mxUINT8_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxUINT8_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxUINT8_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxUINT8_CLASS:      if (nfirst_frame>=nb_images)    
18     case mxUINT8_CLASS:      return assign();    
24     case mxUINT8_CLASS:      if (nlast_frame>=nb_images)    
22     case mxUINT8_CLASS:      nlast_frame = nb_images-1;    
23     case mxUINT8_CLASS:      TIFFSetDirectory(tif,0);    
17     case mxUINT8_CLASS:      CImg<T> frame;    
63     case mxUINT8_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxUINT8_CLASS:      frame._load_tiff(tif,l);    
108     case mxUINT8_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxUINT8_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxUINT8_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxUINT8_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     case mxUINT8_CLASS:      TIFFClose(tif);    
17     case mxUINT8_CLASS:      else    
32     case mxUINT8_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxUINT8_CLASS:      "load_tiff(): Failed to read data from stream",    
17     case mxUINT8_CLASS:      cimg_instance);    
18     case mxUINT8_CLASS:      return *this;    
51     case mxUINT8_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxUINT8_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT8_CLASS:      const unsigned int step_frame=1)    
70     case mxUINT8_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
19     case mxUINT8_CLASS:     #endif    
20     case mxUINT8_CLASS:         


21 / 129

20     case mxINT16_CLASS:     #ifndef cimg_use_tiff    
27     case mxINT16_CLASS:     error cimg_use_tiff not defined    
19     case mxINT16_CLASS:     #endif    
27     case mxINT16_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxINT16_CLASS:     #define cimg_plugin_tiff_stream    
20     case mxINT16_CLASS:     #include <ios>    
92     case mxINT16_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxINT16_CLASS:      if (!tiffOutStream->good())    
38     case mxINT16_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxINT16_CLASS:      "save_tiff(): tiffstream is not good!",    
17     case mxINT16_CLASS:      cimg_instance);    
18     case mxINT16_CLASS:      if (is_empty())    
38     case mxINT16_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxINT16_CLASS:      "Not allowed to write empty images to stream",    
17     case mxINT16_CLASS:      cimg_instance    
19     case mxINT16_CLASS:      );    
49     case mxINT16_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
18     case mxINT16_CLASS:      if (tif)    
62     case mxINT16_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxINT16_CLASS:      tiffOutStream->flush();    
19     case mxINT16_CLASS:      TIFFClose(tif);    
17     case mxINT16_CLASS:      else    
32     case mxINT16_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxINT16_CLASS:      "save_tiff(): Failed to stream for writing.",    
17     case mxINT16_CLASS:      cimg_instance);    
18     case mxINT16_CLASS:      return *this;    
41     case mxINT16_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxINT16_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT16_CLASS:      const unsigned int step_frame=1)    
17     case mxINT16_CLASS:      const unsigned int    
55     case mxINT16_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     case mxINT16_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxINT16_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxINT16_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
18     case mxINT16_CLASS:      if (tif)    
24     case mxINT16_CLASS:      unsigned int nb_images = 0;    
18     case mxINT16_CLASS:      do     
19     case mxINT16_CLASS:      ++nb_images;    
29     case mxINT16_CLASS:       while (TIFFReadDirectory(tif));    
71     case mxINT16_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxINT16_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxINT16_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxINT16_CLASS:      if (nfirst_frame>=nb_images)    
18     case mxINT16_CLASS:      return assign();    
24     case mxINT16_CLASS:      if (nlast_frame>=nb_images)    
22     case mxINT16_CLASS:      nlast_frame = nb_images-1;    
23     case mxINT16_CLASS:      TIFFSetDirectory(tif,0);    
17     case mxINT16_CLASS:      CImg<T> frame;    
63     case mxINT16_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxINT16_CLASS:      frame._load_tiff(tif,l);    
107     case mxINT16_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxINT16_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxINT16_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxINT16_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     case mxINT16_CLASS:      TIFFClose(tif);    
17     case mxINT16_CLASS:      else    
32     case mxINT16_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxINT16_CLASS:      "load_tiff(): Failed to read data from stream",    
17     case mxINT16_CLASS:      cimg_instance);    
18     case mxINT16_CLASS:      return *this;    
51     case mxINT16_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxINT16_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT16_CLASS:      const unsigned int step_frame=1)    
70     case mxINT16_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
19     case mxINT16_CLASS:     #endif    
20     case mxINT16_CLASS:         


22 / 129

20     case mxUINT16_CLASS:     #ifndef cimg_use_tiff    
27     case mxUINT16_CLASS:     error cimg_use_tiff not defined    
20     case mxUINT16_CLASS:     #endif    
27     case mxUINT16_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxUINT16_CLASS:     #define cimg_plugin_tiff_stream    
21     case mxUINT16_CLASS:     #include <ios>    
92     case mxUINT16_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxUINT16_CLASS:      if (!tiffOutStream->good())    
38     case mxUINT16_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxUINT16_CLASS:      "save_tiff(): tiffstream is not good!",    
18     case mxUINT16_CLASS:      cimg_instance);    
19     case mxUINT16_CLASS:      if (is_empty())    
38     case mxUINT16_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxUINT16_CLASS:      "Not allowed to write empty images to stream",    
18     case mxUINT16_CLASS:      cimg_instance    
20     case mxUINT16_CLASS:      );    
49     case mxUINT16_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     case mxUINT16_CLASS:      if (tif)    
62     case mxUINT16_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxUINT16_CLASS:      tiffOutStream->flush();    
20     case mxUINT16_CLASS:      TIFFClose(tif);    
18     case mxUINT16_CLASS:      else    
32     case mxUINT16_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxUINT16_CLASS:      "save_tiff(): Failed to stream for writing.",    
18     case mxUINT16_CLASS:      cimg_instance);    
19     case mxUINT16_CLASS:      return *this;    
41     case mxUINT16_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxUINT16_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT16_CLASS:      const unsigned int step_frame=1)    
18     case mxUINT16_CLASS:      const unsigned int    
55     case mxUINT16_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     case mxUINT16_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxUINT16_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxUINT16_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     case mxUINT16_CLASS:      if (tif)    
24     case mxUINT16_CLASS:      unsigned int nb_images = 0;    
19     case mxUINT16_CLASS:      do     
20     case mxUINT16_CLASS:      ++nb_images;    
30     case mxUINT16_CLASS:       while (TIFFReadDirectory(tif));    
70     case mxUINT16_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxUINT16_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxUINT16_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxUINT16_CLASS:      if (nfirst_frame>=nb_images)    
19     case mxUINT16_CLASS:      return assign();    
24     case mxUINT16_CLASS:      if (nlast_frame>=nb_images)    
23     case mxUINT16_CLASS:      nlast_frame = nb_images-1;    
23     case mxUINT16_CLASS:      TIFFSetDirectory(tif,0);    
18     case mxUINT16_CLASS:      CImg<T> frame;    
63     case mxUINT16_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxUINT16_CLASS:      frame._load_tiff(tif,l);    
107     case mxUINT16_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxUINT16_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxUINT16_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxUINT16_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
20     case mxUINT16_CLASS:      TIFFClose(tif);    
18     case mxUINT16_CLASS:      else    
32     case mxUINT16_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxUINT16_CLASS:      "load_tiff(): Failed to read data from stream",    
18     case mxUINT16_CLASS:      cimg_instance);    
19     case mxUINT16_CLASS:      return *this;    
51     case mxUINT16_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxUINT16_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT16_CLASS:      const unsigned int step_frame=1)    
71     case mxUINT16_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
20     case mxUINT16_CLASS:     #endif    
21     case mxUINT16_CLASS:         


23 / 129

20     case mxINT32_CLASS:     #ifndef cimg_use_tiff    
27     case mxINT32_CLASS:     error cimg_use_tiff not defined    
19     case mxINT32_CLASS:     #endif    
27     case mxINT32_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxINT32_CLASS:     #define cimg_plugin_tiff_stream    
20     case mxINT32_CLASS:     #include <ios>    
92     case mxINT32_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxINT32_CLASS:      if (!tiffOutStream->good())    
38     case mxINT32_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxINT32_CLASS:      "save_tiff(): tiffstream is not good!",    
17     case mxINT32_CLASS:      cimg_instance);    
18     case mxINT32_CLASS:      if (is_empty())    
38     case mxINT32_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxINT32_CLASS:      "Not allowed to write empty images to stream",    
17     case mxINT32_CLASS:      cimg_instance    
19     case mxINT32_CLASS:      );    
49     case mxINT32_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
18     case mxINT32_CLASS:      if (tif)    
62     case mxINT32_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxINT32_CLASS:      tiffOutStream->flush();    
19     case mxINT32_CLASS:      TIFFClose(tif);    
17     case mxINT32_CLASS:      else    
32     case mxINT32_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxINT32_CLASS:      "save_tiff(): Failed to stream for writing.",    
17     case mxINT32_CLASS:      cimg_instance);    
18     case mxINT32_CLASS:      return *this;    
41     case mxINT32_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxINT32_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT32_CLASS:      const unsigned int step_frame=1)    
17     case mxINT32_CLASS:      const unsigned int    
55     case mxINT32_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     case mxINT32_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxINT32_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxINT32_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
18     case mxINT32_CLASS:      if (tif)    
24     case mxINT32_CLASS:      unsigned int nb_images = 0;    
18     case mxINT32_CLASS:      do     
19     case mxINT32_CLASS:      ++nb_images;    
29     case mxINT32_CLASS:       while (TIFFReadDirectory(tif));    
71     case mxINT32_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxINT32_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxINT32_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxINT32_CLASS:      if (nfirst_frame>=nb_images)    
18     case mxINT32_CLASS:      return assign();    
24     case mxINT32_CLASS:      if (nlast_frame>=nb_images)    
22     case mxINT32_CLASS:      nlast_frame = nb_images-1;    
23     case mxINT32_CLASS:      TIFFSetDirectory(tif,0);    
17     case mxINT32_CLASS:      CImg<T> frame;    
63     case mxINT32_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxINT32_CLASS:      frame._load_tiff(tif,l);    
108     case mxINT32_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxINT32_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxINT32_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxINT32_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     case mxINT32_CLASS:      TIFFClose(tif);    
17     case mxINT32_CLASS:      else    
32     case mxINT32_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxINT32_CLASS:      "load_tiff(): Failed to read data from stream",    
17     case mxINT32_CLASS:      cimg_instance);    
18     case mxINT32_CLASS:      return *this;    
51     case mxINT32_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxINT32_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT32_CLASS:      const unsigned int step_frame=1)    
70     case mxINT32_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
19     case mxINT32_CLASS:     #endif    
20     case mxINT32_CLASS:         


24 / 129

20     case mxUINT32_CLASS:     #ifndef cimg_use_tiff    
27     case mxUINT32_CLASS:     error cimg_use_tiff not defined    
20     case mxUINT32_CLASS:     #endif    
27     case mxUINT32_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxUINT32_CLASS:     #define cimg_plugin_tiff_stream    
21     case mxUINT32_CLASS:     #include <ios>    
92     case mxUINT32_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxUINT32_CLASS:      if (!tiffOutStream->good())    
38     case mxUINT32_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxUINT32_CLASS:      "save_tiff(): tiffstream is not good!",    
18     case mxUINT32_CLASS:      cimg_instance);    
19     case mxUINT32_CLASS:      if (is_empty())    
38     case mxUINT32_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxUINT32_CLASS:      "Not allowed to write empty images to stream",    
18     case mxUINT32_CLASS:      cimg_instance    
20     case mxUINT32_CLASS:      );    
49     case mxUINT32_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     case mxUINT32_CLASS:      if (tif)    
62     case mxUINT32_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxUINT32_CLASS:      tiffOutStream->flush();    
20     case mxUINT32_CLASS:      TIFFClose(tif);    
18     case mxUINT32_CLASS:      else    
32     case mxUINT32_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxUINT32_CLASS:      "save_tiff(): Failed to stream for writing.",    
18     case mxUINT32_CLASS:      cimg_instance);    
19     case mxUINT32_CLASS:      return *this;    
41     case mxUINT32_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxUINT32_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT32_CLASS:      const unsigned int step_frame=1)    
18     case mxUINT32_CLASS:      const unsigned int    
55     case mxUINT32_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     case mxUINT32_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxUINT32_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxUINT32_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     case mxUINT32_CLASS:      if (tif)    
24     case mxUINT32_CLASS:      unsigned int nb_images = 0;    
19     case mxUINT32_CLASS:      do     
20     case mxUINT32_CLASS:      ++nb_images;    
30     case mxUINT32_CLASS:       while (TIFFReadDirectory(tif));    
70     case mxUINT32_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxUINT32_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxUINT32_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxUINT32_CLASS:      if (nfirst_frame>=nb_images)    
19     case mxUINT32_CLASS:      return assign();    
24     case mxUINT32_CLASS:      if (nlast_frame>=nb_images)    
23     case mxUINT32_CLASS:      nlast_frame = nb_images-1;    
23     case mxUINT32_CLASS:      TIFFSetDirectory(tif,0);    
18     case mxUINT32_CLASS:      CImg<T> frame;    
63     case mxUINT32_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxUINT32_CLASS:      frame._load_tiff(tif,l);    
108     case mxUINT32_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxUINT32_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxUINT32_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxUINT32_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
20     case mxUINT32_CLASS:      TIFFClose(tif);    
18     case mxUINT32_CLASS:      else    
32     case mxUINT32_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxUINT32_CLASS:      "load_tiff(): Failed to read data from stream",    
18     case mxUINT32_CLASS:      cimg_instance);    
19     case mxUINT32_CLASS:      return *this;    
51     case mxUINT32_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxUINT32_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxUINT32_CLASS:      const unsigned int step_frame=1)    
71     case mxUINT32_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
20     case mxUINT32_CLASS:     #endif    
21     case mxUINT32_CLASS:         


25 / 129

20     case mxINT64_CLASS:     #ifndef cimg_use_tiff    
27     case mxINT64_CLASS:     error cimg_use_tiff not defined    
19     case mxINT64_CLASS:     #endif    
27     case mxINT64_CLASS:     #ifndef cimg_plugin_tiff_stream    
27     case mxINT64_CLASS:     #define cimg_plugin_tiff_stream    
20     case mxINT64_CLASS:     #include <ios>    
92     case mxINT64_CLASS:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27     case mxINT64_CLASS:      if (!tiffOutStream->good())    
38     case mxINT64_CLASS:      throw CImgArgumentException(_cimg_instance    
35     case mxINT64_CLASS:      "save_tiff(): tiffstream is not good!",    
17     case mxINT64_CLASS:      cimg_instance);    
18     case mxINT64_CLASS:      if (is_empty())    
38     case mxINT64_CLASS:      throw CImgArgumentException(_cimg_instance    
42     case mxINT64_CLASS:      "Not allowed to write empty images to stream",    
17     case mxINT64_CLASS:      cimg_instance    
19     case mxINT64_CLASS:      );    
49     case mxINT64_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
18     case mxINT64_CLASS:      if (tif)    
62     case mxINT64_CLASS:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     case mxINT64_CLASS:      tiffOutStream->flush();    
19     case mxINT64_CLASS:      TIFFClose(tif);    
17     case mxINT64_CLASS:      else    
32     case mxINT64_CLASS:      throw CImgIOException(_cimg_instance    
41     case mxINT64_CLASS:      "save_tiff(): Failed to stream for writing.",    
17     case mxINT64_CLASS:      cimg_instance);    
18     case mxINT64_CLASS:      return *this;    
41     case mxINT64_CLASS:     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxINT64_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT64_CLASS:      const unsigned int step_frame=1)    
17     case mxINT64_CLASS:      const unsigned int    
55     case mxINT64_CLASS:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     case mxINT64_CLASS:      nstep_frame = step_frame?step_frame:1;    
66     case mxINT64_CLASS:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     case mxINT64_CLASS:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
18     case mxINT64_CLASS:      if (tif)    
24     case mxINT64_CLASS:      unsigned int nb_images = 0;    
18     case mxINT64_CLASS:      do     
19     case mxINT64_CLASS:      ++nb_images;    
29     case mxINT64_CLASS:       while (TIFFReadDirectory(tif));    
71     case mxINT64_CLASS:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
106     case mxINT64_CLASS:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     case mxINT64_CLASS:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     case mxINT64_CLASS:      if (nfirst_frame>=nb_images)    
18     case mxINT64_CLASS:      return assign();    
24     case mxINT64_CLASS:      if (nlast_frame>=nb_images)    
22     case mxINT64_CLASS:      nlast_frame = nb_images-1;    
23     case mxINT64_CLASS:      TIFFSetDirectory(tif,0);    
17     case mxINT64_CLASS:      CImg<T> frame;    
63     case mxINT64_CLASS:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     case mxINT64_CLASS:      frame._load_tiff(tif,l);    
108     case mxINT64_CLASS:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     case mxINT64_CLASS:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     case mxINT64_CLASS:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47     case mxINT64_CLASS:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     case mxINT64_CLASS:      TIFFClose(tif);    
17     case mxINT64_CLASS:      else    
32     case mxINT64_CLASS:      throw CImgIOException(_cimg_instance    
44     case mxINT64_CLASS:      "load_tiff(): Failed to read data from stream",    
17     case mxINT64_CLASS:      cimg_instance);    
18     case mxINT64_CLASS:      return *this;    
51     case mxINT64_CLASS:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxINT64_CLASS:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     case mxINT64_CLASS:      const unsigned int step_frame=1)    
70     case mxINT64_CLASS:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
19     case mxINT64_CLASS:     #endif    
20     case mxINT64_CLASS:         


26 / 129

29     case mxUINT64_CLASS: return 1;     #ifndef cimg_use_tiff    
28     case mxUINT64_CLASS: return 1;     error cimg_use_tiff not defined    
29     case mxUINT64_CLASS: return 1;     #endif    
29     case mxUINT64_CLASS: return 1;     #ifndef cimg_plugin_tiff_stream    
29     case mxUINT64_CLASS: return 1;     #define cimg_plugin_tiff_stream    
30     case mxUINT64_CLASS: return 1;     #include <ios>    
86     case mxUINT64_CLASS: return 1;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
29     case mxUINT64_CLASS: return 1;      if (!tiffOutStream->good())    
39     case mxUINT64_CLASS: return 1;      throw CImgArgumentException(_cimg_instance    
35     case mxUINT64_CLASS: return 1;      "save_tiff(): tiffstream is not good!",    
25     case mxUINT64_CLASS: return 1;      cimg_instance);    
27     case mxUINT64_CLASS: return 1;      if (is_empty())    
39     case mxUINT64_CLASS: return 1;      throw CImgArgumentException(_cimg_instance    
40     case mxUINT64_CLASS: return 1;      "Not allowed to write empty images to stream",    
25     case mxUINT64_CLASS: return 1;      cimg_instance    
29     case mxUINT64_CLASS: return 1;      );    
46     case mxUINT64_CLASS: return 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
28     case mxUINT64_CLASS: return 1;      if (tif)    
59     case mxUINT64_CLASS: return 1;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
28     case mxUINT64_CLASS: return 1;      tiffOutStream->flush();    
26     case mxUINT64_CLASS: return 1;      TIFFClose(tif);    
28     case mxUINT64_CLASS: return 1;      else    
33     case mxUINT64_CLASS: return 1;      throw CImgIOException(_cimg_instance    
38     case mxUINT64_CLASS: return 1;      "save_tiff(): Failed to stream for writing.",    
25     case mxUINT64_CLASS: return 1;      cimg_instance);    
26     case mxUINT64_CLASS: return 1;      return *this;    
40     case mxUINT64_CLASS: return 1;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     case mxUINT64_CLASS: return 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     case mxUINT64_CLASS: return 1;      const unsigned int step_frame=1)    
26     case mxUINT64_CLASS: return 1;      const unsigned int    
53     case mxUINT64_CLASS: return 1;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     case mxUINT64_CLASS: return 1;      nstep_frame = step_frame?step_frame:1;    
62     case mxUINT64_CLASS: return 1;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46     case mxUINT64_CLASS: return 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
28     case mxUINT64_CLASS: return 1;      if (tif)    
26     case mxUINT64_CLASS: return 1;      unsigned int nb_images = 0;    
29     case mxUINT64_CLASS: return 1;      do     
27     case mxUINT64_CLASS: return 1;      ++nb_images;    
28     case mxUINT64_CLASS: return 1;       while (TIFFReadDirectory(tif));    
68     case mxUINT64_CLASS: return 1;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
100     case mxUINT64_CLASS: return 1;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     case mxUINT64_CLASS: return 1;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
29     case mxUINT64_CLASS: return 1;      if (nfirst_frame>=nb_images)    
26     case mxUINT64_CLASS: return 1;      return assign();    
29     case mxUINT64_CLASS: return 1;      if (nlast_frame>=nb_images)    
26     case mxUINT64_CLASS: return 1;      nlast_frame = nb_images-1;    
27     case mxUINT64_CLASS: return 1;      TIFFSetDirectory(tif,0);    
25     case mxUINT64_CLASS: return 1;      CImg<T> frame;    
59     case mxUINT64_CLASS: return 1;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
26     case mxUINT64_CLASS: return 1;      frame._load_tiff(tif,l);    
102     case mxUINT64_CLASS: return 1;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxUINT64_CLASS: return 1;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
103     case mxUINT64_CLASS: return 1;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     case mxUINT64_CLASS: return 1;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
26     case mxUINT64_CLASS: return 1;      TIFFClose(tif);    
28     case mxUINT64_CLASS: return 1;      else    
33     case mxUINT64_CLASS: return 1;      throw CImgIOException(_cimg_instance    
40     case mxUINT64_CLASS: return 1;      "load_tiff(): Failed to read data from stream",    
25     case mxUINT64_CLASS: return 1;      cimg_instance);    
26     case mxUINT64_CLASS: return 1;      return *this;    
47     case mxUINT64_CLASS: return 1;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     case mxUINT64_CLASS: return 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     case mxUINT64_CLASS: return 1;      const unsigned int step_frame=1)    
66     case mxUINT64_CLASS: return 1;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
29     case mxUINT64_CLASS: return 1;     #endif    
31     case mxUINT64_CLASS: return 1;         


27 / 129

19     default: return 0;     #ifndef cimg_use_tiff    
26     default: return 0;     error cimg_use_tiff not defined    
17     default: return 0;     #endif    
26     default: return 0;     #ifndef cimg_plugin_tiff_stream    
26     default: return 0;     #define cimg_plugin_tiff_stream    
17     default: return 0;     #include <ios>    
86     default: return 0;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
23     default: return 0;      if (!tiffOutStream->good())    
37     default: return 0;      throw CImgArgumentException(_cimg_instance    
32     default: return 0;      "save_tiff(): tiffstream is not good!",    
16     default: return 0;      cimg_instance);    
16     default: return 0;      if (is_empty())    
37     default: return 0;      throw CImgArgumentException(_cimg_instance    
38     default: return 0;      "Not allowed to write empty images to stream",    
16     default: return 0;      cimg_instance    
17     default: return 0;      );    
45     default: return 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
15     default: return 0;      if (tif)    
59     default: return 0;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
17     default: return 0;      tiffOutStream->flush();    
15     default: return 0;      TIFFClose(tif);    
15     default: return 0;      else    
33     default: return 0;      throw CImgIOException(_cimg_instance    
35     default: return 0;      "save_tiff(): Failed to stream for writing.",    
16     default: return 0;      cimg_instance);    
13     default: return 0;      return *this;    
37     default: return 0;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     default: return 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     default: return 0;      const unsigned int step_frame=1)    
17     default: return 0;      const unsigned int    
52     default: return 0;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
29     default: return 0;      nstep_frame = step_frame?step_frame:1;    
62     default: return 0;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     default: return 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
15     default: return 0;      if (tif)    
22     default: return 0;      unsigned int nb_images = 0;    
16     default: return 0;      do     
16     default: return 0;      ++nb_images;    
26     default: return 0;       while (TIFFReadDirectory(tif));    
67     default: return 0;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
100     default: return 0;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
38     default: return 0;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     default: return 0;      if (nfirst_frame>=nb_images)    
13     default: return 0;      return assign();    
23     default: return 0;      if (nlast_frame>=nb_images)    
22     default: return 0;      nlast_frame = nb_images-1;    
17     default: return 0;      TIFFSetDirectory(tif,0);    
15     default: return 0;      CImg<T> frame;    
59     default: return 0;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
19     default: return 0;      frame._load_tiff(tif,l);    
102     default: return 0;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     default: return 0;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
104     default: return 0;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     default: return 0;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
15     default: return 0;      TIFFClose(tif);    
15     default: return 0;      else    
33     default: return 0;      throw CImgIOException(_cimg_instance    
36     default: return 0;      "load_tiff(): Failed to read data from stream",    
16     default: return 0;      cimg_instance);    
13     default: return 0;      return *this;    
47     default: return 0;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     default: return 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     default: return 0;      const unsigned int step_frame=1)    
64     default: return 0;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
17     default: return 0;     #endif    
19     default: return 0;         


28 / 129

71    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #ifndef cimg_use_tiff    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      error cimg_use_tiff not defined    
74    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #endif    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #ifndef cimg_plugin_tiff_stream    
65    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #define cimg_plugin_tiff_stream    
71    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #include <ios>    
80    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (!tiffOutStream->good())    
65    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       throw CImgArgumentException(_cimg_instance    
65    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       "save_tiff(): tiffstream is not good!",    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg_instance);    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (is_empty())    
65    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       throw CImgArgumentException(_cimg_instance    
62    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       "Not allowed to write empty images to stream",    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg_instance    
74    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       );    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
71    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (tif)    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       tiffOutStream->flush();    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       TIFFClose(tif);    
72    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       else    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       throw CImgIOException(_cimg_instance    
63    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       "save_tiff(): Failed to stream for writing.",    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg_instance);    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       return *this;    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      CImg<T>& load_tiff(std::istream* tiffInStream,    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       const unsigned int step_frame=1)    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       const unsigned int    
62    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       nstep_frame = step_frame?step_frame:1;    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
71    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (tif)    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       unsigned int nb_images = 0;    
73    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       do     
70    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       ++nb_images;    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)        while (TIFFReadDirectory(tif));    
69    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
60    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
63    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (nfirst_frame>=nb_images)    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       return assign();    
62    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (nlast_frame>=nb_images)    
65    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       nlast_frame = nb_images-1;    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       TIFFSetDirectory(tif,0);    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       CImg<T> frame;    
63    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       frame._load_tiff(tif,l);    
94    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
72    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
97    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
60    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       TIFFClose(tif);    
72    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       else    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       throw CImgIOException(_cimg_instance    
60    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       "load_tiff(): Failed to read data from stream",    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       cimg_instance);    
68    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       return *this;    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
67    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
64    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       const unsigned int step_frame=1)    
66    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
74    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)      #endif    
76    void makeImageFromMatlabData(const mxArray *matlabArray, mxClassID classID)          


29 / 129

27     if (classID==mxLOGICAL_CLASS)      #ifndef cimg_use_tiff    
31     if (classID==mxLOGICAL_CLASS)      error cimg_use_tiff not defined    
31     if (classID==mxLOGICAL_CLASS)      #endif    
29     if (classID==mxLOGICAL_CLASS)      #ifndef cimg_plugin_tiff_stream    
30     if (classID==mxLOGICAL_CLASS)      #define cimg_plugin_tiff_stream    
28     if (classID==mxLOGICAL_CLASS)      #include <ios>    
88     if (classID==mxLOGICAL_CLASS)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     if (classID==mxLOGICAL_CLASS)       if (!tiffOutStream->good())    
39     if (classID==mxLOGICAL_CLASS)       throw CImgArgumentException(_cimg_instance    
35     if (classID==mxLOGICAL_CLASS)       "save_tiff(): tiffstream is not good!",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
23     if (classID==mxLOGICAL_CLASS)       if (is_empty())    
39     if (classID==mxLOGICAL_CLASS)       throw CImgArgumentException(_cimg_instance    
43     if (classID==mxLOGICAL_CLASS)       "Not allowed to write empty images to stream",    
28     if (classID==mxLOGICAL_CLASS)       cimg_instance    
29     if (classID==mxLOGICAL_CLASS)       );    
46     if (classID==mxLOGICAL_CLASS)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
25     if (classID==mxLOGICAL_CLASS)       if (tif)    
60     if (classID==mxLOGICAL_CLASS)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
27     if (classID==mxLOGICAL_CLASS)       tiffOutStream->flush();    
27     if (classID==mxLOGICAL_CLASS)       TIFFClose(tif);    
28     if (classID==mxLOGICAL_CLASS)       else    
34     if (classID==mxLOGICAL_CLASS)       throw CImgIOException(_cimg_instance    
40     if (classID==mxLOGICAL_CLASS)       "save_tiff(): Failed to stream for writing.",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
30     if (classID==mxLOGICAL_CLASS)       return *this;    
41     if (classID==mxLOGICAL_CLASS)      CImg<T>& load_tiff(std::istream* tiffInStream,    
62     if (classID==mxLOGICAL_CLASS)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30     if (classID==mxLOGICAL_CLASS)       const unsigned int step_frame=1)    
28     if (classID==mxLOGICAL_CLASS)       const unsigned int    
54     if (classID==mxLOGICAL_CLASS)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     if (classID==mxLOGICAL_CLASS)       nstep_frame = step_frame?step_frame:1;    
65     if (classID==mxLOGICAL_CLASS)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     if (classID==mxLOGICAL_CLASS)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
25     if (classID==mxLOGICAL_CLASS)       if (tif)    
30     if (classID==mxLOGICAL_CLASS)       unsigned int nb_images = 0;    
29     if (classID==mxLOGICAL_CLASS)       do     
29     if (classID==mxLOGICAL_CLASS)       ++nb_images;    
30     if (classID==mxLOGICAL_CLASS)        while (TIFFReadDirectory(tif));    
66     if (classID==mxLOGICAL_CLASS)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103     if (classID==mxLOGICAL_CLASS)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     if (classID==mxLOGICAL_CLASS)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     if (classID==mxLOGICAL_CLASS)       if (nfirst_frame>=nb_images)    
27     if (classID==mxLOGICAL_CLASS)       return assign();    
21     if (classID==mxLOGICAL_CLASS)       if (nlast_frame>=nb_images)    
26     if (classID==mxLOGICAL_CLASS)       nlast_frame = nb_images-1;    
28     if (classID==mxLOGICAL_CLASS)       TIFFSetDirectory(tif,0);    
28     if (classID==mxLOGICAL_CLASS)       CImg<T> frame;    
58     if (classID==mxLOGICAL_CLASS)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
27     if (classID==mxLOGICAL_CLASS)       frame._load_tiff(tif,l);    
102     if (classID==mxLOGICAL_CLASS)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     if (classID==mxLOGICAL_CLASS)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
108     if (classID==mxLOGICAL_CLASS)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     if (classID==mxLOGICAL_CLASS)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
27     if (classID==mxLOGICAL_CLASS)       TIFFClose(tif);    
28     if (classID==mxLOGICAL_CLASS)       else    
34     if (classID==mxLOGICAL_CLASS)       throw CImgIOException(_cimg_instance    
42     if (classID==mxLOGICAL_CLASS)       "load_tiff(): Failed to read data from stream",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
30     if (classID==mxLOGICAL_CLASS)       return *this;    
50     if (classID==mxLOGICAL_CLASS)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     if (classID==mxLOGICAL_CLASS)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30     if (classID==mxLOGICAL_CLASS)       const unsigned int step_frame=1)    
67     if (classID==mxLOGICAL_CLASS)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
31     if (classID==mxLOGICAL_CLASS)      #endif    
31     if (classID==mxLOGICAL_CLASS)          


30 / 129

40     mxLogical *mdata = mxGetLogicals(matlabArray);     #ifndef cimg_use_tiff    
41     mxLogical *mdata = mxGetLogicals(matlabArray);     error cimg_use_tiff not defined    
45     mxLogical *mdata = mxGetLogicals(matlabArray);     #endif    
39     mxLogical *mdata = mxGetLogicals(matlabArray);     #ifndef cimg_plugin_tiff_stream    
39     mxLogical *mdata = mxGetLogicals(matlabArray);     #define cimg_plugin_tiff_stream    
41     mxLogical *mdata = mxGetLogicals(matlabArray);     #include <ios>    
84     mxLogical *mdata = mxGetLogicals(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
39     mxLogical *mdata = mxGetLogicals(matlabArray);      if (!tiffOutStream->good())    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgArgumentException(_cimg_instance    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      "save_tiff(): tiffstream is not good!",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      if (is_empty())    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgArgumentException(_cimg_instance    
37     mxLogical *mdata = mxGetLogicals(matlabArray);      "Not allowed to write empty images to stream",    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      );    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      if (tif)    
56     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      tiffOutStream->flush();    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFClose(tif);    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      else    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgIOException(_cimg_instance    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      "save_tiff(): Failed to stream for writing.",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return *this;    
42     mxLogical *mdata = mxGetLogicals(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int step_frame=1)    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int    
50     mxLogical *mdata = mxGetLogicals(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      nstep_frame = step_frame?step_frame:1;    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      if (tif)    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      unsigned int nb_images = 0;    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      do     
40     mxLogical *mdata = mxGetLogicals(matlabArray);      ++nb_images;    
38     mxLogical *mdata = mxGetLogicals(matlabArray);       while (TIFFReadDirectory(tif));    
63     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nfirst_frame>=nb_images)    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return assign();    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nlast_frame>=nb_images)    
37     mxLogical *mdata = mxGetLogicals(matlabArray);      nlast_frame = nb_images-1;    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFSetDirectory(tif,0);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      CImg<T> frame;    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
38     mxLogical *mdata = mxGetLogicals(matlabArray);      frame._load_tiff(tif,l);    
96     mxLogical *mdata = mxGetLogicals(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     mxLogical *mdata = mxGetLogicals(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     mxLogical *mdata = mxGetLogicals(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     mxLogical *mdata = mxGetLogicals(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFClose(tif);    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      else    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgIOException(_cimg_instance    
42     mxLogical *mdata = mxGetLogicals(matlabArray);      "load_tiff(): Failed to read data from stream",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return *this;    
49     mxLogical *mdata = mxGetLogicals(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int step_frame=1)    
62     mxLogical *mdata = mxGetLogicals(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
45     mxLogical *mdata = mxGetLogicals(matlabArray);     #endif    
47     mxLogical *mdata = mxGetLogicals(matlabArray);         


31 / 129

36     cpMatlabData((const mxLogical *)mdata);     #ifndef cimg_use_tiff    
37     cpMatlabData((const mxLogical *)mdata);     error cimg_use_tiff not defined    
38     cpMatlabData((const mxLogical *)mdata);     #endif    
37     cpMatlabData((const mxLogical *)mdata);     #ifndef cimg_plugin_tiff_stream    
37     cpMatlabData((const mxLogical *)mdata);     #define cimg_plugin_tiff_stream    
37     cpMatlabData((const mxLogical *)mdata);     #include <ios>    
82     cpMatlabData((const mxLogical *)mdata);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
34     cpMatlabData((const mxLogical *)mdata);      if (!tiffOutStream->good())    
37     cpMatlabData((const mxLogical *)mdata);      throw CImgArgumentException(_cimg_instance    
37     cpMatlabData((const mxLogical *)mdata);      "save_tiff(): tiffstream is not good!",    
32     cpMatlabData((const mxLogical *)mdata);      cimg_instance);    
34     cpMatlabData((const mxLogical *)mdata);      if (is_empty())    
37     cpMatlabData((const mxLogical *)mdata);      throw CImgArgumentException(_cimg_instance    
37     cpMatlabData((const mxLogical *)mdata);      "Not allowed to write empty images to stream",    
34     cpMatlabData((const mxLogical *)mdata);      cimg_instance    
37     cpMatlabData((const mxLogical *)mdata);      );    
44     cpMatlabData((const mxLogical *)mdata);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
35     cpMatlabData((const mxLogical *)mdata);      if (tif)    
57     cpMatlabData((const mxLogical *)mdata);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
33     cpMatlabData((const mxLogical *)mdata);      tiffOutStream->flush();    
33     cpMatlabData((const mxLogical *)mdata);      TIFFClose(tif);    
37     cpMatlabData((const mxLogical *)mdata);      else    
35     cpMatlabData((const mxLogical *)mdata);      throw CImgIOException(_cimg_instance    
41     cpMatlabData((const mxLogical *)mdata);      "save_tiff(): Failed to stream for writing.",    
32     cpMatlabData((const mxLogical *)mdata);      cimg_instance);    
34     cpMatlabData((const mxLogical *)mdata);      return *this;    
39     cpMatlabData((const mxLogical *)mdata);     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     cpMatlabData((const mxLogical *)mdata);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     cpMatlabData((const mxLogical *)mdata);      const unsigned int step_frame=1)    
30     cpMatlabData((const mxLogical *)mdata);      const unsigned int    
50     cpMatlabData((const mxLogical *)mdata);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     cpMatlabData((const mxLogical *)mdata);      nstep_frame = step_frame?step_frame:1;    
60     cpMatlabData((const mxLogical *)mdata);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     cpMatlabData((const mxLogical *)mdata);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
35     cpMatlabData((const mxLogical *)mdata);      if (tif)    
33     cpMatlabData((const mxLogical *)mdata);      unsigned int nb_images = 0;    
37     cpMatlabData((const mxLogical *)mdata);      do     
34     cpMatlabData((const mxLogical *)mdata);      ++nb_images;    
34     cpMatlabData((const mxLogical *)mdata);       while (TIFFReadDirectory(tif));    
64     cpMatlabData((const mxLogical *)mdata);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     cpMatlabData((const mxLogical *)mdata);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
38     cpMatlabData((const mxLogical *)mdata);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
34     cpMatlabData((const mxLogical *)mdata);      if (nfirst_frame>=nb_images)    
33     cpMatlabData((const mxLogical *)mdata);      return assign();    
33     cpMatlabData((const mxLogical *)mdata);      if (nlast_frame>=nb_images)    
32     cpMatlabData((const mxLogical *)mdata);      nlast_frame = nb_images-1;    
33     cpMatlabData((const mxLogical *)mdata);      TIFFSetDirectory(tif,0);    
34     cpMatlabData((const mxLogical *)mdata);      CImg<T> frame;    
58     cpMatlabData((const mxLogical *)mdata);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
32     cpMatlabData((const mxLogical *)mdata);      frame._load_tiff(tif,l);    
97     cpMatlabData((const mxLogical *)mdata);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     cpMatlabData((const mxLogical *)mdata);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     cpMatlabData((const mxLogical *)mdata);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     cpMatlabData((const mxLogical *)mdata);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
33     cpMatlabData((const mxLogical *)mdata);      TIFFClose(tif);    
37     cpMatlabData((const mxLogical *)mdata);      else    
35     cpMatlabData((const mxLogical *)mdata);      throw CImgIOException(_cimg_instance    
39     cpMatlabData((const mxLogical *)mdata);      "load_tiff(): Failed to read data from stream",    
32     cpMatlabData((const mxLogical *)mdata);      cimg_instance);    
34     cpMatlabData((const mxLogical *)mdata);      return *this;    
47     cpMatlabData((const mxLogical *)mdata);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     cpMatlabData((const mxLogical *)mdata);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     cpMatlabData((const mxLogical *)mdata);      const unsigned int step_frame=1)    
62     cpMatlabData((const mxLogical *)mdata);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
38     cpMatlabData((const mxLogical *)mdata);     #endif    
40     cpMatlabData((const mxLogical *)mdata);         


32 / 129

18      else      #ifndef cimg_use_tiff    
27      else      error cimg_use_tiff not defined    
6      else      #endif    
27      else      #ifndef cimg_plugin_tiff_stream    
27      else      #define cimg_plugin_tiff_stream    
11      else      #include <ios>    
93      else      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25      else       if (!tiffOutStream->good())    
39      else       throw CImgArgumentException(_cimg_instance    
35      else       "save_tiff(): tiffstream is not good!",    
13      else       cimg_instance);    
12      else       if (is_empty())    
39      else       throw CImgArgumentException(_cimg_instance    
42      else       "Not allowed to write empty images to stream",    
12      else       cimg_instance    
6      else       );    
49      else       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
7      else       if (tif)    
62      else       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20      else       tiffOutStream->flush();    
12      else       TIFFClose(tif);    
2      else       else    


33 / 129

37     void *mdata = (void*)mxGetPr(matlabArray);     #ifndef cimg_use_tiff    
40     void *mdata = (void*)mxGetPr(matlabArray);     error cimg_use_tiff not defined    
41     void *mdata = (void*)mxGetPr(matlabArray);     #endif    
36     void *mdata = (void*)mxGetPr(matlabArray);     #ifndef cimg_plugin_tiff_stream    
37     void *mdata = (void*)mxGetPr(matlabArray);     #define cimg_plugin_tiff_stream    
39     void *mdata = (void*)mxGetPr(matlabArray);     #include <ios>    
84     void *mdata = (void*)mxGetPr(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
34     void *mdata = (void*)mxGetPr(matlabArray);      if (!tiffOutStream->good())    
40     void *mdata = (void*)mxGetPr(matlabArray);      throw CImgArgumentException(_cimg_instance    
39     void *mdata = (void*)mxGetPr(matlabArray);      "save_tiff(): tiffstream is not good!",    
35     void *mdata = (void*)mxGetPr(matlabArray);      cimg_instance);    
34     void *mdata = (void*)mxGetPr(matlabArray);      if (is_empty())    
40     void *mdata = (void*)mxGetPr(matlabArray);      throw CImgArgumentException(_cimg_instance    
38     void *mdata = (void*)mxGetPr(matlabArray);      "Not allowed to write empty images to stream",    
37     void *mdata = (void*)mxGetPr(matlabArray);      cimg_instance    
40     void *mdata = (void*)mxGetPr(matlabArray);      );    
42     void *mdata = (void*)mxGetPr(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
37     void *mdata = (void*)mxGetPr(matlabArray);      if (tif)    
55     void *mdata = (void*)mxGetPr(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
35     void *mdata = (void*)mxGetPr(matlabArray);      tiffOutStream->flush();    
36     void *mdata = (void*)mxGetPr(matlabArray);      TIFFClose(tif);    
40     void *mdata = (void*)mxGetPr(matlabArray);      else    
39     void *mdata = (void*)mxGetPr(matlabArray);      throw CImgIOException(_cimg_instance    
41     void *mdata = (void*)mxGetPr(matlabArray);      "save_tiff(): Failed to stream for writing.",    
35     void *mdata = (void*)mxGetPr(matlabArray);      cimg_instance);    
37     void *mdata = (void*)mxGetPr(matlabArray);      return *this;    
41     void *mdata = (void*)mxGetPr(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     void *mdata = (void*)mxGetPr(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
36     void *mdata = (void*)mxGetPr(matlabArray);      const unsigned int step_frame=1)    
36     void *mdata = (void*)mxGetPr(matlabArray);      const unsigned int    
47     void *mdata = (void*)mxGetPr(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     void *mdata = (void*)mxGetPr(matlabArray);      nstep_frame = step_frame?step_frame:1;    
53     void *mdata = (void*)mxGetPr(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
41     void *mdata = (void*)mxGetPr(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
37     void *mdata = (void*)mxGetPr(matlabArray);      if (tif)    
36     void *mdata = (void*)mxGetPr(matlabArray);      unsigned int nb_images = 0;    
40     void *mdata = (void*)mxGetPr(matlabArray);      do     
38     void *mdata = (void*)mxGetPr(matlabArray);      ++nb_images;    
35     void *mdata = (void*)mxGetPr(matlabArray);       while (TIFFReadDirectory(tif));    
63     void *mdata = (void*)mxGetPr(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     void *mdata = (void*)mxGetPr(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     void *mdata = (void*)mxGetPr(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
35     void *mdata = (void*)mxGetPr(matlabArray);      if (nfirst_frame>=nb_images)    
36     void *mdata = (void*)mxGetPr(matlabArray);      return assign();    
35     void *mdata = (void*)mxGetPr(matlabArray);      if (nlast_frame>=nb_images)    
34     void *mdata = (void*)mxGetPr(matlabArray);      nlast_frame = nb_images-1;    
35     void *mdata = (void*)mxGetPr(matlabArray);      TIFFSetDirectory(tif,0);    
37     void *mdata = (void*)mxGetPr(matlabArray);      CImg<T> frame;    
54     void *mdata = (void*)mxGetPr(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
35     void *mdata = (void*)mxGetPr(matlabArray);      frame._load_tiff(tif,l);    
95     void *mdata = (void*)mxGetPr(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     void *mdata = (void*)mxGetPr(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     void *mdata = (void*)mxGetPr(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     void *mdata = (void*)mxGetPr(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
36     void *mdata = (void*)mxGetPr(matlabArray);      TIFFClose(tif);    
40     void *mdata = (void*)mxGetPr(matlabArray);      else    
39     void *mdata = (void*)mxGetPr(matlabArray);      throw CImgIOException(_cimg_instance    
39     void *mdata = (void*)mxGetPr(matlabArray);      "load_tiff(): Failed to read data from stream",    
35     void *mdata = (void*)mxGetPr(matlabArray);      cimg_instance);    
37     void *mdata = (void*)mxGetPr(matlabArray);      return *this;    
45     void *mdata = (void*)mxGetPr(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     void *mdata = (void*)mxGetPr(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
36     void *mdata = (void*)mxGetPr(matlabArray);      const unsigned int step_frame=1)    
60     void *mdata = (void*)mxGetPr(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
41     void *mdata = (void*)mxGetPr(matlabArray);     #endif    
43     void *mdata = (void*)mxGetPr(matlabArray);         


34 / 129

19     switch (classID)      #ifndef cimg_use_tiff    
27     switch (classID)      error cimg_use_tiff not defined    
18     switch (classID)      #endif    
28     switch (classID)      #ifndef cimg_plugin_tiff_stream    
27     switch (classID)      #define cimg_plugin_tiff_stream    
16     switch (classID)      #include <ios>    
88     switch (classID)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     switch (classID)       if (!tiffOutStream->good())    
36     switch (classID)       throw CImgArgumentException(_cimg_instance    
33     switch (classID)       "save_tiff(): tiffstream is not good!",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       if (is_empty())    
36     switch (classID)       throw CImgArgumentException(_cimg_instance    
40     switch (classID)       "Not allowed to write empty images to stream",    
15     switch (classID)       cimg_instance    
16     switch (classID)       );    
49     switch (classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13     switch (classID)       if (tif)    
59     switch (classID)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     switch (classID)       tiffOutStream->flush();    
16     switch (classID)       TIFFClose(tif);    
15     switch (classID)       else    
31     switch (classID)       throw CImgIOException(_cimg_instance    
39     switch (classID)       "save_tiff(): Failed to stream for writing.",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       return *this;    
41     switch (classID)      CImg<T>& load_tiff(std::istream* tiffInStream,    
60     switch (classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (classID)       const unsigned int step_frame=1)    
17     switch (classID)       const unsigned int    
54     switch (classID)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34     switch (classID)       nstep_frame = step_frame?step_frame:1;    
65     switch (classID)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     switch (classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13     switch (classID)       if (tif)    
22     switch (classID)       unsigned int nb_images = 0;    
16     switch (classID)       do     
16     switch (classID)       ++nb_images;    
27     switch (classID)        while (TIFFReadDirectory(tif));    
67     switch (classID)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103     switch (classID)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     switch (classID)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     switch (classID)       if (nfirst_frame>=nb_images)    
14     switch (classID)       return assign();    
25     switch (classID)       if (nlast_frame>=nb_images)    
23     switch (classID)       nlast_frame = nb_images-1;    
21     switch (classID)       TIFFSetDirectory(tif,0);    
16     switch (classID)       CImg<T> frame;    
58     switch (classID)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23     switch (classID)       frame._load_tiff(tif,l);    
102     switch (classID)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     switch (classID)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
105     switch (classID)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     switch (classID)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16     switch (classID)       TIFFClose(tif);    
15     switch (classID)       else    
31     switch (classID)       throw CImgIOException(_cimg_instance    
42     switch (classID)       "load_tiff(): Failed to read data from stream",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       return *this;    
48     switch (classID)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     switch (classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (classID)       const unsigned int step_frame=1)    
68     switch (classID)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
18     switch (classID)      #endif    
18     switch (classID)          


35 / 129

61     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #endif    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
56     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
63     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #include <ios>    
80     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (!tiffOutStream->good())    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg_instance);    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (is_empty())    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg_instance    
64     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      );    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
62     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (tif)    
63     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      tiffOutStream->flush();    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      TIFFClose(tif);    
62     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      else    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg_instance);    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      return *this;    
54     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      const unsigned int step_frame=1)    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      const unsigned int    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
53     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
62     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (tif)    
56     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      do     
60     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      ++nb_images;    
56     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
55     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      return assign();    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      nlast_frame = nb_images-1;    
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      CImg<T> frame;    
61     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      frame._load_tiff(tif,l);    
95     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
55     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      TIFFClose(tif);    
62     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      else    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      cimg_instance);    
59     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      return *this;    
55     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      const unsigned int step_frame=1)    
63     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;     #endif    
67     case mxDOUBLE_CLASS : cpMatlabData((const real64_T*)mdata); break;         


36 / 129

61     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #endif    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
63     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #include <ios>    
80     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (!tiffOutStream->good())    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg_instance);    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (is_empty())    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg_instance    
64     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      );    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
62     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (tif)    
63     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      tiffOutStream->flush();    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      TIFFClose(tif);    
62     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      else    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg_instance);    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      return *this;    
54     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      const unsigned int step_frame=1)    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      const unsigned int    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
53     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
62     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (tif)    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      do     
60     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      ++nb_images;    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
55     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      return assign();    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      nlast_frame = nb_images-1;    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      CImg<T> frame;    
61     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      frame._load_tiff(tif,l);    
95     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
55     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
58     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      TIFFClose(tif);    
62     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      else    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      cimg_instance);    
59     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      return *this;    
54     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      const unsigned int step_frame=1)    
62     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;     #endif    
67     case mxSINGLE_CLASS : cpMatlabData((const real32_T*)mdata); break;         


37 / 129

58     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #ifndef cimg_use_tiff    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     error cimg_use_tiff not defined    
60     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #endif    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #define cimg_plugin_tiff_stream    
59     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #include <ios>    
79     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (!tiffOutStream->good())    
51     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg_instance);    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (is_empty())    
51     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      "Not allowed to write empty images to stream",    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg_instance    
60     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      );    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
57     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (tif)    
61     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
56     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      tiffOutStream->flush();    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      TIFFClose(tif);    
58     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      else    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
51     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg_instance);    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      return *this;    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      const unsigned int step_frame=1)    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      const unsigned int    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
50     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
57     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (tif)    
51     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      unsigned int nb_images = 0;    
60     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      do     
56     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      ++nb_images;    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;       while (TIFFReadDirectory(tif));    
65     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (nfirst_frame>=nb_images)    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      return assign();    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (nlast_frame>=nb_images)    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      nlast_frame = nb_images-1;    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      TIFFSetDirectory(tif,0);    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      CImg<T> frame;    
61     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
54     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      TIFFClose(tif);    
58     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      else    
52     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
50     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      cimg_instance);    
55     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      return *this;    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
53     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
60     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;     #endif    
63     case mxINT8_CLASS : cpMatlabData((const int8_T*)mdata); break;         


38 / 129

60     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #ifndef cimg_use_tiff    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     error cimg_use_tiff not defined    
62     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #endif    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #define cimg_plugin_tiff_stream    
60     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #include <ios>    
78     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (!tiffOutStream->good())    
53     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg_instance);    
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (is_empty())    
53     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      "Not allowed to write empty images to stream",    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg_instance    
62     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      );    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
59     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (tif)    
62     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      tiffOutStream->flush();    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      TIFFClose(tif);    
60     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      else    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
53     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg_instance);    
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      return *this;    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      const unsigned int step_frame=1)    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      const unsigned int    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
52     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
59     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (tif)    
53     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      unsigned int nb_images = 0;    
62     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      do     
58     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      ++nb_images;    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (nfirst_frame>=nb_images)    
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      return assign();    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (nlast_frame>=nb_images)    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      nlast_frame = nb_images-1;    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      TIFFSetDirectory(tif,0);    
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      CImg<T> frame;    
61     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
56     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      TIFFClose(tif);    
60     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      else    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      cimg_instance);    
57     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      return *this;    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
55     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
62     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;     #endif    
65     case mxUINT8_CLASS : cpMatlabData((const uint8_T*)mdata); break;         


39 / 129

60     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #ifndef cimg_use_tiff    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     error cimg_use_tiff not defined    
62     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #endif    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #define cimg_plugin_tiff_stream    
61     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #include <ios>    
79     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (!tiffOutStream->good())    
53     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg_instance);    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (is_empty())    
53     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      "Not allowed to write empty images to stream",    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg_instance    
62     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      );    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
59     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (tif)    
62     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      tiffOutStream->flush();    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      else    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
53     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg_instance);    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      return *this;    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      const unsigned int step_frame=1)    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      const unsigned int    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
52     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
59     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (tif)    
53     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      unsigned int nb_images = 0;    
62     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      do     
58     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      ++nb_images;    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (nfirst_frame>=nb_images)    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      return assign();    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (nlast_frame>=nb_images)    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      nlast_frame = nb_images-1;    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      TIFFSetDirectory(tif,0);    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      CImg<T> frame;    
61     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
56     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      else    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      cimg_instance);    
57     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      return *this;    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
62     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;     #endif    
65     case mxINT16_CLASS : cpMatlabData((const int16_T*)mdata); break;         


40 / 129

62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #endif    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #define cimg_plugin_tiff_stream    
62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #include <ios>    
78     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (!tiffOutStream->good())    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg_instance);    
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (is_empty())    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg_instance    
64     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      );    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
61     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (tif)    
62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
60     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      tiffOutStream->flush();    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      else    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg_instance);    
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      return *this;    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      const unsigned int step_frame=1)    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      const unsigned int    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
61     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
61     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (tif)    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      do     
60     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      ++nb_images;    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (nfirst_frame>=nb_images)    
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      return assign();    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      nlast_frame = nb_images-1;    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      TIFFSetDirectory(tif,0);    
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      CImg<T> frame;    
62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
58     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      else    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
54     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      cimg_instance);    
59     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      return *this;    
55     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;     #endif    
67     case mxUINT16_CLASS : cpMatlabData((const uint16_T*)mdata); break;         


41 / 129

60     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #ifndef cimg_use_tiff    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     error cimg_use_tiff not defined    
62     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #endif    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
61     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #include <ios>    
79     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (!tiffOutStream->good())    
53     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg_instance);    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (is_empty())    
53     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      "Not allowed to write empty images to stream",    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg_instance    
62     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      );    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
59     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (tif)    
62     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      tiffOutStream->flush();    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      else    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
53     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg_instance);    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      return *this;    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      const unsigned int step_frame=1)    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      const unsigned int    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
52     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
59     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (tif)    
53     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      unsigned int nb_images = 0;    
62     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      do     
58     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      ++nb_images;    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      return assign();    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (nlast_frame>=nb_images)    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      nlast_frame = nb_images-1;    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      CImg<T> frame;    
61     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
56     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      else    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      cimg_instance);    
57     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      return *this;    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
62     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;     #endif    
65     case mxINT32_CLASS : cpMatlabData((const int32_T*)mdata); break;         


42 / 129

62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #endif    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #include <ios>    
78     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (!tiffOutStream->good())    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg_instance);    
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (is_empty())    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg_instance    
64     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      );    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
61     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (tif)    
62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
60     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      tiffOutStream->flush();    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      else    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg_instance);    
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      return *this;    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      const unsigned int step_frame=1)    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      const unsigned int    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
61     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
61     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (tif)    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      do     
60     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      ++nb_images;    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      return assign();    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      nlast_frame = nb_images-1;    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      CImg<T> frame;    
62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
58     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      else    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
54     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      cimg_instance);    
59     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      return *this;    
55     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;     #endif    
67     case mxUINT32_CLASS : cpMatlabData((const uint32_T*)mdata); break;         


43 / 129

60     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #ifndef cimg_use_tiff    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     error cimg_use_tiff not defined    
62     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #endif    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
61     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #include <ios>    
79     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (!tiffOutStream->good())    
53     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg_instance);    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (is_empty())    
53     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      "Not allowed to write empty images to stream",    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg_instance    
62     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      );    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
59     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (tif)    
62     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
58     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      tiffOutStream->flush();    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      else    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
53     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg_instance);    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      return *this;    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      const unsigned int step_frame=1)    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      const unsigned int    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
52     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
59     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (tif)    
53     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      unsigned int nb_images = 0;    
62     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      do     
58     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      ++nb_images;    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      return assign();    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (nlast_frame>=nb_images)    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      nlast_frame = nb_images-1;    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      CImg<T> frame;    
61     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
56     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      TIFFClose(tif);    
60     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      else    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
52     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      cimg_instance);    
57     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      return *this;    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
54     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
62     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;     #endif    
65     case mxINT64_CLASS : cpMatlabData((const int64_T*)mdata); break;         


44 / 129

62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #endif    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #include <ios>    
78     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (!tiffOutStream->good())    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg_instance);    
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (is_empty())    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg_instance    
64     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      );    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
61     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (tif)    
62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
60     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      tiffOutStream->flush();    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      else    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg_instance);    
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      return *this;    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      const unsigned int step_frame=1)    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      const unsigned int    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
61     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
61     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (tif)    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      do     
60     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      ++nb_images;    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      return assign();    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      nlast_frame = nb_images-1;    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      CImg<T> frame;    
62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      frame._load_tiff(tif,l);    
96     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
58     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      TIFFClose(tif);    
62     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      else    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
54     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      cimg_instance);    
59     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      return *this;    
55     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;     #endif    
67     case mxUINT64_CLASS : cpMatlabData((const uint64_T*)mdata); break;         


45 / 129

50    template <typename t> void cpMatlabData(const t* mdata)      #ifndef cimg_use_tiff    
48    template <typename t> void cpMatlabData(const t* mdata)      error cimg_use_tiff not defined    
53    template <typename t> void cpMatlabData(const t* mdata)      #endif    
47    template <typename t> void cpMatlabData(const t* mdata)      #ifndef cimg_plugin_tiff_stream    
46    template <typename t> void cpMatlabData(const t* mdata)      #define cimg_plugin_tiff_stream    
49    template <typename t> void cpMatlabData(const t* mdata)      #include <ios>    
79    template <typename t> void cpMatlabData(const t* mdata)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
48    template <typename t> void cpMatlabData(const t* mdata)       if (!tiffOutStream->good())    
48    template <typename t> void cpMatlabData(const t* mdata)       throw CImgArgumentException(_cimg_instance    
44    template <typename t> void cpMatlabData(const t* mdata)       "save_tiff(): tiffstream is not good!",    
49    template <typename t> void cpMatlabData(const t* mdata)       cimg_instance);    
49    template <typename t> void cpMatlabData(const t* mdata)       if (is_empty())    
48    template <typename t> void cpMatlabData(const t* mdata)       throw CImgArgumentException(_cimg_instance    
44    template <typename t> void cpMatlabData(const t* mdata)       "Not allowed to write empty images to stream",    
49    template <typename t> void cpMatlabData(const t* mdata)       cimg_instance    
54    template <typename t> void cpMatlabData(const t* mdata)       );    
51    template <typename t> void cpMatlabData(const t* mdata)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
50    template <typename t> void cpMatlabData(const t* mdata)       if (tif)    
58    template <typename t> void cpMatlabData(const t* mdata)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
47    template <typename t> void cpMatlabData(const t* mdata)       tiffOutStream->flush();    
50    template <typename t> void cpMatlabData(const t* mdata)       TIFFClose(tif);    
52    template <typename t> void cpMatlabData(const t* mdata)       else    
48    template <typename t> void cpMatlabData(const t* mdata)       throw CImgIOException(_cimg_instance    
46    template <typename t> void cpMatlabData(const t* mdata)       "save_tiff(): Failed to stream for writing.",    
49    template <typename t> void cpMatlabData(const t* mdata)       cimg_instance);    
50    template <typename t> void cpMatlabData(const t* mdata)       return *this;    
47    template <typename t> void cpMatlabData(const t* mdata)      CImg<T>& load_tiff(std::istream* tiffInStream,    
57    template <typename t> void cpMatlabData(const t* mdata)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
46    template <typename t> void cpMatlabData(const t* mdata)       const unsigned int step_frame=1)    
48    template <typename t> void cpMatlabData(const t* mdata)       const unsigned int    
52    template <typename t> void cpMatlabData(const t* mdata)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
45    template <typename t> void cpMatlabData(const t* mdata)       nstep_frame = step_frame?step_frame:1;    
58    template <typename t> void cpMatlabData(const t* mdata)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
51    template <typename t> void cpMatlabData(const t* mdata)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
50    template <typename t> void cpMatlabData(const t* mdata)       if (tif)    
45    template <typename t> void cpMatlabData(const t* mdata)       unsigned int nb_images = 0;    
52    template <typename t> void cpMatlabData(const t* mdata)       do     
51    template <typename t> void cpMatlabData(const t* mdata)       ++nb_images;    
47    template <typename t> void cpMatlabData(const t* mdata)        while (TIFFReadDirectory(tif));    
63    template <typename t> void cpMatlabData(const t* mdata)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
90    template <typename t> void cpMatlabData(const t* mdata)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
48    template <typename t> void cpMatlabData(const t* mdata)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
47    template <typename t> void cpMatlabData(const t* mdata)       if (nfirst_frame>=nb_images)    
49    template <typename t> void cpMatlabData(const t* mdata)       return assign();    
47    template <typename t> void cpMatlabData(const t* mdata)       if (nlast_frame>=nb_images)    
45    template <typename t> void cpMatlabData(const t* mdata)       nlast_frame = nb_images-1;    
47    template <typename t> void cpMatlabData(const t* mdata)       TIFFSetDirectory(tif,0);    
50    template <typename t> void cpMatlabData(const t* mdata)       CImg<T> frame;    
56    template <typename t> void cpMatlabData(const t* mdata)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
46    template <typename t> void cpMatlabData(const t* mdata)       frame._load_tiff(tif,l);    
92    template <typename t> void cpMatlabData(const t* mdata)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
67    template <typename t> void cpMatlabData(const t* mdata)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99    template <typename t> void cpMatlabData(const t* mdata)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
50    template <typename t> void cpMatlabData(const t* mdata)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
50    template <typename t> void cpMatlabData(const t* mdata)       TIFFClose(tif);    
52    template <typename t> void cpMatlabData(const t* mdata)       else    
48    template <typename t> void cpMatlabData(const t* mdata)       throw CImgIOException(_cimg_instance    
45    template <typename t> void cpMatlabData(const t* mdata)       "load_tiff(): Failed to read data from stream",    
49    template <typename t> void cpMatlabData(const t* mdata)       cimg_instance);    
50    template <typename t> void cpMatlabData(const t* mdata)       return *this;    
50    template <typename t> void cpMatlabData(const t* mdata)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57    template <typename t> void cpMatlabData(const t* mdata)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
46    template <typename t> void cpMatlabData(const t* mdata)       const unsigned int step_frame=1)    
63    template <typename t> void cpMatlabData(const t* mdata)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
53    template <typename t> void cpMatlabData(const t* mdata)      #endif    
56    template <typename t> void cpMatlabData(const t* mdata)          


46 / 129

25     if (cimg::type<t>::is_float())      #ifndef cimg_use_tiff    
27     if (cimg::type<t>::is_float())      error cimg_use_tiff not defined    
29     if (cimg::type<t>::is_float())      #endif    
26     if (cimg::type<t>::is_float())      #ifndef cimg_plugin_tiff_stream    
27     if (cimg::type<t>::is_float())      #define cimg_plugin_tiff_stream    
27     if (cimg::type<t>::is_float())      #include <ios>    
86     if (cimg::type<t>::is_float())      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
21     if (cimg::type<t>::is_float())       if (!tiffOutStream->good())    
35     if (cimg::type<t>::is_float())       throw CImgArgumentException(_cimg_instance    
33     if (cimg::type<t>::is_float())       "save_tiff(): tiffstream is not good!",    
24     if (cimg::type<t>::is_float())       cimg_instance);    
21     if (cimg::type<t>::is_float())       if (is_empty())    
35     if (cimg::type<t>::is_float())       throw CImgArgumentException(_cimg_instance    
40     if (cimg::type<t>::is_float())       "Not allowed to write empty images to stream",    
25     if (cimg::type<t>::is_float())       cimg_instance    
30     if (cimg::type<t>::is_float())       );    
43     if (cimg::type<t>::is_float())       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23     if (cimg::type<t>::is_float())       if (tif)    
56     if (cimg::type<t>::is_float())       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
24     if (cimg::type<t>::is_float())       tiffOutStream->flush();    
26     if (cimg::type<t>::is_float())       TIFFClose(tif);    
29     if (cimg::type<t>::is_float())       else    
30     if (cimg::type<t>::is_float())       throw CImgIOException(_cimg_instance    
39     if (cimg::type<t>::is_float())       "save_tiff(): Failed to stream for writing.",    
24     if (cimg::type<t>::is_float())       cimg_instance);    
28     if (cimg::type<t>::is_float())       return *this;    
38     if (cimg::type<t>::is_float())      CImg<T>& load_tiff(std::istream* tiffInStream,    
59     if (cimg::type<t>::is_float())       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     if (cimg::type<t>::is_float())       const unsigned int step_frame=1)    
28     if (cimg::type<t>::is_float())       const unsigned int    
48     if (cimg::type<t>::is_float())       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     if (cimg::type<t>::is_float())       nstep_frame = step_frame?step_frame:1;    
62     if (cimg::type<t>::is_float())       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
42     if (cimg::type<t>::is_float())       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23     if (cimg::type<t>::is_float())       if (tif)    
28     if (cimg::type<t>::is_float())       unsigned int nb_images = 0;    
29     if (cimg::type<t>::is_float())       do     
27     if (cimg::type<t>::is_float())       ++nb_images;    
27     if (cimg::type<t>::is_float())        while (TIFFReadDirectory(tif));    
62     if (cimg::type<t>::is_float())       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
96     if (cimg::type<t>::is_float())       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     if (cimg::type<t>::is_float())       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
23     if (cimg::type<t>::is_float())       if (nfirst_frame>=nb_images)    
27     if (cimg::type<t>::is_float())       return assign();    
23     if (cimg::type<t>::is_float())       if (nlast_frame>=nb_images)    
29     if (cimg::type<t>::is_float())       nlast_frame = nb_images-1;    
27     if (cimg::type<t>::is_float())       TIFFSetDirectory(tif,0);    
25     if (cimg::type<t>::is_float())       CImg<T> frame;    
56     if (cimg::type<t>::is_float())       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
25     if (cimg::type<t>::is_float())       frame._load_tiff(tif,l);    
96     if (cimg::type<t>::is_float())       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     if (cimg::type<t>::is_float())       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     if (cimg::type<t>::is_float())       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     if (cimg::type<t>::is_float())       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
26     if (cimg::type<t>::is_float())       TIFFClose(tif);    
29     if (cimg::type<t>::is_float())       else    
30     if (cimg::type<t>::is_float())       throw CImgIOException(_cimg_instance    
38     if (cimg::type<t>::is_float())       "load_tiff(): Failed to read data from stream",    
24     if (cimg::type<t>::is_float())       cimg_instance);    
28     if (cimg::type<t>::is_float())       return *this;    
45     if (cimg::type<t>::is_float())      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59     if (cimg::type<t>::is_float())       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     if (cimg::type<t>::is_float())       const unsigned int step_frame=1)    
63     if (cimg::type<t>::is_float())       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
29     if (cimg::type<t>::is_float())      #endif    
32     if (cimg::type<t>::is_float())          


47 / 129

91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #ifndef cimg_use_tiff    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     error cimg_use_tiff not defined    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #endif    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #ifndef cimg_plugin_tiff_stream    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #define cimg_plugin_tiff_stream    
95     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #include <ios>    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (!tiffOutStream->good())    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgArgumentException(_cimg_instance    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "save_tiff(): tiffstream is not good!",    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (is_empty())    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgArgumentException(_cimg_instance    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "Not allowed to write empty images to stream",    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      );    
84     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (tif)    
68     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      tiffOutStream->flush();    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFClose(tif);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      else    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgIOException(_cimg_instance    
85     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "save_tiff(): Failed to stream for writing.",    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return *this;    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     CImg<T>& load_tiff(std::istream* tiffInStream,    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int step_frame=1)    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nstep_frame = step_frame?step_frame:1;    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
84     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (tif)    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      unsigned int nb_images = 0;    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      do     
93     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      ++nb_images;    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);       while (TIFFReadDirectory(tif));    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
96     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
85     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nfirst_frame>=nb_images)    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return assign();    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nlast_frame>=nb_images)    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nlast_frame = nb_images-1;    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFSetDirectory(tif,0);    
93     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      CImg<T> frame;    
85     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      frame._load_tiff(tif,l);    
100     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFClose(tif);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      else    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgIOException(_cimg_instance    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "load_tiff(): Failed to read data from stream",    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return *this;    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
86     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
87     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int step_frame=1)    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #endif    
100     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(mdata[((v*_depth + z)*_width + x)*_height + y]);         


48 / 129

18      else      #ifndef cimg_use_tiff    
27      else      error cimg_use_tiff not defined    
6      else      #endif    
27      else      #ifndef cimg_plugin_tiff_stream    
27      else      #define cimg_plugin_tiff_stream    
11      else      #include <ios>    
93      else      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25      else       if (!tiffOutStream->good())    
39      else       throw CImgArgumentException(_cimg_instance    
35      else       "save_tiff(): tiffstream is not good!",    
13      else       cimg_instance);    
12      else       if (is_empty())    
39      else       throw CImgArgumentException(_cimg_instance    
42      else       "Not allowed to write empty images to stream",    
12      else       cimg_instance    
6      else       );    
49      else       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
7      else       if (tif)    
62      else       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20      else       tiffOutStream->flush();    
12      else       TIFFClose(tif);    
2      else       else    


49 / 129

96     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #ifndef cimg_use_tiff    
93     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     error cimg_use_tiff not defined    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #endif    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #ifndef cimg_plugin_tiff_stream    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #define cimg_plugin_tiff_stream    
99     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #include <ios>    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (!tiffOutStream->good())    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgArgumentException(_cimg_instance    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "save_tiff(): tiffstream is not good!",    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
93     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (is_empty())    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgArgumentException(_cimg_instance    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "Not allowed to write empty images to stream",    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      );    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (tif)    
73     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
96     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      tiffOutStream->flush();    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFClose(tif);    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      else    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgIOException(_cimg_instance    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "save_tiff(): Failed to stream for writing.",    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
95     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return *this;    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     CImg<T>& load_tiff(std::istream* tiffInStream,    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int step_frame=1)    
93     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nstep_frame = step_frame?step_frame:1;    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (tif)    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      unsigned int nb_images = 0;    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      do     
98     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      ++nb_images;    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);       while (TIFFReadDirectory(tif));    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nfirst_frame>=nb_images)    
96     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return assign();    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (nlast_frame>=nb_images)    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      nlast_frame = nb_images-1;    
95     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFSetDirectory(tif,0);    
98     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      CImg<T> frame;    
88     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
95     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      frame._load_tiff(tif,l);    
101     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
91     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
104     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
97     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      TIFFClose(tif);    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      else    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      throw CImgIOException(_cimg_instance    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      "load_tiff(): Failed to read data from stream",    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      cimg_instance);    
95     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return *this;    
94     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
90     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
89     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      const unsigned int step_frame=1)    
92     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
102     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);     #endif    
105     cimg_forXYZC(*this,x,y,z,v) (*this)(x,y,z,v) = (T)(int)(mdata[((v*_depth + z)*_width + x)*_height + y]);         


50 / 129

19    public:     #ifndef cimg_use_tiff    
29    public:     error cimg_use_tiff not defined    
6    public:     #endif    
28    public:     #ifndef cimg_plugin_tiff_stream    
28    public:     #define cimg_plugin_tiff_stream    
12    public:     #include <ios>    
96    public:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27    public:      if (!tiffOutStream->good())    
40    public:      throw CImgArgumentException(_cimg_instance    
38    public:      "save_tiff(): tiffstream is not good!",    
14    public:      cimg_instance);    
15    public:      if (is_empty())    
40    public:      throw CImgArgumentException(_cimg_instance    
45    public:      "Not allowed to write empty images to stream",    
12    public:      cimg_instance    
7    public:      );    
52    public:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
8    public:      if (tif)    
65    public:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22    public:      tiffOutStream->flush();    
14    public:      TIFFClose(tif);    
6    public:      else    
34    public:      throw CImgIOException(_cimg_instance    
44    public:      "save_tiff(): Failed to stream for writing.",    
14    public:      cimg_instance);    
12    public:      return *this;    
43    public:     CImg<T>& load_tiff(std::istream* tiffInStream,    
66    public:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31    public:      const unsigned int step_frame=1)    
17    public:      const unsigned int    
59    public:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
37    public:      nstep_frame = step_frame?step_frame:1;    
70    public:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
51    public:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
8    public:      if (tif)    
25    public:      unsigned int nb_images = 0;    
7    public:      do     
11    public:      ++nb_images;    
30    public:       while (TIFFReadDirectory(tif));    
74    public:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
109    public:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
46    public:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27    public:      if (nfirst_frame>=nb_images)    
15    public:      return assign();    
26    public:      if (nlast_frame>=nb_images)    
25    public:      nlast_frame = nb_images-1;    
23    public:      TIFFSetDirectory(tif,0);    
15    public:      CImg<T> frame;    
66    public:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    public:      frame._load_tiff(tif,l);    
111    public:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
76    public:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
114    public:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
50    public:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
14    public:      TIFFClose(tif);    
6    public:      else    
34    public:      throw CImgIOException(_cimg_instance    
46    public:      "load_tiff(): Failed to read data from stream",    
14    public:      cimg_instance);    
12    public:      return *this;    
53    public:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
66    public:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31    public:      const unsigned int step_frame=1)    
73    public:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
6    public:     #endif    
7    public:         


51 / 129

53    CImg(const mxArray *matlabArray, const bool vdata = false)     #ifndef cimg_use_tiff    
48    CImg(const mxArray *matlabArray, const bool vdata = false)     error cimg_use_tiff not defined    
55    CImg(const mxArray *matlabArray, const bool vdata = false)     #endif    
52    CImg(const mxArray *matlabArray, const bool vdata = false)     #ifndef cimg_plugin_tiff_stream    
51    CImg(const mxArray *matlabArray, const bool vdata = false)     #define cimg_plugin_tiff_stream    
52    CImg(const mxArray *matlabArray, const bool vdata = false)     #include <ios>    
74    CImg(const mxArray *matlabArray, const bool vdata = false)     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
49    CImg(const mxArray *matlabArray, const bool vdata = false)      if (!tiffOutStream->good())    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      throw CImgArgumentException(_cimg_instance    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      "save_tiff(): tiffstream is not good!",    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg_instance);    
52    CImg(const mxArray *matlabArray, const bool vdata = false)      if (is_empty())    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      throw CImgArgumentException(_cimg_instance    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      "Not allowed to write empty images to stream",    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg_instance    
57    CImg(const mxArray *matlabArray, const bool vdata = false)      );    
53    CImg(const mxArray *matlabArray, const bool vdata = false)      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
53    CImg(const mxArray *matlabArray, const bool vdata = false)      if (tif)    
59    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
53    CImg(const mxArray *matlabArray, const bool vdata = false)      tiffOutStream->flush();    
52    CImg(const mxArray *matlabArray, const bool vdata = false)      TIFFClose(tif);    
54    CImg(const mxArray *matlabArray, const bool vdata = false)      else    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      throw CImgIOException(_cimg_instance    
49    CImg(const mxArray *matlabArray, const bool vdata = false)      "save_tiff(): Failed to stream for writing.",    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg_instance);    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      return *this;    
48    CImg(const mxArray *matlabArray, const bool vdata = false)     CImg<T>& load_tiff(std::istream* tiffInStream,    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
45    CImg(const mxArray *matlabArray, const bool vdata = false)      const unsigned int step_frame=1)    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      const unsigned int    
52    CImg(const mxArray *matlabArray, const bool vdata = false)      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
47    CImg(const mxArray *matlabArray, const bool vdata = false)      nstep_frame = step_frame?step_frame:1;    
59    CImg(const mxArray *matlabArray, const bool vdata = false)      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
53    CImg(const mxArray *matlabArray, const bool vdata = false)      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
53    CImg(const mxArray *matlabArray, const bool vdata = false)      if (tif)    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      unsigned int nb_images = 0;    
55    CImg(const mxArray *matlabArray, const bool vdata = false)      do     
53    CImg(const mxArray *matlabArray, const bool vdata = false)      ++nb_images;    
50    CImg(const mxArray *matlabArray, const bool vdata = false)       while (TIFFReadDirectory(tif));    
61    CImg(const mxArray *matlabArray, const bool vdata = false)      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
91    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
47    CImg(const mxArray *matlabArray, const bool vdata = false)      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
47    CImg(const mxArray *matlabArray, const bool vdata = false)      if (nfirst_frame>=nb_images)    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      return assign();    
47    CImg(const mxArray *matlabArray, const bool vdata = false)      if (nlast_frame>=nb_images)    
49    CImg(const mxArray *matlabArray, const bool vdata = false)      nlast_frame = nb_images-1;    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      TIFFSetDirectory(tif,0);    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      CImg<T> frame;    
56    CImg(const mxArray *matlabArray, const bool vdata = false)      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
49    CImg(const mxArray *matlabArray, const bool vdata = false)      frame._load_tiff(tif,l);    
92    CImg(const mxArray *matlabArray, const bool vdata = false)      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68    CImg(const mxArray *matlabArray, const bool vdata = false)      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100    CImg(const mxArray *matlabArray, const bool vdata = false)      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
52    CImg(const mxArray *matlabArray, const bool vdata = false)      TIFFClose(tif);    
54    CImg(const mxArray *matlabArray, const bool vdata = false)      else    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      throw CImgIOException(_cimg_instance    
48    CImg(const mxArray *matlabArray, const bool vdata = false)      "load_tiff(): Failed to read data from stream",    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      cimg_instance);    
50    CImg(const mxArray *matlabArray, const bool vdata = false)      return *this;    
53    CImg(const mxArray *matlabArray, const bool vdata = false)     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
51    CImg(const mxArray *matlabArray, const bool vdata = false)      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
45    CImg(const mxArray *matlabArray, const bool vdata = false)      const unsigned int step_frame=1)    
62    CImg(const mxArray *matlabArray, const bool vdata = false)      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
55    CImg(const mxArray *matlabArray, const bool vdata = false)     #endif    
58    CImg(const mxArray *matlabArray, const bool vdata = false)         


52 / 129

21     : _is_shared(false)      #ifndef cimg_use_tiff    
26     : _is_shared(false)      error cimg_use_tiff not defined    
19     : _is_shared(false)      #endif    
25     : _is_shared(false)      #ifndef cimg_plugin_tiff_stream    
25     : _is_shared(false)      #define cimg_plugin_tiff_stream    
18     : _is_shared(false)      #include <ios>    
85     : _is_shared(false)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
22     : _is_shared(false)       if (!tiffOutStream->good())    
38     : _is_shared(false)       throw CImgArgumentException(_cimg_instance    
33     : _is_shared(false)       "save_tiff(): tiffstream is not good!",    
16     : _is_shared(false)       cimg_instance);    
15     : _is_shared(false)       if (is_empty())    
38     : _is_shared(false)       throw CImgArgumentException(_cimg_instance    
40     : _is_shared(false)       "Not allowed to write empty images to stream",    
17     : _is_shared(false)       cimg_instance    
19     : _is_shared(false)       );    
45     : _is_shared(false)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
17     : _is_shared(false)       if (tif)    
55     : _is_shared(false)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
18     : _is_shared(false)       tiffOutStream->flush();    
17     : _is_shared(false)       TIFFClose(tif);    
16     : _is_shared(false)       else    
32     : _is_shared(false)       throw CImgIOException(_cimg_instance    
37     : _is_shared(false)       "save_tiff(): Failed to stream for writing.",    
16     : _is_shared(false)       cimg_instance);    
18     : _is_shared(false)       return *this;    
38     : _is_shared(false)      CImg<T>& load_tiff(std::istream* tiffInStream,    
58     : _is_shared(false)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     : _is_shared(false)       const unsigned int step_frame=1)    
19     : _is_shared(false)       const unsigned int    
50     : _is_shared(false)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     : _is_shared(false)       nstep_frame = step_frame?step_frame:1;    
61     : _is_shared(false)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     : _is_shared(false)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
17     : _is_shared(false)       if (tif)    
23     : _is_shared(false)       unsigned int nb_images = 0;    
18     : _is_shared(false)       do     
16     : _is_shared(false)       ++nb_images;    
27     : _is_shared(false)        while (TIFFReadDirectory(tif));    
63     : _is_shared(false)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
100     : _is_shared(false)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     : _is_shared(false)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
21     : _is_shared(false)       if (nfirst_frame>=nb_images)    
18     : _is_shared(false)       return assign();    
21     : _is_shared(false)       if (nlast_frame>=nb_images)    
21     : _is_shared(false)       nlast_frame = nb_images-1;    
20     : _is_shared(false)       TIFFSetDirectory(tif,0);    
17     : _is_shared(false)       CImg<T> frame;    
55     : _is_shared(false)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     : _is_shared(false)       frame._load_tiff(tif,l);    
99     : _is_shared(false)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
67     : _is_shared(false)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     : _is_shared(false)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     : _is_shared(false)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
17     : _is_shared(false)       TIFFClose(tif);    
16     : _is_shared(false)       else    
32     : _is_shared(false)       throw CImgIOException(_cimg_instance    
38     : _is_shared(false)       "load_tiff(): Failed to read data from stream",    
16     : _is_shared(false)       cimg_instance);    
18     : _is_shared(false)       return *this;    
47     : _is_shared(false)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     : _is_shared(false)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     : _is_shared(false)       const unsigned int step_frame=1)    
63     : _is_shared(false)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
19     : _is_shared(false)      #endif    
21     : _is_shared(false)          


53 / 129

46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #ifndef cimg_use_tiff    
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     error cimg_use_tiff not defined    
49     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #endif    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #ifndef cimg_plugin_tiff_stream    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #define cimg_plugin_tiff_stream    
47     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #include <ios>    
82     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (!tiffOutStream->good())    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      "save_tiff(): tiffstream is not good!",    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg_instance);    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (is_empty())    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      "Not allowed to write empty images to stream",    
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg_instance    
51     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      );    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
48     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (tif)    
57     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      tiffOutStream->flush();    
47     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      TIFFClose(tif);    
50     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      else    
42     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
48     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      "save_tiff(): Failed to stream for writing.",    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg_instance);    
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      return *this;    
47     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      const unsigned int step_frame=1)    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      const unsigned int    
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
40     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      nstep_frame = step_frame?step_frame:1;    
55     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
48     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (tif)    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      unsigned int nb_images = 0;    
51     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      do     
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      ++nb_images;    
40     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);       while (TIFFReadDirectory(tif));    
59     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
42     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (nfirst_frame>=nb_images)    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      return assign();    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (nlast_frame>=nb_images)    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      nlast_frame = nb_images-1;    
43     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      TIFFSetDirectory(tif,0);    
48     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      CImg<T> frame;    
54     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      frame._load_tiff(tif,l);    
93     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
64     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
47     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      TIFFClose(tif);    
50     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      else    
42     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
47     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      "load_tiff(): Failed to read data from stream",    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      cimg_instance);    
46     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      return *this;    
50     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
44     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      const unsigned int step_frame=1)    
60     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
49     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);     #endif    
54     mwSize nbdims = mxGetNumberOfDimensions(matlabArray);         


54 / 129

42     mxClassID classID = mxGetClassID(matlabArray);     #ifndef cimg_use_tiff    
43     mxClassID classID = mxGetClassID(matlabArray);     error cimg_use_tiff not defined    
46     mxClassID classID = mxGetClassID(matlabArray);     #endif    
40     mxClassID classID = mxGetClassID(matlabArray);     #ifndef cimg_plugin_tiff_stream    
40     mxClassID classID = mxGetClassID(matlabArray);     #define cimg_plugin_tiff_stream    
43     mxClassID classID = mxGetClassID(matlabArray);     #include <ios>    
85     mxClassID classID = mxGetClassID(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
41     mxClassID classID = mxGetClassID(matlabArray);      if (!tiffOutStream->good())    
41     mxClassID classID = mxGetClassID(matlabArray);      throw CImgArgumentException(_cimg_instance    
41     mxClassID classID = mxGetClassID(matlabArray);      "save_tiff(): tiffstream is not good!",    
39     mxClassID classID = mxGetClassID(matlabArray);      cimg_instance);    
40     mxClassID classID = mxGetClassID(matlabArray);      if (is_empty())    
41     mxClassID classID = mxGetClassID(matlabArray);      throw CImgArgumentException(_cimg_instance    
42     mxClassID classID = mxGetClassID(matlabArray);      "Not allowed to write empty images to stream",    
41     mxClassID classID = mxGetClassID(matlabArray);      cimg_instance    
44     mxClassID classID = mxGetClassID(matlabArray);      );    
45     mxClassID classID = mxGetClassID(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
42     mxClassID classID = mxGetClassID(matlabArray);      if (tif)    
57     mxClassID classID = mxGetClassID(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
39     mxClassID classID = mxGetClassID(matlabArray);      tiffOutStream->flush();    
38     mxClassID classID = mxGetClassID(matlabArray);      TIFFClose(tif);    
43     mxClassID classID = mxGetClassID(matlabArray);      else    
40     mxClassID classID = mxGetClassID(matlabArray);      throw CImgIOException(_cimg_instance    
44     mxClassID classID = mxGetClassID(matlabArray);      "save_tiff(): Failed to stream for writing.",    
39     mxClassID classID = mxGetClassID(matlabArray);      cimg_instance);    
42     mxClassID classID = mxGetClassID(matlabArray);      return *this;    
43     mxClassID classID = mxGetClassID(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
56     mxClassID classID = mxGetClassID(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     mxClassID classID = mxGetClassID(matlabArray);      const unsigned int step_frame=1)    
41     mxClassID classID = mxGetClassID(matlabArray);      const unsigned int    
50     mxClassID classID = mxGetClassID(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
38     mxClassID classID = mxGetClassID(matlabArray);      nstep_frame = step_frame?step_frame:1;    
54     mxClassID classID = mxGetClassID(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     mxClassID classID = mxGetClassID(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
42     mxClassID classID = mxGetClassID(matlabArray);      if (tif)    
40     mxClassID classID = mxGetClassID(matlabArray);      unsigned int nb_images = 0;    
45     mxClassID classID = mxGetClassID(matlabArray);      do     
42     mxClassID classID = mxGetClassID(matlabArray);      ++nb_images;    
39     mxClassID classID = mxGetClassID(matlabArray);       while (TIFFReadDirectory(tif));    
61     mxClassID classID = mxGetClassID(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     mxClassID classID = mxGetClassID(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42     mxClassID classID = mxGetClassID(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
40     mxClassID classID = mxGetClassID(matlabArray);      if (nfirst_frame>=nb_images)    
39     mxClassID classID = mxGetClassID(matlabArray);      return assign();    
38     mxClassID classID = mxGetClassID(matlabArray);      if (nlast_frame>=nb_images)    
36     mxClassID classID = mxGetClassID(matlabArray);      nlast_frame = nb_images-1;    
39     mxClassID classID = mxGetClassID(matlabArray);      TIFFSetDirectory(tif,0);    
40     mxClassID classID = mxGetClassID(matlabArray);      CImg<T> frame;    
55     mxClassID classID = mxGetClassID(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
39     mxClassID classID = mxGetClassID(matlabArray);      frame._load_tiff(tif,l);    
94     mxClassID classID = mxGetClassID(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     mxClassID classID = mxGetClassID(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     mxClassID classID = mxGetClassID(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45     mxClassID classID = mxGetClassID(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
38     mxClassID classID = mxGetClassID(matlabArray);      TIFFClose(tif);    
43     mxClassID classID = mxGetClassID(matlabArray);      else    
40     mxClassID classID = mxGetClassID(matlabArray);      throw CImgIOException(_cimg_instance    
44     mxClassID classID = mxGetClassID(matlabArray);      "load_tiff(): Failed to read data from stream",    
39     mxClassID classID = mxGetClassID(matlabArray);      cimg_instance);    
42     mxClassID classID = mxGetClassID(matlabArray);      return *this;    
49     mxClassID classID = mxGetClassID(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
56     mxClassID classID = mxGetClassID(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     mxClassID classID = mxGetClassID(matlabArray);      const unsigned int step_frame=1)    
61     mxClassID classID = mxGetClassID(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
46     mxClassID classID = mxGetClassID(matlabArray);     #endif    
47     mxClassID classID = mxGetClassID(matlabArray);         


55 / 129

39     if (nbdims>4 || !isNumericalClassID(classID))      #ifndef cimg_use_tiff    
43     if (nbdims>4 || !isNumericalClassID(classID))      error cimg_use_tiff not defined    
44     if (nbdims>4 || !isNumericalClassID(classID))      #endif    
38     if (nbdims>4 || !isNumericalClassID(classID))      #ifndef cimg_plugin_tiff_stream    
41     if (nbdims>4 || !isNumericalClassID(classID))      #define cimg_plugin_tiff_stream    
42     if (nbdims>4 || !isNumericalClassID(classID))      #include <ios>    
82     if (nbdims>4 || !isNumericalClassID(classID))      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
36     if (nbdims>4 || !isNumericalClassID(classID))       if (!tiffOutStream->good())    
43     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
40     if (nbdims>4 || !isNumericalClassID(classID))       "save_tiff(): tiffstream is not good!",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
36     if (nbdims>4 || !isNumericalClassID(classID))       if (is_empty())    
43     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
42     if (nbdims>4 || !isNumericalClassID(classID))       "Not allowed to write empty images to stream",    
41     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance    
45     if (nbdims>4 || !isNumericalClassID(classID))       );    
48     if (nbdims>4 || !isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
40     if (nbdims>4 || !isNumericalClassID(classID))       if (tif)    
56     if (nbdims>4 || !isNumericalClassID(classID))       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
40     if (nbdims>4 || !isNumericalClassID(classID))       tiffOutStream->flush();    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFClose(tif);    
43     if (nbdims>4 || !isNumericalClassID(classID))       else    
42     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
44     if (nbdims>4 || !isNumericalClassID(classID))       "save_tiff(): Failed to stream for writing.",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
43     if (nbdims>4 || !isNumericalClassID(classID))       return *this;    
45     if (nbdims>4 || !isNumericalClassID(classID))      CImg<T>& load_tiff(std::istream* tiffInStream,    
55     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int step_frame=1)    
41     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int    
50     if (nbdims>4 || !isNumericalClassID(classID))       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
40     if (nbdims>4 || !isNumericalClassID(classID))       nstep_frame = step_frame?step_frame:1;    
59     if (nbdims>4 || !isNumericalClassID(classID))       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     if (nbdims>4 || !isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
40     if (nbdims>4 || !isNumericalClassID(classID))       if (tif)    
39     if (nbdims>4 || !isNumericalClassID(classID))       unsigned int nb_images = 0;    
44     if (nbdims>4 || !isNumericalClassID(classID))       do     
40     if (nbdims>4 || !isNumericalClassID(classID))       ++nb_images;    
39     if (nbdims>4 || !isNumericalClassID(classID))        while (TIFFReadDirectory(tif));    
57     if (nbdims>4 || !isNumericalClassID(classID))       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     if (nbdims>4 || !isNumericalClassID(classID))       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     if (nbdims>4 || !isNumericalClassID(classID))       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
34     if (nbdims>4 || !isNumericalClassID(classID))       if (nfirst_frame>=nb_images)    
40     if (nbdims>4 || !isNumericalClassID(classID))       return assign();    
35     if (nbdims>4 || !isNumericalClassID(classID))       if (nlast_frame>=nb_images)    
41     if (nbdims>4 || !isNumericalClassID(classID))       nlast_frame = nb_images-1;    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFSetDirectory(tif,0);    
42     if (nbdims>4 || !isNumericalClassID(classID))       CImg<T> frame;    
51     if (nbdims>4 || !isNumericalClassID(classID))       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
40     if (nbdims>4 || !isNumericalClassID(classID))       frame._load_tiff(tif,l);    
94     if (nbdims>4 || !isNumericalClassID(classID))       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
63     if (nbdims>4 || !isNumericalClassID(classID))       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     if (nbdims>4 || !isNumericalClassID(classID))       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     if (nbdims>4 || !isNumericalClassID(classID))       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFClose(tif);    
43     if (nbdims>4 || !isNumericalClassID(classID))       else    
42     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
42     if (nbdims>4 || !isNumericalClassID(classID))       "load_tiff(): Failed to read data from stream",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
43     if (nbdims>4 || !isNumericalClassID(classID))       return *this;    
52     if (nbdims>4 || !isNumericalClassID(classID))      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int step_frame=1)    
63     if (nbdims>4 || !isNumericalClassID(classID))       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
44     if (nbdims>4 || !isNumericalClassID(classID))      #endif    
47     if (nbdims>4 || !isNumericalClassID(classID))          


56 / 129

47     _data = 0; _width = _height = _depth = _spectrum = 0;     #ifndef cimg_use_tiff    
46     _data = 0; _width = _height = _depth = _spectrum = 0;     error cimg_use_tiff not defined    
52     _data = 0; _width = _height = _depth = _spectrum = 0;     #endif    
44     _data = 0; _width = _height = _depth = _spectrum = 0;     #ifndef cimg_plugin_tiff_stream    
43     _data = 0; _width = _height = _depth = _spectrum = 0;     #define cimg_plugin_tiff_stream    
49     _data = 0; _width = _height = _depth = _spectrum = 0;     #include <ios>    
82     _data = 0; _width = _height = _depth = _spectrum = 0;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
49     _data = 0; _width = _height = _depth = _spectrum = 0;      if (!tiffOutStream->good())    
45     _data = 0; _width = _height = _depth = _spectrum = 0;      throw CImgArgumentException(_cimg_instance    
44     _data = 0; _width = _height = _depth = _spectrum = 0;      "save_tiff(): tiffstream is not good!",    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg_instance);    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      if (is_empty())    
45     _data = 0; _width = _height = _depth = _spectrum = 0;      throw CImgArgumentException(_cimg_instance    
42     _data = 0; _width = _height = _depth = _spectrum = 0;      "Not allowed to write empty images to stream",    
48     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg_instance    
52     _data = 0; _width = _height = _depth = _spectrum = 0;      );    
48     _data = 0; _width = _height = _depth = _spectrum = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
50     _data = 0; _width = _height = _depth = _spectrum = 0;      if (tif)    
57     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      tiffOutStream->flush();    
49     _data = 0; _width = _height = _depth = _spectrum = 0;      TIFFClose(tif);    
50     _data = 0; _width = _height = _depth = _spectrum = 0;      else    
45     _data = 0; _width = _height = _depth = _spectrum = 0;      throw CImgIOException(_cimg_instance    
45     _data = 0; _width = _height = _depth = _spectrum = 0;      "save_tiff(): Failed to stream for writing.",    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg_instance);    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      return *this;    
46     _data = 0; _width = _height = _depth = _spectrum = 0;     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     _data = 0; _width = _height = _depth = _spectrum = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
41     _data = 0; _width = _height = _depth = _spectrum = 0;      const unsigned int step_frame=1)    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      const unsigned int    
53     _data = 0; _width = _height = _depth = _spectrum = 0;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
42     _data = 0; _width = _height = _depth = _spectrum = 0;      nstep_frame = step_frame?step_frame:1;    
60     _data = 0; _width = _height = _depth = _spectrum = 0;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
50     _data = 0; _width = _height = _depth = _spectrum = 0;      if (tif)    
40     _data = 0; _width = _height = _depth = _spectrum = 0;      unsigned int nb_images = 0;    
51     _data = 0; _width = _height = _depth = _spectrum = 0;      do     
47     _data = 0; _width = _height = _depth = _spectrum = 0;      ++nb_images;    
45     _data = 0; _width = _height = _depth = _spectrum = 0;       while (TIFFReadDirectory(tif));    
64     _data = 0; _width = _height = _depth = _spectrum = 0;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
92     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
48     _data = 0; _width = _height = _depth = _spectrum = 0;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      if (nfirst_frame>=nb_images)    
48     _data = 0; _width = _height = _depth = _spectrum = 0;      return assign();    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      if (nlast_frame>=nb_images)    
44     _data = 0; _width = _height = _depth = _spectrum = 0;      nlast_frame = nb_images-1;    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      TIFFSetDirectory(tif,0);    
48     _data = 0; _width = _height = _depth = _spectrum = 0;      CImg<T> frame;    
55     _data = 0; _width = _height = _depth = _spectrum = 0;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
47     _data = 0; _width = _height = _depth = _spectrum = 0;      frame._load_tiff(tif,l);    
87     _data = 0; _width = _height = _depth = _spectrum = 0;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
50     _data = 0; _width = _height = _depth = _spectrum = 0;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
88     _data = 0; _width = _height = _depth = _spectrum = 0;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
49     _data = 0; _width = _height = _depth = _spectrum = 0;      TIFFClose(tif);    
50     _data = 0; _width = _height = _depth = _spectrum = 0;      else    
45     _data = 0; _width = _height = _depth = _spectrum = 0;      throw CImgIOException(_cimg_instance    
44     _data = 0; _width = _height = _depth = _spectrum = 0;      "load_tiff(): Failed to read data from stream",    
47     _data = 0; _width = _height = _depth = _spectrum = 0;      cimg_instance);    
46     _data = 0; _width = _height = _depth = _spectrum = 0;      return *this;    
50     _data = 0; _width = _height = _depth = _spectrum = 0;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     _data = 0; _width = _height = _depth = _spectrum = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
41     _data = 0; _width = _height = _depth = _spectrum = 0;      const unsigned int step_frame=1)    
63     _data = 0; _width = _height = _depth = _spectrum = 0;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
52     _data = 0; _width = _height = _depth = _spectrum = 0;     #endif    
54     _data = 0; _width = _height = _depth = _spectrum = 0;         


57 / 129

11    #if cimg_debug>1     #ifndef cimg_use_tiff    
23    #if cimg_debug>1     error cimg_use_tiff not defined    
14    #if cimg_debug>1     #endif    
21    #if cimg_debug>1     #ifndef cimg_plugin_tiff_stream    
22    #if cimg_debug>1     #define cimg_plugin_tiff_stream    
12    #if cimg_debug>1     #include <ios>    
91    #if cimg_debug>1     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
22    #if cimg_debug>1      if (!tiffOutStream->good())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
34    #if cimg_debug>1      "save_tiff(): tiffstream is not good!",    
13    #if cimg_debug>1      cimg_instance);    
12    #if cimg_debug>1      if (is_empty())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
42    #if cimg_debug>1      "Not allowed to write empty images to stream",    
11    #if cimg_debug>1      cimg_instance    
15    #if cimg_debug>1      );    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13    #if cimg_debug>1      if (tif)    
62    #if cimg_debug>1      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20    #if cimg_debug>1      tiffOutStream->flush();    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
40    #if cimg_debug>1      "save_tiff(): Failed to stream for writing.",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
42    #if cimg_debug>1     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
17    #if cimg_debug>1      const unsigned int    
55    #if cimg_debug>1      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34    #if cimg_debug>1      nstep_frame = step_frame?step_frame:1;    
67    #if cimg_debug>1      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13    #if cimg_debug>1      if (tif)    
24    #if cimg_debug>1      unsigned int nb_images = 0;    
14    #if cimg_debug>1      do     
14    #if cimg_debug>1      ++nb_images;    
29    #if cimg_debug>1       while (TIFFReadDirectory(tif));    
67    #if cimg_debug>1      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103    #if cimg_debug>1      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42    #if cimg_debug>1      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
21    #if cimg_debug>1      if (nfirst_frame>=nb_images)    
17    #if cimg_debug>1      return assign();    
21    #if cimg_debug>1      if (nlast_frame>=nb_images)    
23    #if cimg_debug>1      nlast_frame = nb_images-1;    
23    #if cimg_debug>1      TIFFSetDirectory(tif,0);    
15    #if cimg_debug>1      CImg<T> frame;    
63    #if cimg_debug>1      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    #if cimg_debug>1      frame._load_tiff(tif,l);    
103    #if cimg_debug>1      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    #if cimg_debug>1      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107    #if cimg_debug>1      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    #if cimg_debug>1      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
43    #if cimg_debug>1      "load_tiff(): Failed to read data from stream",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
49    #if cimg_debug>1     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
70    #if cimg_debug>1      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
14    #if cimg_debug>1     #endif    
16    #if cimg_debug>1         


58 / 129

82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #ifndef cimg_use_tiff    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     error cimg_use_tiff not defined    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #endif    
80     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #ifndef cimg_plugin_tiff_stream    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #define cimg_plugin_tiff_stream    
85     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #include <ios>    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (!tiffOutStream->good())    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgArgumentException(_cimg_instance    
76     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "save_tiff(): tiffstream is not good!",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (is_empty())    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgArgumentException(_cimg_instance    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "Not allowed to write empty images to stream",    
80     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance    
89     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      );    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
86     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (tif)    
72     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      tiffOutStream->flush();    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFClose(tif);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      else    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgIOException(_cimg_instance    
71     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "save_tiff(): Failed to stream for writing.",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return *this;    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     CImg<T>& load_tiff(std::istream* tiffInStream,    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int step_frame=1)    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nstep_frame = step_frame?step_frame:1;    
76     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
86     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (tif)    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      unsigned int nb_images = 0;    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      do     
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      ++nb_images;    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");       while (TIFFReadDirectory(tif));    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
70     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nfirst_frame>=nb_images)    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return assign();    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nlast_frame>=nb_images)    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nlast_frame = nb_images-1;    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFSetDirectory(tif,0);    
82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      CImg<T> frame;    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      frame._load_tiff(tif,l);    
94     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
97     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFClose(tif);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      else    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgIOException(_cimg_instance    
72     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "load_tiff(): Failed to read data from stream",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return *this;    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int step_frame=1)    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #endif    
92     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");         


59 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


60 / 129

18      else      #ifndef cimg_use_tiff    
27      else      error cimg_use_tiff not defined    
6      else      #endif    
27      else      #ifndef cimg_plugin_tiff_stream    
27      else      #define cimg_plugin_tiff_stream    
11      else      #include <ios>    
93      else      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25      else       if (!tiffOutStream->good())    
39      else       throw CImgArgumentException(_cimg_instance    
35      else       "save_tiff(): tiffstream is not good!",    
13      else       cimg_instance);    
12      else       if (is_empty())    
39      else       throw CImgArgumentException(_cimg_instance    
42      else       "Not allowed to write empty images to stream",    
12      else       cimg_instance    
6      else       );    
49      else       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
7      else       if (tif)    
62      else       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20      else       tiffOutStream->flush();    
12      else       TIFFClose(tif);    
2      else       else    


61 / 129

44     const mwSize *dims = mxGetDimensions(matlabArray);     #ifndef cimg_use_tiff    
43     const mwSize *dims = mxGetDimensions(matlabArray);     error cimg_use_tiff not defined    
48     const mwSize *dims = mxGetDimensions(matlabArray);     #endif    
42     const mwSize *dims = mxGetDimensions(matlabArray);     #ifndef cimg_plugin_tiff_stream    
41     const mwSize *dims = mxGetDimensions(matlabArray);     #define cimg_plugin_tiff_stream    
45     const mwSize *dims = mxGetDimensions(matlabArray);     #include <ios>    
77     const mwSize *dims = mxGetDimensions(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
43     const mwSize *dims = mxGetDimensions(matlabArray);      if (!tiffOutStream->good())    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
43     const mwSize *dims = mxGetDimensions(matlabArray);      "save_tiff(): tiffstream is not good!",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (is_empty())    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
40     const mwSize *dims = mxGetDimensions(matlabArray);      "Not allowed to write empty images to stream",    
42     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance    
48     const mwSize *dims = mxGetDimensions(matlabArray);      );    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      if (tif)    
55     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      tiffOutStream->flush();    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFClose(tif);    
47     const mwSize *dims = mxGetDimensions(matlabArray);      else    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
45     const mwSize *dims = mxGetDimensions(matlabArray);      "save_tiff(): Failed to stream for writing.",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      return *this;    
46     const mwSize *dims = mxGetDimensions(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
47     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int step_frame=1)    
38     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int    
46     const mwSize *dims = mxGetDimensions(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
39     const mwSize *dims = mxGetDimensions(matlabArray);      nstep_frame = step_frame?step_frame:1;    
54     const mwSize *dims = mxGetDimensions(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     const mwSize *dims = mxGetDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      if (tif)    
40     const mwSize *dims = mxGetDimensions(matlabArray);      unsigned int nb_images = 0;    
48     const mwSize *dims = mxGetDimensions(matlabArray);      do     
44     const mwSize *dims = mxGetDimensions(matlabArray);      ++nb_images;    
37     const mwSize *dims = mxGetDimensions(matlabArray);       while (TIFFReadDirectory(tif));    
59     const mwSize *dims = mxGetDimensions(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     const mwSize *dims = mxGetDimensions(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42     const mwSize *dims = mxGetDimensions(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (nfirst_frame>=nb_images)    
41     const mwSize *dims = mxGetDimensions(matlabArray);      return assign();    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (nlast_frame>=nb_images)    
40     const mwSize *dims = mxGetDimensions(matlabArray);      nlast_frame = nb_images-1;    
39     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFSetDirectory(tif,0);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      CImg<T> frame;    
52     const mwSize *dims = mxGetDimensions(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
42     const mwSize *dims = mxGetDimensions(matlabArray);      frame._load_tiff(tif,l);    
92     const mwSize *dims = mxGetDimensions(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
64     const mwSize *dims = mxGetDimensions(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     const mwSize *dims = mxGetDimensions(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFClose(tif);    
47     const mwSize *dims = mxGetDimensions(matlabArray);      else    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
44     const mwSize *dims = mxGetDimensions(matlabArray);      "load_tiff(): Failed to read data from stream",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      return *this;    
50     const mwSize *dims = mxGetDimensions(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
47     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int step_frame=1)    
60     const mwSize *dims = mxGetDimensions(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
48     const mwSize *dims = mxGetDimensions(matlabArray);     #endif    
51     const mwSize *dims = mxGetDimensions(matlabArray);         


62 / 129

21     _depth = _spectrum = 1;     #ifndef cimg_use_tiff    
26     _depth = _spectrum = 1;     error cimg_use_tiff not defined    
23     _depth = _spectrum = 1;     #endif    
27     _depth = _spectrum = 1;     #ifndef cimg_plugin_tiff_stream    
27     _depth = _spectrum = 1;     #define cimg_plugin_tiff_stream    
23     _depth = _spectrum = 1;     #include <ios>    
86     _depth = _spectrum = 1;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     _depth = _spectrum = 1;      if (!tiffOutStream->good())    
38     _depth = _spectrum = 1;      throw CImgArgumentException(_cimg_instance    
31     _depth = _spectrum = 1;      "save_tiff(): tiffstream is not good!",    
20     _depth = _spectrum = 1;      cimg_instance);    
20     _depth = _spectrum = 1;      if (is_empty())    
38     _depth = _spectrum = 1;      throw CImgArgumentException(_cimg_instance    
38     _depth = _spectrum = 1;      "Not allowed to write empty images to stream",    
21     _depth = _spectrum = 1;      cimg_instance    
22     _depth = _spectrum = 1;      );    
44     _depth = _spectrum = 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
21     _depth = _spectrum = 1;      if (tif)    
57     _depth = _spectrum = 1;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22     _depth = _spectrum = 1;      tiffOutStream->flush();    
19     _depth = _spectrum = 1;      TIFFClose(tif);    
20     _depth = _spectrum = 1;      else    
32     _depth = _spectrum = 1;      throw CImgIOException(_cimg_instance    
36     _depth = _spectrum = 1;      "save_tiff(): Failed to stream for writing.",    
20     _depth = _spectrum = 1;      cimg_instance);    
18     _depth = _spectrum = 1;      return *this;    
39     _depth = _spectrum = 1;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     _depth = _spectrum = 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _depth = _spectrum = 1;      const unsigned int step_frame=1)    
19     _depth = _spectrum = 1;      const unsigned int    
51     _depth = _spectrum = 1;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
27     _depth = _spectrum = 1;      nstep_frame = step_frame?step_frame:1;    
61     _depth = _spectrum = 1;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     _depth = _spectrum = 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
21     _depth = _spectrum = 1;      if (tif)    
21     _depth = _spectrum = 1;      unsigned int nb_images = 0;    
21     _depth = _spectrum = 1;      do     
20     _depth = _spectrum = 1;      ++nb_images;    
26     _depth = _spectrum = 1;       while (TIFFReadDirectory(tif));    
66     _depth = _spectrum = 1;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     _depth = _spectrum = 1;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     _depth = _spectrum = 1;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     _depth = _spectrum = 1;      if (nfirst_frame>=nb_images)    
18     _depth = _spectrum = 1;      return assign();    
24     _depth = _spectrum = 1;      if (nlast_frame>=nb_images)    
22     _depth = _spectrum = 1;      nlast_frame = nb_images-1;    
21     _depth = _spectrum = 1;      TIFFSetDirectory(tif,0);    
19     _depth = _spectrum = 1;      CImg<T> frame;    
56     _depth = _spectrum = 1;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     _depth = _spectrum = 1;      frame._load_tiff(tif,l);    
102     _depth = _spectrum = 1;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
62     _depth = _spectrum = 1;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _depth = _spectrum = 1;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     _depth = _spectrum = 1;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     _depth = _spectrum = 1;      TIFFClose(tif);    
20     _depth = _spectrum = 1;      else    
32     _depth = _spectrum = 1;      throw CImgIOException(_cimg_instance    
39     _depth = _spectrum = 1;      "load_tiff(): Failed to read data from stream",    
20     _depth = _spectrum = 1;      cimg_instance);    
18     _depth = _spectrum = 1;      return *this;    
48     _depth = _spectrum = 1;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     _depth = _spectrum = 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _depth = _spectrum = 1;      const unsigned int step_frame=1)    
67     _depth = _spectrum = 1;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
23     _depth = _spectrum = 1;     #endif    
24     _depth = _spectrum = 1;         


63 / 129

24     _width = (unsigned)dims[1];     #ifndef cimg_use_tiff    
28     _width = (unsigned)dims[1];     error cimg_use_tiff not defined    
25     _width = (unsigned)dims[1];     #endif    
26     _width = (unsigned)dims[1];     #ifndef cimg_plugin_tiff_stream    
27     _width = (unsigned)dims[1];     #define cimg_plugin_tiff_stream    
23     _width = (unsigned)dims[1];     #include <ios>    
82     _width = (unsigned)dims[1];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     _width = (unsigned)dims[1];      if (!tiffOutStream->good())    
35     _width = (unsigned)dims[1];      throw CImgArgumentException(_cimg_instance    
34     _width = (unsigned)dims[1];      "save_tiff(): tiffstream is not good!",    
21     _width = (unsigned)dims[1];      cimg_instance);    
22     _width = (unsigned)dims[1];      if (is_empty())    
35     _width = (unsigned)dims[1];      throw CImgArgumentException(_cimg_instance    
38     _width = (unsigned)dims[1];      "Not allowed to write empty images to stream",    
23     _width = (unsigned)dims[1];      cimg_instance    
25     _width = (unsigned)dims[1];      );    
45     _width = (unsigned)dims[1];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
22     _width = (unsigned)dims[1];      if (tif)    
56     _width = (unsigned)dims[1];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
24     _width = (unsigned)dims[1];      tiffOutStream->flush();    
23     _width = (unsigned)dims[1];      TIFFClose(tif);    
25     _width = (unsigned)dims[1];      else    
31     _width = (unsigned)dims[1];      throw CImgIOException(_cimg_instance    
39     _width = (unsigned)dims[1];      "save_tiff(): Failed to stream for writing.",    
21     _width = (unsigned)dims[1];      cimg_instance);    
21     _width = (unsigned)dims[1];      return *this;    
40     _width = (unsigned)dims[1];     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     _width = (unsigned)dims[1];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _width = (unsigned)dims[1];      const unsigned int step_frame=1)    
16     _width = (unsigned)dims[1];      const unsigned int    
51     _width = (unsigned)dims[1];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     _width = (unsigned)dims[1];      nstep_frame = step_frame?step_frame:1;    
62     _width = (unsigned)dims[1];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     _width = (unsigned)dims[1];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
22     _width = (unsigned)dims[1];      if (tif)    
24     _width = (unsigned)dims[1];      unsigned int nb_images = 0;    
25     _width = (unsigned)dims[1];      do     
23     _width = (unsigned)dims[1];      ++nb_images;    
28     _width = (unsigned)dims[1];       while (TIFFReadDirectory(tif));    
66     _width = (unsigned)dims[1];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     _width = (unsigned)dims[1];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _width = (unsigned)dims[1];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     _width = (unsigned)dims[1];      if (nfirst_frame>=nb_images)    
19     _width = (unsigned)dims[1];      return assign();    
25     _width = (unsigned)dims[1];      if (nlast_frame>=nb_images)    
23     _width = (unsigned)dims[1];      nlast_frame = nb_images-1;    
25     _width = (unsigned)dims[1];      TIFFSetDirectory(tif,0);    
24     _width = (unsigned)dims[1];      CImg<T> frame;    
58     _width = (unsigned)dims[1];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
24     _width = (unsigned)dims[1];      frame._load_tiff(tif,l);    
99     _width = (unsigned)dims[1];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     _width = (unsigned)dims[1];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _width = (unsigned)dims[1];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     _width = (unsigned)dims[1];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
23     _width = (unsigned)dims[1];      TIFFClose(tif);    
25     _width = (unsigned)dims[1];      else    
31     _width = (unsigned)dims[1];      throw CImgIOException(_cimg_instance    
39     _width = (unsigned)dims[1];      "load_tiff(): Failed to read data from stream",    
21     _width = (unsigned)dims[1];      cimg_instance);    
21     _width = (unsigned)dims[1];      return *this;    
49     _width = (unsigned)dims[1];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     _width = (unsigned)dims[1];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _width = (unsigned)dims[1];      const unsigned int step_frame=1)    
66     _width = (unsigned)dims[1];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
25     _width = (unsigned)dims[1];     #endif    
28     _width = (unsigned)dims[1];         


64 / 129

25     _height = (unsigned)dims[0];     #ifndef cimg_use_tiff    
29     _height = (unsigned)dims[0];     error cimg_use_tiff not defined    
25     _height = (unsigned)dims[0];     #endif    
28     _height = (unsigned)dims[0];     #ifndef cimg_plugin_tiff_stream    
27     _height = (unsigned)dims[0];     #define cimg_plugin_tiff_stream    
24     _height = (unsigned)dims[0];     #include <ios>    
82     _height = (unsigned)dims[0];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     _height = (unsigned)dims[0];      if (!tiffOutStream->good())    
35     _height = (unsigned)dims[0];      throw CImgArgumentException(_cimg_instance    
34     _height = (unsigned)dims[0];      "save_tiff(): tiffstream is not good!",    
22     _height = (unsigned)dims[0];      cimg_instance);    
23     _height = (unsigned)dims[0];      if (is_empty())    
35     _height = (unsigned)dims[0];      throw CImgArgumentException(_cimg_instance    
40     _height = (unsigned)dims[0];      "Not allowed to write empty images to stream",    
24     _height = (unsigned)dims[0];      cimg_instance    
26     _height = (unsigned)dims[0];      );    
45     _height = (unsigned)dims[0];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23     _height = (unsigned)dims[0];      if (tif)    
57     _height = (unsigned)dims[0];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     _height = (unsigned)dims[0];      tiffOutStream->flush();    
24     _height = (unsigned)dims[0];      TIFFClose(tif);    
25     _height = (unsigned)dims[0];      else    
31     _height = (unsigned)dims[0];      throw CImgIOException(_cimg_instance    
39     _height = (unsigned)dims[0];      "save_tiff(): Failed to stream for writing.",    
22     _height = (unsigned)dims[0];      cimg_instance);    
21     _height = (unsigned)dims[0];      return *this;    
41     _height = (unsigned)dims[0];     CImg<T>& load_tiff(std::istream* tiffInStream,    
52     _height = (unsigned)dims[0];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     _height = (unsigned)dims[0];      const unsigned int step_frame=1)    
17     _height = (unsigned)dims[0];      const unsigned int    
52     _height = (unsigned)dims[0];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     _height = (unsigned)dims[0];      nstep_frame = step_frame?step_frame:1;    
62     _height = (unsigned)dims[0];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     _height = (unsigned)dims[0];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23     _height = (unsigned)dims[0];      if (tif)    
23     _height = (unsigned)dims[0];      unsigned int nb_images = 0;    
27     _height = (unsigned)dims[0];      do     
24     _height = (unsigned)dims[0];      ++nb_images;    
28     _height = (unsigned)dims[0];       while (TIFFReadDirectory(tif));    
64     _height = (unsigned)dims[0];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
98     _height = (unsigned)dims[0];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _height = (unsigned)dims[0];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     _height = (unsigned)dims[0];      if (nfirst_frame>=nb_images)    
20     _height = (unsigned)dims[0];      return assign();    
26     _height = (unsigned)dims[0];      if (nlast_frame>=nb_images)    
25     _height = (unsigned)dims[0];      nlast_frame = nb_images-1;    
24     _height = (unsigned)dims[0];      TIFFSetDirectory(tif,0);    
24     _height = (unsigned)dims[0];      CImg<T> frame;    
58     _height = (unsigned)dims[0];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
25     _height = (unsigned)dims[0];      frame._load_tiff(tif,l);    
98     _height = (unsigned)dims[0];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     _height = (unsigned)dims[0];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _height = (unsigned)dims[0];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     _height = (unsigned)dims[0];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24     _height = (unsigned)dims[0];      TIFFClose(tif);    
25     _height = (unsigned)dims[0];      else    
31     _height = (unsigned)dims[0];      throw CImgIOException(_cimg_instance    
39     _height = (unsigned)dims[0];      "load_tiff(): Failed to read data from stream",    
22     _height = (unsigned)dims[0];      cimg_instance);    
21     _height = (unsigned)dims[0];      return *this;    
49     _height = (unsigned)dims[0];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
52     _height = (unsigned)dims[0];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     _height = (unsigned)dims[0];      const unsigned int step_frame=1)    
66     _height = (unsigned)dims[0];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
25     _height = (unsigned)dims[0];     #endif    
29     _height = (unsigned)dims[0];         


65 / 129

63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #ifndef cimg_use_tiff    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      error cimg_use_tiff not defined    
72     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #endif    
60     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #ifndef cimg_plugin_tiff_stream    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #define cimg_plugin_tiff_stream    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #include <ios>    
81     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (!tiffOutStream->good())    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       throw CImgArgumentException(_cimg_instance    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       "save_tiff(): tiffstream is not good!",    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg_instance);    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (is_empty())    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       throw CImgArgumentException(_cimg_instance    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       "Not allowed to write empty images to stream",    
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg_instance    
73     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       );    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (tif)    
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
67     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       tiffOutStream->flush();    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       TIFFClose(tif);    
72     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       else    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       throw CImgIOException(_cimg_instance    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       "save_tiff(): Failed to stream for writing.",    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg_instance);    
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       return *this;    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      CImg<T>& load_tiff(std::istream* tiffInStream,    
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       const unsigned int step_frame=1)    
60     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       const unsigned int    
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
61     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       nstep_frame = step_frame?step_frame:1;    
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (tif)    
61     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       unsigned int nb_images = 0;    
73     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       do     
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       ++nb_images;    
61     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];        while (TIFFReadDirectory(tif));    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
91     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (nfirst_frame>=nb_images)    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       return assign();    
61     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (nlast_frame>=nb_images)    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       nlast_frame = nb_images-1;    
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       TIFFSetDirectory(tif,0);    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       CImg<T> frame;    
61     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       frame._load_tiff(tif,l);    
93     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
96     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       TIFFClose(tif);    
72     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       else    
63     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       throw CImgIOException(_cimg_instance    
62     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       "load_tiff(): Failed to read data from stream",    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       cimg_instance);    
66     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       return *this;    
64     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
65     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       const unsigned int step_frame=1)    
68     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
72     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];      #endif    
76     if (nbdims==4)  _depth = (unsigned)dims[2]; _spectrum = (unsigned)dims[3];          


66 / 129

19     else if (nbdims==3)      #ifndef cimg_use_tiff    
25     else if (nbdims==3)      error cimg_use_tiff not defined    
17     else if (nbdims==3)      #endif    
25     else if (nbdims==3)      #ifndef cimg_plugin_tiff_stream    
24     else if (nbdims==3)      #define cimg_plugin_tiff_stream    
18     else if (nbdims==3)      #include <ios>    
83     else if (nbdims==3)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
23     else if (nbdims==3)       if (!tiffOutStream->good())    
36     else if (nbdims==3)       throw CImgArgumentException(_cimg_instance    
31     else if (nbdims==3)       "save_tiff(): tiffstream is not good!",    
17     else if (nbdims==3)       cimg_instance);    
14     else if (nbdims==3)       if (is_empty())    
36     else if (nbdims==3)       throw CImgArgumentException(_cimg_instance    
38     else if (nbdims==3)       "Not allowed to write empty images to stream",    
17     else if (nbdims==3)       cimg_instance    
19     else if (nbdims==3)       );    
46     else if (nbdims==3)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
14     else if (nbdims==3)       if (tif)    
57     else if (nbdims==3)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22     else if (nbdims==3)       tiffOutStream->flush();    
18     else if (nbdims==3)       TIFFClose(tif);    
16     else if (nbdims==3)       else    
31     else if (nbdims==3)       throw CImgIOException(_cimg_instance    
38     else if (nbdims==3)       "save_tiff(): Failed to stream for writing.",    
17     else if (nbdims==3)       cimg_instance);    
17     else if (nbdims==3)       return *this;    
39     else if (nbdims==3)      CImg<T>& load_tiff(std::istream* tiffInStream,    
57     else if (nbdims==3)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     else if (nbdims==3)       const unsigned int step_frame=1)    
18     else if (nbdims==3)       const unsigned int    
53     else if (nbdims==3)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     else if (nbdims==3)       nstep_frame = step_frame?step_frame:1;    
64     else if (nbdims==3)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     else if (nbdims==3)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
14     else if (nbdims==3)       if (tif)    
17     else if (nbdims==3)       unsigned int nb_images = 0;    
18     else if (nbdims==3)       do     
16     else if (nbdims==3)       ++nb_images;    
27     else if (nbdims==3)        while (TIFFReadDirectory(tif));    
65     else if (nbdims==3)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
101     else if (nbdims==3)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
38     else if (nbdims==3)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
22     else if (nbdims==3)       if (nfirst_frame>=nb_images)    
17     else if (nbdims==3)       return assign();    
21     else if (nbdims==3)       if (nlast_frame>=nb_images)    
19     else if (nbdims==3)       nlast_frame = nb_images-1;    
21     else if (nbdims==3)       TIFFSetDirectory(tif,0);    
18     else if (nbdims==3)       CImg<T> frame;    
57     else if (nbdims==3)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
21     else if (nbdims==3)       frame._load_tiff(tif,l);    
101     else if (nbdims==3)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
72     else if (nbdims==3)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107     else if (nbdims==3)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     else if (nbdims==3)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
18     else if (nbdims==3)       TIFFClose(tif);    
16     else if (nbdims==3)       else    
31     else if (nbdims==3)       throw CImgIOException(_cimg_instance    
40     else if (nbdims==3)       "load_tiff(): Failed to read data from stream",    
17     else if (nbdims==3)       cimg_instance);    
17     else if (nbdims==3)       return *this;    
47     else if (nbdims==3)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     else if (nbdims==3)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     else if (nbdims==3)       const unsigned int step_frame=1)    
65     else if (nbdims==3)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
17     else if (nbdims==3)      #endif    
21     else if (nbdims==3)          


67 / 129

63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #ifndef cimg_use_tiff    
60     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     error cimg_use_tiff not defined    
71     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #endif    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #ifndef cimg_plugin_tiff_stream    
63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #define cimg_plugin_tiff_stream    
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #include <ios>    
82     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (!tiffOutStream->good())    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      throw CImgArgumentException(_cimg_instance    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      "save_tiff(): tiffstream is not good!",    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg_instance);    
63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (is_empty())    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      throw CImgArgumentException(_cimg_instance    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      "Not allowed to write empty images to stream",    
66     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg_instance    
72     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      );    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (tif)    
66     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      tiffOutStream->flush();    
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      TIFFClose(tif);    
70     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      else    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      throw CImgIOException(_cimg_instance    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      "save_tiff(): Failed to stream for writing.",    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg_instance);    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      return *this;    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     CImg<T>& load_tiff(std::istream* tiffInStream,    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
57     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      const unsigned int step_frame=1)    
60     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      const unsigned int    
63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
60     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      nstep_frame = step_frame?step_frame:1;    
65     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (tif)    
59     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      unsigned int nb_images = 0;    
72     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      do     
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      ++nb_images;    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];       while (TIFFReadDirectory(tif));    
66     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
88     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (nfirst_frame>=nb_images)    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      return assign();    
60     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (nlast_frame>=nb_images)    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      nlast_frame = nb_images-1;    
65     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      TIFFSetDirectory(tif,0);    
69     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      CImg<T> frame;    
61     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
63     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      frame._load_tiff(tif,l);    
90     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
62     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
67     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      TIFFClose(tif);    
70     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      else    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      throw CImgIOException(_cimg_instance    
60     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      "load_tiff(): Failed to read data from stream",    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      cimg_instance);    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      return *this;    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
57     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      const unsigned int step_frame=1)    
70     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
71     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];     #endif    
75     if (vdata) _spectrum = (unsigned)dims[2]; else _depth = (unsigned)dims[2];         


68 / 129

21     _data = new T[size()];     #ifndef cimg_use_tiff    
26     _data = new T[size()];     error cimg_use_tiff not defined    
21     _data = new T[size()];     #endif    
29     _data = new T[size()];     #ifndef cimg_plugin_tiff_stream    
29     _data = new T[size()];     #define cimg_plugin_tiff_stream    
20     _data = new T[size()];     #include <ios>    
84     _data = new T[size()];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     _data = new T[size()];      if (!tiffOutStream->good())    
38     _data = new T[size()];      throw CImgArgumentException(_cimg_instance    
34     _data = new T[size()];      "save_tiff(): tiffstream is not good!",    
18     _data = new T[size()];      cimg_instance);    
19     _data = new T[size()];      if (is_empty())    
38     _data = new T[size()];      throw CImgArgumentException(_cimg_instance    
38     _data = new T[size()];      "Not allowed to write empty images to stream",    
20     _data = new T[size()];      cimg_instance    
20     _data = new T[size()];      );    
44     _data = new T[size()];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     _data = new T[size()];      if (tif)    
58     _data = new T[size()];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     _data = new T[size()];      tiffOutStream->flush();    
18     _data = new T[size()];      TIFFClose(tif);    
19     _data = new T[size()];      else    
33     _data = new T[size()];      throw CImgIOException(_cimg_instance    
37     _data = new T[size()];      "save_tiff(): Failed to stream for writing.",    
18     _data = new T[size()];      cimg_instance);    
17     _data = new T[size()];      return *this;    
40     _data = new T[size()];     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     _data = new T[size()];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     _data = new T[size()];      const unsigned int step_frame=1)    
19     _data = new T[size()];      const unsigned int    
53     _data = new T[size()];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     _data = new T[size()];      nstep_frame = step_frame?step_frame:1;    
62     _data = new T[size()];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     _data = new T[size()];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     _data = new T[size()];      if (tif)    
22     _data = new T[size()];      unsigned int nb_images = 0;    
20     _data = new T[size()];      do     
19     _data = new T[size()];      ++nb_images;    
26     _data = new T[size()];       while (TIFFReadDirectory(tif));    
65     _data = new T[size()];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
98     _data = new T[size()];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _data = new T[size()];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     _data = new T[size()];      if (nfirst_frame>=nb_images)    
14     _data = new T[size()];      return assign();    
23     _data = new T[size()];      if (nlast_frame>=nb_images)    
19     _data = new T[size()];      nlast_frame = nb_images-1;    
21     _data = new T[size()];      TIFFSetDirectory(tif,0);    
19     _data = new T[size()];      CImg<T> frame;    
58     _data = new T[size()];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
21     _data = new T[size()];      frame._load_tiff(tif,l);    
103     _data = new T[size()];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     _data = new T[size()];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107     _data = new T[size()];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     _data = new T[size()];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
18     _data = new T[size()];      TIFFClose(tif);    
19     _data = new T[size()];      else    
33     _data = new T[size()];      throw CImgIOException(_cimg_instance    
38     _data = new T[size()];      "load_tiff(): Failed to read data from stream",    
18     _data = new T[size()];      cimg_instance);    
17     _data = new T[size()];      return *this;    
49     _data = new T[size()];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     _data = new T[size()];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     _data = new T[size()];      const unsigned int step_frame=1)    
68     _data = new T[size()];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
21     _data = new T[size()];     #endif    
23     _data = new T[size()];         


69 / 129

44     makeImageFromMatlabData(matlabArray,classID);     #ifndef cimg_use_tiff    
42     makeImageFromMatlabData(matlabArray,classID);     error cimg_use_tiff not defined    
45     makeImageFromMatlabData(matlabArray,classID);     #endif    
42     makeImageFromMatlabData(matlabArray,classID);     #ifndef cimg_plugin_tiff_stream    
40     makeImageFromMatlabData(matlabArray,classID);     #define cimg_plugin_tiff_stream    
44     makeImageFromMatlabData(matlabArray,classID);     #include <ios>    
84     makeImageFromMatlabData(matlabArray,classID);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
39     makeImageFromMatlabData(matlabArray,classID);      if (!tiffOutStream->good())    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgArgumentException(_cimg_instance    
41     makeImageFromMatlabData(matlabArray,classID);      "save_tiff(): tiffstream is not good!",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      if (is_empty())    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgArgumentException(_cimg_instance    
42     makeImageFromMatlabData(matlabArray,classID);      "Not allowed to write empty images to stream",    
40     makeImageFromMatlabData(matlabArray,classID);      cimg_instance    
43     makeImageFromMatlabData(matlabArray,classID);      );    
47     makeImageFromMatlabData(matlabArray,classID);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
42     makeImageFromMatlabData(matlabArray,classID);      if (tif)    
56     makeImageFromMatlabData(matlabArray,classID);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
37     makeImageFromMatlabData(matlabArray,classID);      tiffOutStream->flush();    
38     makeImageFromMatlabData(matlabArray,classID);      TIFFClose(tif);    
42     makeImageFromMatlabData(matlabArray,classID);      else    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgIOException(_cimg_instance    
40     makeImageFromMatlabData(matlabArray,classID);      "save_tiff(): Failed to stream for writing.",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      return *this;    
43     makeImageFromMatlabData(matlabArray,classID);     CImg<T>& load_tiff(std::istream* tiffInStream,    
60     makeImageFromMatlabData(matlabArray,classID);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     makeImageFromMatlabData(matlabArray,classID);      const unsigned int step_frame=1)    
43     makeImageFromMatlabData(matlabArray,classID);      const unsigned int    
48     makeImageFromMatlabData(matlabArray,classID);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
39     makeImageFromMatlabData(matlabArray,classID);      nstep_frame = step_frame?step_frame:1;    
58     makeImageFromMatlabData(matlabArray,classID);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46     makeImageFromMatlabData(matlabArray,classID);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
42     makeImageFromMatlabData(matlabArray,classID);      if (tif)    
38     makeImageFromMatlabData(matlabArray,classID);      unsigned int nb_images = 0;    
44     makeImageFromMatlabData(matlabArray,classID);      do     
40     makeImageFromMatlabData(matlabArray,classID);      ++nb_images;    
37     makeImageFromMatlabData(matlabArray,classID);       while (TIFFReadDirectory(tif));    
62     makeImageFromMatlabData(matlabArray,classID);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     makeImageFromMatlabData(matlabArray,classID);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     makeImageFromMatlabData(matlabArray,classID);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
37     makeImageFromMatlabData(matlabArray,classID);      if (nfirst_frame>=nb_images)    
39     makeImageFromMatlabData(matlabArray,classID);      return assign();    
37     makeImageFromMatlabData(matlabArray,classID);      if (nlast_frame>=nb_images)    
38     makeImageFromMatlabData(matlabArray,classID);      nlast_frame = nb_images-1;    
36     makeImageFromMatlabData(matlabArray,classID);      TIFFSetDirectory(tif,0);    
39     makeImageFromMatlabData(matlabArray,classID);      CImg<T> frame;    
57     makeImageFromMatlabData(matlabArray,classID);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
36     makeImageFromMatlabData(matlabArray,classID);      frame._load_tiff(tif,l);    
92     makeImageFromMatlabData(matlabArray,classID);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     makeImageFromMatlabData(matlabArray,classID);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     makeImageFromMatlabData(matlabArray,classID);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
40     makeImageFromMatlabData(matlabArray,classID);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
38     makeImageFromMatlabData(matlabArray,classID);      TIFFClose(tif);    
42     makeImageFromMatlabData(matlabArray,classID);      else    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgIOException(_cimg_instance    
43     makeImageFromMatlabData(matlabArray,classID);      "load_tiff(): Failed to read data from stream",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      return *this;    
46     makeImageFromMatlabData(matlabArray,classID);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     makeImageFromMatlabData(matlabArray,classID);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     makeImageFromMatlabData(matlabArray,classID);      const unsigned int step_frame=1)    
60     makeImageFromMatlabData(matlabArray,classID);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
45     makeImageFromMatlabData(matlabArray,classID);     #endif    
46     makeImageFromMatlabData(matlabArray,classID);         


70 / 129

41    CImg & operator=(const mxArray *matlabArray)      #ifndef cimg_use_tiff    
38    CImg & operator=(const mxArray *matlabArray)      error cimg_use_tiff not defined    
43    CImg & operator=(const mxArray *matlabArray)      #endif    
40    CImg & operator=(const mxArray *matlabArray)      #ifndef cimg_plugin_tiff_stream    
40    CImg & operator=(const mxArray *matlabArray)      #define cimg_plugin_tiff_stream    
42    CImg & operator=(const mxArray *matlabArray)      #include <ios>    
77    CImg & operator=(const mxArray *matlabArray)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
38    CImg & operator=(const mxArray *matlabArray)       if (!tiffOutStream->good())    
41    CImg & operator=(const mxArray *matlabArray)       throw CImgArgumentException(_cimg_instance    
38    CImg & operator=(const mxArray *matlabArray)       "save_tiff(): tiffstream is not good!",    
39    CImg & operator=(const mxArray *matlabArray)       cimg_instance);    
39    CImg & operator=(const mxArray *matlabArray)       if (is_empty())    
41    CImg & operator=(const mxArray *matlabArray)       throw CImgArgumentException(_cimg_instance    
38    CImg & operator=(const mxArray *matlabArray)       "Not allowed to write empty images to stream",    
40    CImg & operator=(const mxArray *matlabArray)       cimg_instance    
43    CImg & operator=(const mxArray *matlabArray)       );    
44    CImg & operator=(const mxArray *matlabArray)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
41    CImg & operator=(const mxArray *matlabArray)       if (tif)    
59    CImg & operator=(const mxArray *matlabArray)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
38    CImg & operator=(const mxArray *matlabArray)       tiffOutStream->flush();    
40    CImg & operator=(const mxArray *matlabArray)       TIFFClose(tif);    
42    CImg & operator=(const mxArray *matlabArray)       else    
40    CImg & operator=(const mxArray *matlabArray)       throw CImgIOException(_cimg_instance    
42    CImg & operator=(const mxArray *matlabArray)       "save_tiff(): Failed to stream for writing.",    
39    CImg & operator=(const mxArray *matlabArray)       cimg_instance);    
37    CImg & operator=(const mxArray *matlabArray)       return *this;    
35    CImg & operator=(const mxArray *matlabArray)      CImg<T>& load_tiff(std::istream* tiffInStream,    
52    CImg & operator=(const mxArray *matlabArray)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38    CImg & operator=(const mxArray *matlabArray)       const unsigned int step_frame=1)    
37    CImg & operator=(const mxArray *matlabArray)       const unsigned int    
48    CImg & operator=(const mxArray *matlabArray)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
37    CImg & operator=(const mxArray *matlabArray)       nstep_frame = step_frame?step_frame:1;    
57    CImg & operator=(const mxArray *matlabArray)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43    CImg & operator=(const mxArray *matlabArray)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
41    CImg & operator=(const mxArray *matlabArray)       if (tif)    
39    CImg & operator=(const mxArray *matlabArray)       unsigned int nb_images = 0;    
42    CImg & operator=(const mxArray *matlabArray)       do     
41    CImg & operator=(const mxArray *matlabArray)       ++nb_images;    
39    CImg & operator=(const mxArray *matlabArray)        while (TIFFReadDirectory(tif));    
63    CImg & operator=(const mxArray *matlabArray)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95    CImg & operator=(const mxArray *matlabArray)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41    CImg & operator=(const mxArray *matlabArray)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
37    CImg & operator=(const mxArray *matlabArray)       if (nfirst_frame>=nb_images)    
37    CImg & operator=(const mxArray *matlabArray)       return assign();    
37    CImg & operator=(const mxArray *matlabArray)       if (nlast_frame>=nb_images)    
39    CImg & operator=(const mxArray *matlabArray)       nlast_frame = nb_images-1;    
37    CImg & operator=(const mxArray *matlabArray)       TIFFSetDirectory(tif,0);    
38    CImg & operator=(const mxArray *matlabArray)       CImg<T> frame;    
55    CImg & operator=(const mxArray *matlabArray)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
39    CImg & operator=(const mxArray *matlabArray)       frame._load_tiff(tif,l);    
96    CImg & operator=(const mxArray *matlabArray)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    CImg & operator=(const mxArray *matlabArray)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101    CImg & operator=(const mxArray *matlabArray)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43    CImg & operator=(const mxArray *matlabArray)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
40    CImg & operator=(const mxArray *matlabArray)       TIFFClose(tif);    
42    CImg & operator=(const mxArray *matlabArray)       else    
40    CImg & operator=(const mxArray *matlabArray)       throw CImgIOException(_cimg_instance    
41    CImg & operator=(const mxArray *matlabArray)       "load_tiff(): Failed to read data from stream",    
39    CImg & operator=(const mxArray *matlabArray)       cimg_instance);    
37    CImg & operator=(const mxArray *matlabArray)       return *this;    
44    CImg & operator=(const mxArray *matlabArray)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
52    CImg & operator=(const mxArray *matlabArray)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38    CImg & operator=(const mxArray *matlabArray)       const unsigned int step_frame=1)    
57    CImg & operator=(const mxArray *matlabArray)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
43    CImg & operator=(const mxArray *matlabArray)      #endif    
45    CImg & operator=(const mxArray *matlabArray)          


71 / 129

18     int     #ifndef cimg_use_tiff    
27     int     error cimg_use_tiff not defined    
5     int     #endif    
27     int     #ifndef cimg_plugin_tiff_stream    
27     int     #define cimg_plugin_tiff_stream    
12     int     #include <ios>    
95     int     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     int      if (!tiffOutStream->good())    
39     int      throw CImgArgumentException(_cimg_instance    
36     int      "save_tiff(): tiffstream is not good!",    
12     int      cimg_instance);    
13     int      if (is_empty())    
39     int      throw CImgArgumentException(_cimg_instance    
44     int      "Not allowed to write empty images to stream",    
10     int      cimg_instance    
3     int      );    


72 / 129

45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #ifndef cimg_use_tiff    
44     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     error cimg_use_tiff not defined    
49     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #endif    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #ifndef cimg_plugin_tiff_stream    
42     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #define cimg_plugin_tiff_stream    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #include <ios>    
82     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (!tiffOutStream->good())    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      throw CImgArgumentException(_cimg_instance    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      "save_tiff(): tiffstream is not good!",    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg_instance);    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (is_empty())    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      throw CImgArgumentException(_cimg_instance    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      "Not allowed to write empty images to stream",    
44     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg_instance    
50     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      );    
46     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (tif)    
57     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      tiffOutStream->flush();    
47     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      TIFFClose(tif);    
49     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      else    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      throw CImgIOException(_cimg_instance    
46     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      "save_tiff(): Failed to stream for writing.",    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg_instance);    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      return *this;    
44     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     CImg<T>& load_tiff(std::istream* tiffInStream,    
51     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      const unsigned int step_frame=1)    
44     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      const unsigned int    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      nstep_frame = step_frame?step_frame:1;    
55     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (tif)    
42     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      unsigned int nb_images = 0;    
49     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      do     
46     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      ++nb_images;    
40     nbdims = (int)mxGetNumberOfDimensions(matlabArray),       while (TIFFReadDirectory(tif));    
62     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
40     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (nfirst_frame>=nb_images)    
42     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      return assign();    
40     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (nlast_frame>=nb_images)    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      nlast_frame = nb_images-1;    
42     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      TIFFSetDirectory(tif,0);    
47     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      CImg<T> frame;    
54     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      frame._load_tiff(tif,l);    
93     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
97     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
47     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      TIFFClose(tif);    
49     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      else    
41     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      throw CImgIOException(_cimg_instance    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      "load_tiff(): Failed to read data from stream",    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      cimg_instance);    
45     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      return *this;    
48     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
51     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
43     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      const unsigned int step_frame=1)    
59     nbdims = (int)mxGetNumberOfDimensions(matlabArray),      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
49     nbdims = (int)mxGetNumberOfDimensions(matlabArray),     #endif    
52     nbdims = (int)mxGetNumberOfDimensions(matlabArray),         


73 / 129

33     classID = mxGetClassID(matlabArray);     #ifndef cimg_use_tiff    
34     classID = mxGetClassID(matlabArray);     error cimg_use_tiff not defined    
36     classID = mxGetClassID(matlabArray);     #endif    
32     classID = mxGetClassID(matlabArray);     #ifndef cimg_plugin_tiff_stream    
32     classID = mxGetClassID(matlabArray);     #define cimg_plugin_tiff_stream    
35     classID = mxGetClassID(matlabArray);     #include <ios>    
86     classID = mxGetClassID(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
32     classID = mxGetClassID(matlabArray);      if (!tiffOutStream->good())    
37     classID = mxGetClassID(matlabArray);      throw CImgArgumentException(_cimg_instance    
35     classID = mxGetClassID(matlabArray);      "save_tiff(): tiffstream is not good!",    
29     classID = mxGetClassID(matlabArray);      cimg_instance);    
31     classID = mxGetClassID(matlabArray);      if (is_empty())    
37     classID = mxGetClassID(matlabArray);      throw CImgArgumentException(_cimg_instance    
38     classID = mxGetClassID(matlabArray);      "Not allowed to write empty images to stream",    
31     classID = mxGetClassID(matlabArray);      cimg_instance    
34     classID = mxGetClassID(matlabArray);      );    
41     classID = mxGetClassID(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
32     classID = mxGetClassID(matlabArray);      if (tif)    
57     classID = mxGetClassID(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
31     classID = mxGetClassID(matlabArray);      tiffOutStream->flush();    
28     classID = mxGetClassID(matlabArray);      TIFFClose(tif);    
33     classID = mxGetClassID(matlabArray);      else    
33     classID = mxGetClassID(matlabArray);      throw CImgIOException(_cimg_instance    
39     classID = mxGetClassID(matlabArray);      "save_tiff(): Failed to stream for writing.",    
29     classID = mxGetClassID(matlabArray);      cimg_instance);    
32     classID = mxGetClassID(matlabArray);      return *this;    
40     classID = mxGetClassID(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     classID = mxGetClassID(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     classID = mxGetClassID(matlabArray);      const unsigned int step_frame=1)    
32     classID = mxGetClassID(matlabArray);      const unsigned int    
47     classID = mxGetClassID(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34     classID = mxGetClassID(matlabArray);      nstep_frame = step_frame?step_frame:1;    
55     classID = mxGetClassID(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
40     classID = mxGetClassID(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
32     classID = mxGetClassID(matlabArray);      if (tif)    
30     classID = mxGetClassID(matlabArray);      unsigned int nb_images = 0;    
35     classID = mxGetClassID(matlabArray);      do     
32     classID = mxGetClassID(matlabArray);      ++nb_images;    
31     classID = mxGetClassID(matlabArray);       while (TIFFReadDirectory(tif));    
62     classID = mxGetClassID(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     classID = mxGetClassID(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
37     classID = mxGetClassID(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
32     classID = mxGetClassID(matlabArray);      if (nfirst_frame>=nb_images)    
30     classID = mxGetClassID(matlabArray);      return assign();    
31     classID = mxGetClassID(matlabArray);      if (nlast_frame>=nb_images)    
28     classID = mxGetClassID(matlabArray);      nlast_frame = nb_images-1;    
30     classID = mxGetClassID(matlabArray);      TIFFSetDirectory(tif,0);    
30     classID = mxGetClassID(matlabArray);      CImg<T> frame;    
55     classID = mxGetClassID(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
29     classID = mxGetClassID(matlabArray);      frame._load_tiff(tif,l);    
95     classID = mxGetClassID(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     classID = mxGetClassID(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
103     classID = mxGetClassID(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     classID = mxGetClassID(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
28     classID = mxGetClassID(matlabArray);      TIFFClose(tif);    
33     classID = mxGetClassID(matlabArray);      else    
33     classID = mxGetClassID(matlabArray);      throw CImgIOException(_cimg_instance    
38     classID = mxGetClassID(matlabArray);      "load_tiff(): Failed to read data from stream",    
29     classID = mxGetClassID(matlabArray);      cimg_instance);    
32     classID = mxGetClassID(matlabArray);      return *this;    
46     classID = mxGetClassID(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     classID = mxGetClassID(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     classID = mxGetClassID(matlabArray);      const unsigned int step_frame=1)    
62     classID = mxGetClassID(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
36     classID = mxGetClassID(matlabArray);     #endif    
37     classID = mxGetClassID(matlabArray);         


74 / 129

39     if (nbdims>4 || !isNumericalClassID(classID))      #ifndef cimg_use_tiff    
43     if (nbdims>4 || !isNumericalClassID(classID))      error cimg_use_tiff not defined    
44     if (nbdims>4 || !isNumericalClassID(classID))      #endif    
38     if (nbdims>4 || !isNumericalClassID(classID))      #ifndef cimg_plugin_tiff_stream    
41     if (nbdims>4 || !isNumericalClassID(classID))      #define cimg_plugin_tiff_stream    
42     if (nbdims>4 || !isNumericalClassID(classID))      #include <ios>    
82     if (nbdims>4 || !isNumericalClassID(classID))      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
36     if (nbdims>4 || !isNumericalClassID(classID))       if (!tiffOutStream->good())    
43     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
40     if (nbdims>4 || !isNumericalClassID(classID))       "save_tiff(): tiffstream is not good!",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
36     if (nbdims>4 || !isNumericalClassID(classID))       if (is_empty())    
43     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
42     if (nbdims>4 || !isNumericalClassID(classID))       "Not allowed to write empty images to stream",    
41     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance    
45     if (nbdims>4 || !isNumericalClassID(classID))       );    
48     if (nbdims>4 || !isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
40     if (nbdims>4 || !isNumericalClassID(classID))       if (tif)    
56     if (nbdims>4 || !isNumericalClassID(classID))       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
40     if (nbdims>4 || !isNumericalClassID(classID))       tiffOutStream->flush();    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFClose(tif);    
43     if (nbdims>4 || !isNumericalClassID(classID))       else    
42     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
44     if (nbdims>4 || !isNumericalClassID(classID))       "save_tiff(): Failed to stream for writing.",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
43     if (nbdims>4 || !isNumericalClassID(classID))       return *this;    
45     if (nbdims>4 || !isNumericalClassID(classID))      CImg<T>& load_tiff(std::istream* tiffInStream,    
55     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int step_frame=1)    
41     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int    
50     if (nbdims>4 || !isNumericalClassID(classID))       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
40     if (nbdims>4 || !isNumericalClassID(classID))       nstep_frame = step_frame?step_frame:1;    
59     if (nbdims>4 || !isNumericalClassID(classID))       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     if (nbdims>4 || !isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
40     if (nbdims>4 || !isNumericalClassID(classID))       if (tif)    
39     if (nbdims>4 || !isNumericalClassID(classID))       unsigned int nb_images = 0;    
44     if (nbdims>4 || !isNumericalClassID(classID))       do     
40     if (nbdims>4 || !isNumericalClassID(classID))       ++nb_images;    
39     if (nbdims>4 || !isNumericalClassID(classID))        while (TIFFReadDirectory(tif));    
57     if (nbdims>4 || !isNumericalClassID(classID))       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     if (nbdims>4 || !isNumericalClassID(classID))       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     if (nbdims>4 || !isNumericalClassID(classID))       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
34     if (nbdims>4 || !isNumericalClassID(classID))       if (nfirst_frame>=nb_images)    
40     if (nbdims>4 || !isNumericalClassID(classID))       return assign();    
35     if (nbdims>4 || !isNumericalClassID(classID))       if (nlast_frame>=nb_images)    
41     if (nbdims>4 || !isNumericalClassID(classID))       nlast_frame = nb_images-1;    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFSetDirectory(tif,0);    
42     if (nbdims>4 || !isNumericalClassID(classID))       CImg<T> frame;    
51     if (nbdims>4 || !isNumericalClassID(classID))       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
40     if (nbdims>4 || !isNumericalClassID(classID))       frame._load_tiff(tif,l);    
94     if (nbdims>4 || !isNumericalClassID(classID))       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
63     if (nbdims>4 || !isNumericalClassID(classID))       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     if (nbdims>4 || !isNumericalClassID(classID))       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     if (nbdims>4 || !isNumericalClassID(classID))       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
41     if (nbdims>4 || !isNumericalClassID(classID))       TIFFClose(tif);    
43     if (nbdims>4 || !isNumericalClassID(classID))       else    
42     if (nbdims>4 || !isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
42     if (nbdims>4 || !isNumericalClassID(classID))       "load_tiff(): Failed to read data from stream",    
40     if (nbdims>4 || !isNumericalClassID(classID))       cimg_instance);    
43     if (nbdims>4 || !isNumericalClassID(classID))       return *this;    
52     if (nbdims>4 || !isNumericalClassID(classID))      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
38     if (nbdims>4 || !isNumericalClassID(classID))       const unsigned int step_frame=1)    
63     if (nbdims>4 || !isNumericalClassID(classID))       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
44     if (nbdims>4 || !isNumericalClassID(classID))      #endif    
47     if (nbdims>4 || !isNumericalClassID(classID))          


75 / 129

25     delete [] _data; _data = 0;     #ifndef cimg_use_tiff    
28     delete [] _data; _data = 0;     error cimg_use_tiff not defined    
26     delete [] _data; _data = 0;     #endif    
28     delete [] _data; _data = 0;     #ifndef cimg_plugin_tiff_stream    
25     delete [] _data; _data = 0;     #define cimg_plugin_tiff_stream    
26     delete [] _data; _data = 0;     #include <ios>    
87     delete [] _data; _data = 0;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     delete [] _data; _data = 0;      if (!tiffOutStream->good())    
38     delete [] _data; _data = 0;      throw CImgArgumentException(_cimg_instance    
32     delete [] _data; _data = 0;      "save_tiff(): tiffstream is not good!",    
23     delete [] _data; _data = 0;      cimg_instance);    
24     delete [] _data; _data = 0;      if (is_empty())    
38     delete [] _data; _data = 0;      throw CImgArgumentException(_cimg_instance    
37     delete [] _data; _data = 0;      "Not allowed to write empty images to stream",    
24     delete [] _data; _data = 0;      cimg_instance    
26     delete [] _data; _data = 0;      );    
46     delete [] _data; _data = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
25     delete [] _data; _data = 0;      if (tif)    
60     delete [] _data; _data = 0;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     delete [] _data; _data = 0;      tiffOutStream->flush();    
25     delete [] _data; _data = 0;      TIFFClose(tif);    
24     delete [] _data; _data = 0;      else    
34     delete [] _data; _data = 0;      throw CImgIOException(_cimg_instance    
37     delete [] _data; _data = 0;      "save_tiff(): Failed to stream for writing.",    
23     delete [] _data; _data = 0;      cimg_instance);    
22     delete [] _data; _data = 0;      return *this;    
40     delete [] _data; _data = 0;     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     delete [] _data; _data = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     delete [] _data; _data = 0;      const unsigned int step_frame=1)    
23     delete [] _data; _data = 0;      const unsigned int    
51     delete [] _data; _data = 0;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     delete [] _data; _data = 0;      nstep_frame = step_frame?step_frame:1;    
60     delete [] _data; _data = 0;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     delete [] _data; _data = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
25     delete [] _data; _data = 0;      if (tif)    
20     delete [] _data; _data = 0;      unsigned int nb_images = 0;    
25     delete [] _data; _data = 0;      do     
24     delete [] _data; _data = 0;      ++nb_images;    
27     delete [] _data; _data = 0;       while (TIFFReadDirectory(tif));    
64     delete [] _data; _data = 0;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     delete [] _data; _data = 0;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     delete [] _data; _data = 0;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     delete [] _data; _data = 0;      if (nfirst_frame>=nb_images)    
22     delete [] _data; _data = 0;      return assign();    
26     delete [] _data; _data = 0;      if (nlast_frame>=nb_images)    
24     delete [] _data; _data = 0;      nlast_frame = nb_images-1;    
23     delete [] _data; _data = 0;      TIFFSetDirectory(tif,0);    
24     delete [] _data; _data = 0;      CImg<T> frame;    
56     delete [] _data; _data = 0;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     delete [] _data; _data = 0;      frame._load_tiff(tif,l);    
99     delete [] _data; _data = 0;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     delete [] _data; _data = 0;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
104     delete [] _data; _data = 0;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     delete [] _data; _data = 0;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
25     delete [] _data; _data = 0;      TIFFClose(tif);    
24     delete [] _data; _data = 0;      else    
34     delete [] _data; _data = 0;      throw CImgIOException(_cimg_instance    
36     delete [] _data; _data = 0;      "load_tiff(): Failed to read data from stream",    
23     delete [] _data; _data = 0;      cimg_instance);    
22     delete [] _data; _data = 0;      return *this;    
47     delete [] _data; _data = 0;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     delete [] _data; _data = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     delete [] _data; _data = 0;      const unsigned int step_frame=1)    
64     delete [] _data; _data = 0;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
26     delete [] _data; _data = 0;     #endif    
28     delete [] _data; _data = 0;         


76 / 129

36     _width = _height = _depth = _spectrum = 0;     #ifndef cimg_use_tiff    
37     _width = _height = _depth = _spectrum = 0;     error cimg_use_tiff not defined    
41     _width = _height = _depth = _spectrum = 0;     #endif    
35     _width = _height = _depth = _spectrum = 0;     #ifndef cimg_plugin_tiff_stream    
36     _width = _height = _depth = _spectrum = 0;     #define cimg_plugin_tiff_stream    
38     _width = _height = _depth = _spectrum = 0;     #include <ios>    
84     _width = _height = _depth = _spectrum = 0;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
38     _width = _height = _depth = _spectrum = 0;      if (!tiffOutStream->good())    
37     _width = _height = _depth = _spectrum = 0;      throw CImgArgumentException(_cimg_instance    
37     _width = _height = _depth = _spectrum = 0;      "save_tiff(): tiffstream is not good!",    
36     _width = _height = _depth = _spectrum = 0;      cimg_instance);    
35     _width = _height = _depth = _spectrum = 0;      if (is_empty())    
37     _width = _height = _depth = _spectrum = 0;      throw CImgArgumentException(_cimg_instance    
39     _width = _height = _depth = _spectrum = 0;      "Not allowed to write empty images to stream",    
37     _width = _height = _depth = _spectrum = 0;      cimg_instance    
41     _width = _height = _depth = _spectrum = 0;      );    
44     _width = _height = _depth = _spectrum = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
39     _width = _height = _depth = _spectrum = 0;      if (tif)    
55     _width = _height = _depth = _spectrum = 0;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
37     _width = _height = _depth = _spectrum = 0;      tiffOutStream->flush();    
38     _width = _height = _depth = _spectrum = 0;      TIFFClose(tif);    
39     _width = _height = _depth = _spectrum = 0;      else    
35     _width = _height = _depth = _spectrum = 0;      throw CImgIOException(_cimg_instance    
40     _width = _height = _depth = _spectrum = 0;      "save_tiff(): Failed to stream for writing.",    
36     _width = _height = _depth = _spectrum = 0;      cimg_instance);    
36     _width = _height = _depth = _spectrum = 0;      return *this;    
42     _width = _height = _depth = _spectrum = 0;     CImg<T>& load_tiff(std::istream* tiffInStream,    
53     _width = _height = _depth = _spectrum = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     _width = _height = _depth = _spectrum = 0;      const unsigned int step_frame=1)    
35     _width = _height = _depth = _spectrum = 0;      const unsigned int    
50     _width = _height = _depth = _spectrum = 0;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     _width = _height = _depth = _spectrum = 0;      nstep_frame = step_frame?step_frame:1;    
60     _width = _height = _depth = _spectrum = 0;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     _width = _height = _depth = _spectrum = 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
39     _width = _height = _depth = _spectrum = 0;      if (tif)    
31     _width = _height = _depth = _spectrum = 0;      unsigned int nb_images = 0;    
40     _width = _height = _depth = _spectrum = 0;      do     
37     _width = _height = _depth = _spectrum = 0;      ++nb_images;    
35     _width = _height = _depth = _spectrum = 0;       while (TIFFReadDirectory(tif));    
62     _width = _height = _depth = _spectrum = 0;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
92     _width = _height = _depth = _spectrum = 0;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     _width = _height = _depth = _spectrum = 0;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
35     _width = _height = _depth = _spectrum = 0;      if (nfirst_frame>=nb_images)    
37     _width = _height = _depth = _spectrum = 0;      return assign();    
36     _width = _height = _depth = _spectrum = 0;      if (nlast_frame>=nb_images)    
35     _width = _height = _depth = _spectrum = 0;      nlast_frame = nb_images-1;    
36     _width = _height = _depth = _spectrum = 0;      TIFFSetDirectory(tif,0);    
37     _width = _height = _depth = _spectrum = 0;      CImg<T> frame;    
54     _width = _height = _depth = _spectrum = 0;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
37     _width = _height = _depth = _spectrum = 0;      frame._load_tiff(tif,l);    
90     _width = _height = _depth = _spectrum = 0;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
51     _width = _height = _depth = _spectrum = 0;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
90     _width = _height = _depth = _spectrum = 0;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     _width = _height = _depth = _spectrum = 0;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
38     _width = _height = _depth = _spectrum = 0;      TIFFClose(tif);    
39     _width = _height = _depth = _spectrum = 0;      else    
35     _width = _height = _depth = _spectrum = 0;      throw CImgIOException(_cimg_instance    
40     _width = _height = _depth = _spectrum = 0;      "load_tiff(): Failed to read data from stream",    
36     _width = _height = _depth = _spectrum = 0;      cimg_instance);    
36     _width = _height = _depth = _spectrum = 0;      return *this;    
48     _width = _height = _depth = _spectrum = 0;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
53     _width = _height = _depth = _spectrum = 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     _width = _height = _depth = _spectrum = 0;      const unsigned int step_frame=1)    
64     _width = _height = _depth = _spectrum = 0;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
41     _width = _height = _depth = _spectrum = 0;     #endif    
43     _width = _height = _depth = _spectrum = 0;         


77 / 129

11    #if cimg_debug>1     #ifndef cimg_use_tiff    
23    #if cimg_debug>1     error cimg_use_tiff not defined    
14    #if cimg_debug>1     #endif    
21    #if cimg_debug>1     #ifndef cimg_plugin_tiff_stream    
22    #if cimg_debug>1     #define cimg_plugin_tiff_stream    
12    #if cimg_debug>1     #include <ios>    
91    #if cimg_debug>1     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
22    #if cimg_debug>1      if (!tiffOutStream->good())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
34    #if cimg_debug>1      "save_tiff(): tiffstream is not good!",    
13    #if cimg_debug>1      cimg_instance);    
12    #if cimg_debug>1      if (is_empty())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
42    #if cimg_debug>1      "Not allowed to write empty images to stream",    
11    #if cimg_debug>1      cimg_instance    
15    #if cimg_debug>1      );    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13    #if cimg_debug>1      if (tif)    
62    #if cimg_debug>1      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20    #if cimg_debug>1      tiffOutStream->flush();    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
40    #if cimg_debug>1      "save_tiff(): Failed to stream for writing.",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
42    #if cimg_debug>1     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
17    #if cimg_debug>1      const unsigned int    
55    #if cimg_debug>1      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34    #if cimg_debug>1      nstep_frame = step_frame?step_frame:1;    
67    #if cimg_debug>1      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13    #if cimg_debug>1      if (tif)    
24    #if cimg_debug>1      unsigned int nb_images = 0;    
14    #if cimg_debug>1      do     
14    #if cimg_debug>1      ++nb_images;    
29    #if cimg_debug>1       while (TIFFReadDirectory(tif));    
67    #if cimg_debug>1      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103    #if cimg_debug>1      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42    #if cimg_debug>1      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
21    #if cimg_debug>1      if (nfirst_frame>=nb_images)    
17    #if cimg_debug>1      return assign();    
21    #if cimg_debug>1      if (nlast_frame>=nb_images)    
23    #if cimg_debug>1      nlast_frame = nb_images-1;    
23    #if cimg_debug>1      TIFFSetDirectory(tif,0);    
15    #if cimg_debug>1      CImg<T> frame;    
63    #if cimg_debug>1      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    #if cimg_debug>1      frame._load_tiff(tif,l);    
103    #if cimg_debug>1      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    #if cimg_debug>1      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107    #if cimg_debug>1      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    #if cimg_debug>1      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
43    #if cimg_debug>1      "load_tiff(): Failed to read data from stream",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
49    #if cimg_debug>1     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
70    #if cimg_debug>1      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
14    #if cimg_debug>1     #endif    
16    #if cimg_debug>1         


78 / 129

82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #ifndef cimg_use_tiff    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     error cimg_use_tiff not defined    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #endif    
80     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #ifndef cimg_plugin_tiff_stream    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #define cimg_plugin_tiff_stream    
85     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #include <ios>    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (!tiffOutStream->good())    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgArgumentException(_cimg_instance    
76     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "save_tiff(): tiffstream is not good!",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (is_empty())    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgArgumentException(_cimg_instance    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "Not allowed to write empty images to stream",    
80     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance    
89     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      );    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
86     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (tif)    
72     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      tiffOutStream->flush();    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFClose(tif);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      else    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgIOException(_cimg_instance    
71     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "save_tiff(): Failed to stream for writing.",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return *this;    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     CImg<T>& load_tiff(std::istream* tiffInStream,    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int step_frame=1)    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nstep_frame = step_frame?step_frame:1;    
76     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
86     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (tif)    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      unsigned int nb_images = 0;    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      do     
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      ++nb_images;    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");       while (TIFFReadDirectory(tif));    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
70     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nfirst_frame>=nb_images)    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return assign();    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (nlast_frame>=nb_images)    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      nlast_frame = nb_images-1;    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFSetDirectory(tif,0);    
82     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      CImg<T> frame;    
75     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      frame._load_tiff(tif,l);    
94     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
97     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
84     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      TIFFClose(tif);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      else    
79     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      throw CImgIOException(_cimg_instance    
72     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      "load_tiff(): Failed to read data from stream",    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      cimg_instance);    
81     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return *this;    
78     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
73     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
74     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      const unsigned int step_frame=1)    
77     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
88     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");     #endif    
92     cimg::warn("MATLAB array is more than 4D or/and not numerical, returning an empty image.");         


79 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


80 / 129

18      else      #ifndef cimg_use_tiff    
27      else      error cimg_use_tiff not defined    
6      else      #endif    
27      else      #ifndef cimg_plugin_tiff_stream    
27      else      #define cimg_plugin_tiff_stream    
11      else      #include <ios>    
93      else      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25      else       if (!tiffOutStream->good())    
39      else       throw CImgArgumentException(_cimg_instance    
35      else       "save_tiff(): tiffstream is not good!",    
13      else       cimg_instance);    
12      else       if (is_empty())    
39      else       throw CImgArgumentException(_cimg_instance    
42      else       "Not allowed to write empty images to stream",    
12      else       cimg_instance    
6      else       );    
49      else       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
7      else       if (tif)    
62      else       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20      else       tiffOutStream->flush();    
12      else       TIFFClose(tif);    
2      else       else    


81 / 129

44     const mwSize *dims = mxGetDimensions(matlabArray);     #ifndef cimg_use_tiff    
43     const mwSize *dims = mxGetDimensions(matlabArray);     error cimg_use_tiff not defined    
48     const mwSize *dims = mxGetDimensions(matlabArray);     #endif    
42     const mwSize *dims = mxGetDimensions(matlabArray);     #ifndef cimg_plugin_tiff_stream    
41     const mwSize *dims = mxGetDimensions(matlabArray);     #define cimg_plugin_tiff_stream    
45     const mwSize *dims = mxGetDimensions(matlabArray);     #include <ios>    
77     const mwSize *dims = mxGetDimensions(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
43     const mwSize *dims = mxGetDimensions(matlabArray);      if (!tiffOutStream->good())    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
43     const mwSize *dims = mxGetDimensions(matlabArray);      "save_tiff(): tiffstream is not good!",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (is_empty())    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgArgumentException(_cimg_instance    
40     const mwSize *dims = mxGetDimensions(matlabArray);      "Not allowed to write empty images to stream",    
42     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance    
48     const mwSize *dims = mxGetDimensions(matlabArray);      );    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      if (tif)    
55     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      tiffOutStream->flush();    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFClose(tif);    
47     const mwSize *dims = mxGetDimensions(matlabArray);      else    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
45     const mwSize *dims = mxGetDimensions(matlabArray);      "save_tiff(): Failed to stream for writing.",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      return *this;    
46     const mwSize *dims = mxGetDimensions(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
47     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int step_frame=1)    
38     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int    
46     const mwSize *dims = mxGetDimensions(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
39     const mwSize *dims = mxGetDimensions(matlabArray);      nstep_frame = step_frame?step_frame:1;    
54     const mwSize *dims = mxGetDimensions(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     const mwSize *dims = mxGetDimensions(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      if (tif)    
40     const mwSize *dims = mxGetDimensions(matlabArray);      unsigned int nb_images = 0;    
48     const mwSize *dims = mxGetDimensions(matlabArray);      do     
44     const mwSize *dims = mxGetDimensions(matlabArray);      ++nb_images;    
37     const mwSize *dims = mxGetDimensions(matlabArray);       while (TIFFReadDirectory(tif));    
59     const mwSize *dims = mxGetDimensions(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     const mwSize *dims = mxGetDimensions(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42     const mwSize *dims = mxGetDimensions(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (nfirst_frame>=nb_images)    
41     const mwSize *dims = mxGetDimensions(matlabArray);      return assign();    
42     const mwSize *dims = mxGetDimensions(matlabArray);      if (nlast_frame>=nb_images)    
40     const mwSize *dims = mxGetDimensions(matlabArray);      nlast_frame = nb_images-1;    
39     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFSetDirectory(tif,0);    
45     const mwSize *dims = mxGetDimensions(matlabArray);      CImg<T> frame;    
52     const mwSize *dims = mxGetDimensions(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
42     const mwSize *dims = mxGetDimensions(matlabArray);      frame._load_tiff(tif,l);    
92     const mwSize *dims = mxGetDimensions(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
64     const mwSize *dims = mxGetDimensions(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     const mwSize *dims = mxGetDimensions(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
44     const mwSize *dims = mxGetDimensions(matlabArray);      TIFFClose(tif);    
47     const mwSize *dims = mxGetDimensions(matlabArray);      else    
41     const mwSize *dims = mxGetDimensions(matlabArray);      throw CImgIOException(_cimg_instance    
44     const mwSize *dims = mxGetDimensions(matlabArray);      "load_tiff(): Failed to read data from stream",    
40     const mwSize *dims = mxGetDimensions(matlabArray);      cimg_instance);    
43     const mwSize *dims = mxGetDimensions(matlabArray);      return *this;    
50     const mwSize *dims = mxGetDimensions(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
47     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
37     const mwSize *dims = mxGetDimensions(matlabArray);      const unsigned int step_frame=1)    
60     const mwSize *dims = mxGetDimensions(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
48     const mwSize *dims = mxGetDimensions(matlabArray);     #endif    
51     const mwSize *dims = mxGetDimensions(matlabArray);         


82 / 129

21     _depth = _spectrum = 1;     #ifndef cimg_use_tiff    
26     _depth = _spectrum = 1;     error cimg_use_tiff not defined    
23     _depth = _spectrum = 1;     #endif    
27     _depth = _spectrum = 1;     #ifndef cimg_plugin_tiff_stream    
27     _depth = _spectrum = 1;     #define cimg_plugin_tiff_stream    
23     _depth = _spectrum = 1;     #include <ios>    
86     _depth = _spectrum = 1;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     _depth = _spectrum = 1;      if (!tiffOutStream->good())    
38     _depth = _spectrum = 1;      throw CImgArgumentException(_cimg_instance    
31     _depth = _spectrum = 1;      "save_tiff(): tiffstream is not good!",    
20     _depth = _spectrum = 1;      cimg_instance);    
20     _depth = _spectrum = 1;      if (is_empty())    
38     _depth = _spectrum = 1;      throw CImgArgumentException(_cimg_instance    
38     _depth = _spectrum = 1;      "Not allowed to write empty images to stream",    
21     _depth = _spectrum = 1;      cimg_instance    
22     _depth = _spectrum = 1;      );    
44     _depth = _spectrum = 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
21     _depth = _spectrum = 1;      if (tif)    
57     _depth = _spectrum = 1;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22     _depth = _spectrum = 1;      tiffOutStream->flush();    
19     _depth = _spectrum = 1;      TIFFClose(tif);    
20     _depth = _spectrum = 1;      else    
32     _depth = _spectrum = 1;      throw CImgIOException(_cimg_instance    
36     _depth = _spectrum = 1;      "save_tiff(): Failed to stream for writing.",    
20     _depth = _spectrum = 1;      cimg_instance);    
18     _depth = _spectrum = 1;      return *this;    
39     _depth = _spectrum = 1;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     _depth = _spectrum = 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _depth = _spectrum = 1;      const unsigned int step_frame=1)    
19     _depth = _spectrum = 1;      const unsigned int    
51     _depth = _spectrum = 1;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
27     _depth = _spectrum = 1;      nstep_frame = step_frame?step_frame:1;    
61     _depth = _spectrum = 1;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     _depth = _spectrum = 1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
21     _depth = _spectrum = 1;      if (tif)    
21     _depth = _spectrum = 1;      unsigned int nb_images = 0;    
21     _depth = _spectrum = 1;      do     
20     _depth = _spectrum = 1;      ++nb_images;    
26     _depth = _spectrum = 1;       while (TIFFReadDirectory(tif));    
66     _depth = _spectrum = 1;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     _depth = _spectrum = 1;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     _depth = _spectrum = 1;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     _depth = _spectrum = 1;      if (nfirst_frame>=nb_images)    
18     _depth = _spectrum = 1;      return assign();    
24     _depth = _spectrum = 1;      if (nlast_frame>=nb_images)    
22     _depth = _spectrum = 1;      nlast_frame = nb_images-1;    
21     _depth = _spectrum = 1;      TIFFSetDirectory(tif,0);    
19     _depth = _spectrum = 1;      CImg<T> frame;    
56     _depth = _spectrum = 1;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     _depth = _spectrum = 1;      frame._load_tiff(tif,l);    
102     _depth = _spectrum = 1;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
62     _depth = _spectrum = 1;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _depth = _spectrum = 1;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     _depth = _spectrum = 1;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
19     _depth = _spectrum = 1;      TIFFClose(tif);    
20     _depth = _spectrum = 1;      else    
32     _depth = _spectrum = 1;      throw CImgIOException(_cimg_instance    
39     _depth = _spectrum = 1;      "load_tiff(): Failed to read data from stream",    
20     _depth = _spectrum = 1;      cimg_instance);    
18     _depth = _spectrum = 1;      return *this;    
48     _depth = _spectrum = 1;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     _depth = _spectrum = 1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _depth = _spectrum = 1;      const unsigned int step_frame=1)    
67     _depth = _spectrum = 1;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
23     _depth = _spectrum = 1;     #endif    
24     _depth = _spectrum = 1;         


83 / 129

24     _width = (unsigned)dims[1];     #ifndef cimg_use_tiff    
28     _width = (unsigned)dims[1];     error cimg_use_tiff not defined    
25     _width = (unsigned)dims[1];     #endif    
26     _width = (unsigned)dims[1];     #ifndef cimg_plugin_tiff_stream    
27     _width = (unsigned)dims[1];     #define cimg_plugin_tiff_stream    
23     _width = (unsigned)dims[1];     #include <ios>    
82     _width = (unsigned)dims[1];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     _width = (unsigned)dims[1];      if (!tiffOutStream->good())    
35     _width = (unsigned)dims[1];      throw CImgArgumentException(_cimg_instance    
34     _width = (unsigned)dims[1];      "save_tiff(): tiffstream is not good!",    
21     _width = (unsigned)dims[1];      cimg_instance);    
22     _width = (unsigned)dims[1];      if (is_empty())    
35     _width = (unsigned)dims[1];      throw CImgArgumentException(_cimg_instance    
38     _width = (unsigned)dims[1];      "Not allowed to write empty images to stream",    
23     _width = (unsigned)dims[1];      cimg_instance    
25     _width = (unsigned)dims[1];      );    
45     _width = (unsigned)dims[1];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
22     _width = (unsigned)dims[1];      if (tif)    
56     _width = (unsigned)dims[1];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
24     _width = (unsigned)dims[1];      tiffOutStream->flush();    
23     _width = (unsigned)dims[1];      TIFFClose(tif);    
25     _width = (unsigned)dims[1];      else    
31     _width = (unsigned)dims[1];      throw CImgIOException(_cimg_instance    
39     _width = (unsigned)dims[1];      "save_tiff(): Failed to stream for writing.",    
21     _width = (unsigned)dims[1];      cimg_instance);    
21     _width = (unsigned)dims[1];      return *this;    
40     _width = (unsigned)dims[1];     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     _width = (unsigned)dims[1];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _width = (unsigned)dims[1];      const unsigned int step_frame=1)    
16     _width = (unsigned)dims[1];      const unsigned int    
51     _width = (unsigned)dims[1];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     _width = (unsigned)dims[1];      nstep_frame = step_frame?step_frame:1;    
62     _width = (unsigned)dims[1];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     _width = (unsigned)dims[1];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
22     _width = (unsigned)dims[1];      if (tif)    
24     _width = (unsigned)dims[1];      unsigned int nb_images = 0;    
25     _width = (unsigned)dims[1];      do     
23     _width = (unsigned)dims[1];      ++nb_images;    
28     _width = (unsigned)dims[1];       while (TIFFReadDirectory(tif));    
66     _width = (unsigned)dims[1];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     _width = (unsigned)dims[1];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _width = (unsigned)dims[1];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     _width = (unsigned)dims[1];      if (nfirst_frame>=nb_images)    
19     _width = (unsigned)dims[1];      return assign();    
25     _width = (unsigned)dims[1];      if (nlast_frame>=nb_images)    
23     _width = (unsigned)dims[1];      nlast_frame = nb_images-1;    
25     _width = (unsigned)dims[1];      TIFFSetDirectory(tif,0);    
24     _width = (unsigned)dims[1];      CImg<T> frame;    
58     _width = (unsigned)dims[1];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
24     _width = (unsigned)dims[1];      frame._load_tiff(tif,l);    
99     _width = (unsigned)dims[1];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     _width = (unsigned)dims[1];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _width = (unsigned)dims[1];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     _width = (unsigned)dims[1];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
23     _width = (unsigned)dims[1];      TIFFClose(tif);    
25     _width = (unsigned)dims[1];      else    
31     _width = (unsigned)dims[1];      throw CImgIOException(_cimg_instance    
39     _width = (unsigned)dims[1];      "load_tiff(): Failed to read data from stream",    
21     _width = (unsigned)dims[1];      cimg_instance);    
21     _width = (unsigned)dims[1];      return *this;    
49     _width = (unsigned)dims[1];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     _width = (unsigned)dims[1];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     _width = (unsigned)dims[1];      const unsigned int step_frame=1)    
66     _width = (unsigned)dims[1];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
25     _width = (unsigned)dims[1];     #endif    
28     _width = (unsigned)dims[1];         


84 / 129

25     _height = (unsigned)dims[0];     #ifndef cimg_use_tiff    
29     _height = (unsigned)dims[0];     error cimg_use_tiff not defined    
25     _height = (unsigned)dims[0];     #endif    
28     _height = (unsigned)dims[0];     #ifndef cimg_plugin_tiff_stream    
27     _height = (unsigned)dims[0];     #define cimg_plugin_tiff_stream    
24     _height = (unsigned)dims[0];     #include <ios>    
82     _height = (unsigned)dims[0];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
26     _height = (unsigned)dims[0];      if (!tiffOutStream->good())    
35     _height = (unsigned)dims[0];      throw CImgArgumentException(_cimg_instance    
34     _height = (unsigned)dims[0];      "save_tiff(): tiffstream is not good!",    
22     _height = (unsigned)dims[0];      cimg_instance);    
23     _height = (unsigned)dims[0];      if (is_empty())    
35     _height = (unsigned)dims[0];      throw CImgArgumentException(_cimg_instance    
40     _height = (unsigned)dims[0];      "Not allowed to write empty images to stream",    
24     _height = (unsigned)dims[0];      cimg_instance    
26     _height = (unsigned)dims[0];      );    
45     _height = (unsigned)dims[0];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23     _height = (unsigned)dims[0];      if (tif)    
57     _height = (unsigned)dims[0];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     _height = (unsigned)dims[0];      tiffOutStream->flush();    
24     _height = (unsigned)dims[0];      TIFFClose(tif);    
25     _height = (unsigned)dims[0];      else    
31     _height = (unsigned)dims[0];      throw CImgIOException(_cimg_instance    
39     _height = (unsigned)dims[0];      "save_tiff(): Failed to stream for writing.",    
22     _height = (unsigned)dims[0];      cimg_instance);    
21     _height = (unsigned)dims[0];      return *this;    
41     _height = (unsigned)dims[0];     CImg<T>& load_tiff(std::istream* tiffInStream,    
52     _height = (unsigned)dims[0];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     _height = (unsigned)dims[0];      const unsigned int step_frame=1)    
17     _height = (unsigned)dims[0];      const unsigned int    
52     _height = (unsigned)dims[0];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
32     _height = (unsigned)dims[0];      nstep_frame = step_frame?step_frame:1;    
62     _height = (unsigned)dims[0];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     _height = (unsigned)dims[0];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23     _height = (unsigned)dims[0];      if (tif)    
23     _height = (unsigned)dims[0];      unsigned int nb_images = 0;    
27     _height = (unsigned)dims[0];      do     
24     _height = (unsigned)dims[0];      ++nb_images;    
28     _height = (unsigned)dims[0];       while (TIFFReadDirectory(tif));    
64     _height = (unsigned)dims[0];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
98     _height = (unsigned)dims[0];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _height = (unsigned)dims[0];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     _height = (unsigned)dims[0];      if (nfirst_frame>=nb_images)    
20     _height = (unsigned)dims[0];      return assign();    
26     _height = (unsigned)dims[0];      if (nlast_frame>=nb_images)    
25     _height = (unsigned)dims[0];      nlast_frame = nb_images-1;    
24     _height = (unsigned)dims[0];      TIFFSetDirectory(tif,0);    
24     _height = (unsigned)dims[0];      CImg<T> frame;    
58     _height = (unsigned)dims[0];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
25     _height = (unsigned)dims[0];      frame._load_tiff(tif,l);    
98     _height = (unsigned)dims[0];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     _height = (unsigned)dims[0];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     _height = (unsigned)dims[0];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     _height = (unsigned)dims[0];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24     _height = (unsigned)dims[0];      TIFFClose(tif);    
25     _height = (unsigned)dims[0];      else    
31     _height = (unsigned)dims[0];      throw CImgIOException(_cimg_instance    
39     _height = (unsigned)dims[0];      "load_tiff(): Failed to read data from stream",    
22     _height = (unsigned)dims[0];      cimg_instance);    
21     _height = (unsigned)dims[0];      return *this;    
49     _height = (unsigned)dims[0];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
52     _height = (unsigned)dims[0];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     _height = (unsigned)dims[0];      const unsigned int step_frame=1)    
66     _height = (unsigned)dims[0];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
25     _height = (unsigned)dims[0];     #endif    
29     _height = (unsigned)dims[0];         


85 / 129

33     if (nbdims>2) _depth = (unsigned)dims[2];     #ifndef cimg_use_tiff    
34     if (nbdims>2) _depth = (unsigned)dims[2];     error cimg_use_tiff not defined    
38     if (nbdims>2) _depth = (unsigned)dims[2];     #endif    
33     if (nbdims>2) _depth = (unsigned)dims[2];     #ifndef cimg_plugin_tiff_stream    
35     if (nbdims>2) _depth = (unsigned)dims[2];     #define cimg_plugin_tiff_stream    
35     if (nbdims>2) _depth = (unsigned)dims[2];     #include <ios>    
80     if (nbdims>2) _depth = (unsigned)dims[2];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
33     if (nbdims>2) _depth = (unsigned)dims[2];      if (!tiffOutStream->good())    
38     if (nbdims>2) _depth = (unsigned)dims[2];      throw CImgArgumentException(_cimg_instance    
37     if (nbdims>2) _depth = (unsigned)dims[2];      "save_tiff(): tiffstream is not good!",    
33     if (nbdims>2) _depth = (unsigned)dims[2];      cimg_instance);    
30     if (nbdims>2) _depth = (unsigned)dims[2];      if (is_empty())    
38     if (nbdims>2) _depth = (unsigned)dims[2];      throw CImgArgumentException(_cimg_instance    
40     if (nbdims>2) _depth = (unsigned)dims[2];      "Not allowed to write empty images to stream",    
35     if (nbdims>2) _depth = (unsigned)dims[2];      cimg_instance    
39     if (nbdims>2) _depth = (unsigned)dims[2];      );    
47     if (nbdims>2) _depth = (unsigned)dims[2];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
34     if (nbdims>2) _depth = (unsigned)dims[2];      if (tif)    
55     if (nbdims>2) _depth = (unsigned)dims[2];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
35     if (nbdims>2) _depth = (unsigned)dims[2];      tiffOutStream->flush();    
35     if (nbdims>2) _depth = (unsigned)dims[2];      TIFFClose(tif);    
38     if (nbdims>2) _depth = (unsigned)dims[2];      else    
34     if (nbdims>2) _depth = (unsigned)dims[2];      throw CImgIOException(_cimg_instance    
39     if (nbdims>2) _depth = (unsigned)dims[2];      "save_tiff(): Failed to stream for writing.",    
33     if (nbdims>2) _depth = (unsigned)dims[2];      cimg_instance);    
34     if (nbdims>2) _depth = (unsigned)dims[2];      return *this;    
44     if (nbdims>2) _depth = (unsigned)dims[2];     CImg<T>& load_tiff(std::istream* tiffInStream,    
52     if (nbdims>2) _depth = (unsigned)dims[2];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
35     if (nbdims>2) _depth = (unsigned)dims[2];      const unsigned int step_frame=1)    
28     if (nbdims>2) _depth = (unsigned)dims[2];      const unsigned int    
52     if (nbdims>2) _depth = (unsigned)dims[2];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     if (nbdims>2) _depth = (unsigned)dims[2];      nstep_frame = step_frame?step_frame:1;    
61     if (nbdims>2) _depth = (unsigned)dims[2];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46     if (nbdims>2) _depth = (unsigned)dims[2];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
34     if (nbdims>2) _depth = (unsigned)dims[2];      if (tif)    
33     if (nbdims>2) _depth = (unsigned)dims[2];      unsigned int nb_images = 0;    
39     if (nbdims>2) _depth = (unsigned)dims[2];      do     
33     if (nbdims>2) _depth = (unsigned)dims[2];      ++nb_images;    
36     if (nbdims>2) _depth = (unsigned)dims[2];       while (TIFFReadDirectory(tif));    
58     if (nbdims>2) _depth = (unsigned)dims[2];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     if (nbdims>2) _depth = (unsigned)dims[2];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     if (nbdims>2) _depth = (unsigned)dims[2];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
29     if (nbdims>2) _depth = (unsigned)dims[2];      if (nfirst_frame>=nb_images)    
32     if (nbdims>2) _depth = (unsigned)dims[2];      return assign();    
30     if (nbdims>2) _depth = (unsigned)dims[2];      if (nlast_frame>=nb_images)    
32     if (nbdims>2) _depth = (unsigned)dims[2];      nlast_frame = nb_images-1;    
35     if (nbdims>2) _depth = (unsigned)dims[2];      TIFFSetDirectory(tif,0);    
37     if (nbdims>2) _depth = (unsigned)dims[2];      CImg<T> frame;    
56     if (nbdims>2) _depth = (unsigned)dims[2];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
33     if (nbdims>2) _depth = (unsigned)dims[2];      frame._load_tiff(tif,l);    
93     if (nbdims>2) _depth = (unsigned)dims[2];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
62     if (nbdims>2) _depth = (unsigned)dims[2];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     if (nbdims>2) _depth = (unsigned)dims[2];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     if (nbdims>2) _depth = (unsigned)dims[2];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
35     if (nbdims>2) _depth = (unsigned)dims[2];      TIFFClose(tif);    
38     if (nbdims>2) _depth = (unsigned)dims[2];      else    
34     if (nbdims>2) _depth = (unsigned)dims[2];      throw CImgIOException(_cimg_instance    
41     if (nbdims>2) _depth = (unsigned)dims[2];      "load_tiff(): Failed to read data from stream",    
33     if (nbdims>2) _depth = (unsigned)dims[2];      cimg_instance);    
34     if (nbdims>2) _depth = (unsigned)dims[2];      return *this;    
49     if (nbdims>2) _depth = (unsigned)dims[2];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
52     if (nbdims>2) _depth = (unsigned)dims[2];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
35     if (nbdims>2) _depth = (unsigned)dims[2];      const unsigned int step_frame=1)    
64     if (nbdims>2) _depth = (unsigned)dims[2];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
38     if (nbdims>2) _depth = (unsigned)dims[2];     #endif    
42     if (nbdims>2) _depth = (unsigned)dims[2];         


86 / 129

39     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #ifndef cimg_use_tiff    
39     else if (nbdims>3) _spectrum = (unsigned)dims[3];     error cimg_use_tiff not defined    
46     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #endif    
40     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #ifndef cimg_plugin_tiff_stream    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #define cimg_plugin_tiff_stream    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #include <ios>    
76     else if (nbdims>3) _spectrum = (unsigned)dims[3];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
40     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (!tiffOutStream->good())    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      throw CImgArgumentException(_cimg_instance    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      "save_tiff(): tiffstream is not good!",    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg_instance);    
38     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (is_empty())    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      throw CImgArgumentException(_cimg_instance    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];      "Not allowed to write empty images to stream",    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg_instance    
47     else if (nbdims>3) _spectrum = (unsigned)dims[3];      );    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (tif)    
56     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      tiffOutStream->flush();    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      TIFFClose(tif);    
45     else if (nbdims>3) _spectrum = (unsigned)dims[3];      else    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      throw CImgIOException(_cimg_instance    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      "save_tiff(): Failed to stream for writing.",    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg_instance);    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      return *this;    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];     CImg<T>& load_tiff(std::istream* tiffInStream,    
51     else if (nbdims>3) _spectrum = (unsigned)dims[3];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      const unsigned int step_frame=1)    
36     else if (nbdims>3) _spectrum = (unsigned)dims[3];      const unsigned int    
54     else if (nbdims>3) _spectrum = (unsigned)dims[3];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
39     else if (nbdims>3) _spectrum = (unsigned)dims[3];      nstep_frame = step_frame?step_frame:1;    
59     else if (nbdims>3) _spectrum = (unsigned)dims[3];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (tif)    
39     else if (nbdims>3) _spectrum = (unsigned)dims[3];      unsigned int nb_images = 0;    
47     else if (nbdims>3) _spectrum = (unsigned)dims[3];      do     
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      ++nb_images;    
40     else if (nbdims>3) _spectrum = (unsigned)dims[3];       while (TIFFReadDirectory(tif));    
58     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
92     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
36     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (nfirst_frame>=nb_images)    
39     else if (nbdims>3) _spectrum = (unsigned)dims[3];      return assign();    
37     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (nlast_frame>=nb_images)    
39     else if (nbdims>3) _spectrum = (unsigned)dims[3];      nlast_frame = nb_images-1;    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      TIFFSetDirectory(tif,0);    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      CImg<T> frame;    
56     else if (nbdims>3) _spectrum = (unsigned)dims[3];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      frame._load_tiff(tif,l);    
96     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
67     else if (nbdims>3) _spectrum = (unsigned)dims[3];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     else if (nbdims>3) _spectrum = (unsigned)dims[3];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
46     else if (nbdims>3) _spectrum = (unsigned)dims[3];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
43     else if (nbdims>3) _spectrum = (unsigned)dims[3];      TIFFClose(tif);    
45     else if (nbdims>3) _spectrum = (unsigned)dims[3];      else    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      throw CImgIOException(_cimg_instance    
44     else if (nbdims>3) _spectrum = (unsigned)dims[3];      "load_tiff(): Failed to read data from stream",    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      cimg_instance);    
42     else if (nbdims>3) _spectrum = (unsigned)dims[3];      return *this;    
52     else if (nbdims>3) _spectrum = (unsigned)dims[3];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
51     else if (nbdims>3) _spectrum = (unsigned)dims[3];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
41     else if (nbdims>3) _spectrum = (unsigned)dims[3];      const unsigned int step_frame=1)    
64     else if (nbdims>3) _spectrum = (unsigned)dims[3];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
46     else if (nbdims>3) _spectrum = (unsigned)dims[3];     #endif    
50     else if (nbdims>3) _spectrum = (unsigned)dims[3];         


87 / 129

18     delete [] _data;     #ifndef cimg_use_tiff    
26     delete [] _data;     error cimg_use_tiff not defined    
15     delete [] _data;     #endif    
26     delete [] _data;     #ifndef cimg_plugin_tiff_stream    
24     delete [] _data;     #define cimg_plugin_tiff_stream    
15     delete [] _data;     #include <ios>    
90     delete [] _data;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     delete [] _data;      if (!tiffOutStream->good())    
36     delete [] _data;      throw CImgArgumentException(_cimg_instance    
34     delete [] _data;      "save_tiff(): tiffstream is not good!",    
15     delete [] _data;      cimg_instance);    
16     delete [] _data;      if (is_empty())    
36     delete [] _data;      throw CImgArgumentException(_cimg_instance    
37     delete [] _data;      "Not allowed to write empty images to stream",    
15     delete [] _data;      cimg_instance    
15     delete [] _data;      );    
46     delete [] _data;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
15     delete [] _data;      if (tif)    
60     delete [] _data;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     delete [] _data;      tiffOutStream->flush();    
15     delete [] _data;      TIFFClose(tif);    
13     delete [] _data;      else    
31     delete [] _data;      throw CImgIOException(_cimg_instance    
37     delete [] _data;      "save_tiff(): Failed to stream for writing.",    
15     delete [] _data;      cimg_instance);    
12     delete [] _data;      return *this;    
39     delete [] _data;     CImg<T>& load_tiff(std::istream* tiffInStream,    
59     delete [] _data;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     delete [] _data;      const unsigned int step_frame=1)    
16     delete [] _data;      const unsigned int    
53     delete [] _data;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     delete [] _data;      nstep_frame = step_frame?step_frame:1;    
63     delete [] _data;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     delete [] _data;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
15     delete [] _data;      if (tif)    
21     delete [] _data;      unsigned int nb_images = 0;    
14     delete [] _data;      do     
15     delete [] _data;      ++nb_images;    
27     delete [] _data;       while (TIFFReadDirectory(tif));    
67     delete [] _data;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
101     delete [] _data;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     delete [] _data;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     delete [] _data;      if (nfirst_frame>=nb_images)    
13     delete [] _data;      return assign();    
22     delete [] _data;      if (nlast_frame>=nb_images)    
20     delete [] _data;      nlast_frame = nb_images-1;    
20     delete [] _data;      TIFFSetDirectory(tif,0);    
13     delete [] _data;      CImg<T> frame;    
59     delete [] _data;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     delete [] _data;      frame._load_tiff(tif,l);    
103     delete [] _data;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     delete [] _data;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107     delete [] _data;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     delete [] _data;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
15     delete [] _data;      TIFFClose(tif);    
13     delete [] _data;      else    
31     delete [] _data;      throw CImgIOException(_cimg_instance    
38     delete [] _data;      "load_tiff(): Failed to read data from stream",    
15     delete [] _data;      cimg_instance);    
12     delete [] _data;      return *this;    
48     delete [] _data;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59     delete [] _data;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
26     delete [] _data;      const unsigned int step_frame=1)    
65     delete [] _data;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
15     delete [] _data;     #endif    
17     delete [] _data;         


88 / 129

21     _data = new T[size()];     #ifndef cimg_use_tiff    
26     _data = new T[size()];     error cimg_use_tiff not defined    
21     _data = new T[size()];     #endif    
29     _data = new T[size()];     #ifndef cimg_plugin_tiff_stream    
29     _data = new T[size()];     #define cimg_plugin_tiff_stream    
20     _data = new T[size()];     #include <ios>    
84     _data = new T[size()];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     _data = new T[size()];      if (!tiffOutStream->good())    
38     _data = new T[size()];      throw CImgArgumentException(_cimg_instance    
34     _data = new T[size()];      "save_tiff(): tiffstream is not good!",    
18     _data = new T[size()];      cimg_instance);    
19     _data = new T[size()];      if (is_empty())    
38     _data = new T[size()];      throw CImgArgumentException(_cimg_instance    
38     _data = new T[size()];      "Not allowed to write empty images to stream",    
20     _data = new T[size()];      cimg_instance    
20     _data = new T[size()];      );    
44     _data = new T[size()];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
19     _data = new T[size()];      if (tif)    
58     _data = new T[size()];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     _data = new T[size()];      tiffOutStream->flush();    
18     _data = new T[size()];      TIFFClose(tif);    
19     _data = new T[size()];      else    
33     _data = new T[size()];      throw CImgIOException(_cimg_instance    
37     _data = new T[size()];      "save_tiff(): Failed to stream for writing.",    
18     _data = new T[size()];      cimg_instance);    
17     _data = new T[size()];      return *this;    
40     _data = new T[size()];     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     _data = new T[size()];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     _data = new T[size()];      const unsigned int step_frame=1)    
19     _data = new T[size()];      const unsigned int    
53     _data = new T[size()];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     _data = new T[size()];      nstep_frame = step_frame?step_frame:1;    
62     _data = new T[size()];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     _data = new T[size()];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
19     _data = new T[size()];      if (tif)    
22     _data = new T[size()];      unsigned int nb_images = 0;    
20     _data = new T[size()];      do     
19     _data = new T[size()];      ++nb_images;    
26     _data = new T[size()];       while (TIFFReadDirectory(tif));    
65     _data = new T[size()];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
98     _data = new T[size()];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     _data = new T[size()];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     _data = new T[size()];      if (nfirst_frame>=nb_images)    
14     _data = new T[size()];      return assign();    
23     _data = new T[size()];      if (nlast_frame>=nb_images)    
19     _data = new T[size()];      nlast_frame = nb_images-1;    
21     _data = new T[size()];      TIFFSetDirectory(tif,0);    
19     _data = new T[size()];      CImg<T> frame;    
58     _data = new T[size()];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
21     _data = new T[size()];      frame._load_tiff(tif,l);    
103     _data = new T[size()];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     _data = new T[size()];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107     _data = new T[size()];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     _data = new T[size()];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
18     _data = new T[size()];      TIFFClose(tif);    
19     _data = new T[size()];      else    
33     _data = new T[size()];      throw CImgIOException(_cimg_instance    
38     _data = new T[size()];      "load_tiff(): Failed to read data from stream",    
18     _data = new T[size()];      cimg_instance);    
17     _data = new T[size()];      return *this;    
49     _data = new T[size()];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     _data = new T[size()];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     _data = new T[size()];      const unsigned int step_frame=1)    
68     _data = new T[size()];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
21     _data = new T[size()];     #endif    
23     _data = new T[size()];         


89 / 129

44     makeImageFromMatlabData(matlabArray,classID);     #ifndef cimg_use_tiff    
42     makeImageFromMatlabData(matlabArray,classID);     error cimg_use_tiff not defined    
45     makeImageFromMatlabData(matlabArray,classID);     #endif    
42     makeImageFromMatlabData(matlabArray,classID);     #ifndef cimg_plugin_tiff_stream    
40     makeImageFromMatlabData(matlabArray,classID);     #define cimg_plugin_tiff_stream    
44     makeImageFromMatlabData(matlabArray,classID);     #include <ios>    
84     makeImageFromMatlabData(matlabArray,classID);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
39     makeImageFromMatlabData(matlabArray,classID);      if (!tiffOutStream->good())    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgArgumentException(_cimg_instance    
41     makeImageFromMatlabData(matlabArray,classID);      "save_tiff(): tiffstream is not good!",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      if (is_empty())    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgArgumentException(_cimg_instance    
42     makeImageFromMatlabData(matlabArray,classID);      "Not allowed to write empty images to stream",    
40     makeImageFromMatlabData(matlabArray,classID);      cimg_instance    
43     makeImageFromMatlabData(matlabArray,classID);      );    
47     makeImageFromMatlabData(matlabArray,classID);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
42     makeImageFromMatlabData(matlabArray,classID);      if (tif)    
56     makeImageFromMatlabData(matlabArray,classID);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
37     makeImageFromMatlabData(matlabArray,classID);      tiffOutStream->flush();    
38     makeImageFromMatlabData(matlabArray,classID);      TIFFClose(tif);    
42     makeImageFromMatlabData(matlabArray,classID);      else    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgIOException(_cimg_instance    
40     makeImageFromMatlabData(matlabArray,classID);      "save_tiff(): Failed to stream for writing.",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      return *this;    
43     makeImageFromMatlabData(matlabArray,classID);     CImg<T>& load_tiff(std::istream* tiffInStream,    
60     makeImageFromMatlabData(matlabArray,classID);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     makeImageFromMatlabData(matlabArray,classID);      const unsigned int step_frame=1)    
43     makeImageFromMatlabData(matlabArray,classID);      const unsigned int    
48     makeImageFromMatlabData(matlabArray,classID);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
39     makeImageFromMatlabData(matlabArray,classID);      nstep_frame = step_frame?step_frame:1;    
58     makeImageFromMatlabData(matlabArray,classID);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46     makeImageFromMatlabData(matlabArray,classID);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
42     makeImageFromMatlabData(matlabArray,classID);      if (tif)    
38     makeImageFromMatlabData(matlabArray,classID);      unsigned int nb_images = 0;    
44     makeImageFromMatlabData(matlabArray,classID);      do     
40     makeImageFromMatlabData(matlabArray,classID);      ++nb_images;    
37     makeImageFromMatlabData(matlabArray,classID);       while (TIFFReadDirectory(tif));    
62     makeImageFromMatlabData(matlabArray,classID);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     makeImageFromMatlabData(matlabArray,classID);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     makeImageFromMatlabData(matlabArray,classID);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
37     makeImageFromMatlabData(matlabArray,classID);      if (nfirst_frame>=nb_images)    
39     makeImageFromMatlabData(matlabArray,classID);      return assign();    
37     makeImageFromMatlabData(matlabArray,classID);      if (nlast_frame>=nb_images)    
38     makeImageFromMatlabData(matlabArray,classID);      nlast_frame = nb_images-1;    
36     makeImageFromMatlabData(matlabArray,classID);      TIFFSetDirectory(tif,0);    
39     makeImageFromMatlabData(matlabArray,classID);      CImg<T> frame;    
57     makeImageFromMatlabData(matlabArray,classID);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
36     makeImageFromMatlabData(matlabArray,classID);      frame._load_tiff(tif,l);    
92     makeImageFromMatlabData(matlabArray,classID);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     makeImageFromMatlabData(matlabArray,classID);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     makeImageFromMatlabData(matlabArray,classID);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
40     makeImageFromMatlabData(matlabArray,classID);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
38     makeImageFromMatlabData(matlabArray,classID);      TIFFClose(tif);    
42     makeImageFromMatlabData(matlabArray,classID);      else    
41     makeImageFromMatlabData(matlabArray,classID);      throw CImgIOException(_cimg_instance    
43     makeImageFromMatlabData(matlabArray,classID);      "load_tiff(): Failed to read data from stream",    
38     makeImageFromMatlabData(matlabArray,classID);      cimg_instance);    
40     makeImageFromMatlabData(matlabArray,classID);      return *this;    
46     makeImageFromMatlabData(matlabArray,classID);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     makeImageFromMatlabData(matlabArray,classID);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     makeImageFromMatlabData(matlabArray,classID);      const unsigned int step_frame=1)    
60     makeImageFromMatlabData(matlabArray,classID);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
45     makeImageFromMatlabData(matlabArray,classID);     #endif    
46     makeImageFromMatlabData(matlabArray,classID);         


90 / 129

19    private:     #ifndef cimg_use_tiff    
27    private:     error cimg_use_tiff not defined    
8    private:     #endif    
27    private:     #ifndef cimg_plugin_tiff_stream    
27    private:     #define cimg_plugin_tiff_stream    
13    private:     #include <ios>    
94    private:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25    private:      if (!tiffOutStream->good())    
40    private:      throw CImgArgumentException(_cimg_instance    
37    private:      "save_tiff(): tiffstream is not good!",    
13    private:      cimg_instance);    
14    private:      if (is_empty())    
40    private:      throw CImgArgumentException(_cimg_instance    
42    private:      "Not allowed to write empty images to stream",    
12    private:      cimg_instance    
8    private:      );    
50    private:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
8    private:      if (tif)    
63    private:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
21    private:      tiffOutStream->flush();    
15    private:      TIFFClose(tif);    
7    private:      else    
34    private:      throw CImgIOException(_cimg_instance    
42    private:      "save_tiff(): Failed to stream for writing.",    
13    private:      cimg_instance);    
12    private:      return *this;    
42    private:     CImg<T>& load_tiff(std::istream* tiffInStream,    
64    private:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    private:      const unsigned int step_frame=1)    
17    private:      const unsigned int    
56    private:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33    private:      nstep_frame = step_frame?step_frame:1;    
68    private:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
49    private:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
8    private:      if (tif)    
25    private:      unsigned int nb_images = 0;    
8    private:      do     
10    private:      ++nb_images;    
30    private:       while (TIFFReadDirectory(tif));    
72    private:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
107    private:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
44    private:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25    private:      if (nfirst_frame>=nb_images)    
15    private:      return assign();    
24    private:      if (nlast_frame>=nb_images)    
23    private:      nlast_frame = nb_images-1;    
23    private:      TIFFSetDirectory(tif,0);    
13    private:      CImg<T> frame;    
64    private:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22    private:      frame._load_tiff(tif,l);    
109    private:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
74    private:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
111    private:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    private:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
15    private:      TIFFClose(tif);    
7    private:      else    
34    private:      throw CImgIOException(_cimg_instance    
44    private:      "load_tiff(): Failed to read data from stream",    
13    private:      cimg_instance);    
12    private:      return *this;    
52    private:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64    private:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30    private:      const unsigned int step_frame=1)    
71    private:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
8    private:     #endif    
8    private:         


91 / 129

64    template <typename c> void populate_maltlab_array(c *const mdata) const      #ifndef cimg_use_tiff    
58    template <typename c> void populate_maltlab_array(c *const mdata) const      error cimg_use_tiff not defined    
69    template <typename c> void populate_maltlab_array(c *const mdata) const      #endif    
61    template <typename c> void populate_maltlab_array(c *const mdata) const      #ifndef cimg_plugin_tiff_stream    
59    template <typename c> void populate_maltlab_array(c *const mdata) const      #define cimg_plugin_tiff_stream    
65    template <typename c> void populate_maltlab_array(c *const mdata) const      #include <ios>    
76    template <typename c> void populate_maltlab_array(c *const mdata) const      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
61    template <typename c> void populate_maltlab_array(c *const mdata) const       if (!tiffOutStream->good())    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       throw CImgArgumentException(_cimg_instance    
59    template <typename c> void populate_maltlab_array(c *const mdata) const       "save_tiff(): tiffstream is not good!",    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg_instance);    
63    template <typename c> void populate_maltlab_array(c *const mdata) const       if (is_empty())    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       throw CImgArgumentException(_cimg_instance    
57    template <typename c> void populate_maltlab_array(c *const mdata) const       "Not allowed to write empty images to stream",    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg_instance    
70    template <typename c> void populate_maltlab_array(c *const mdata) const       );    
64    template <typename c> void populate_maltlab_array(c *const mdata) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
66    template <typename c> void populate_maltlab_array(c *const mdata) const       if (tif)    
65    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       tiffOutStream->flush();    
66    template <typename c> void populate_maltlab_array(c *const mdata) const       TIFFClose(tif);    
68    template <typename c> void populate_maltlab_array(c *const mdata) const       else    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       throw CImgIOException(_cimg_instance    
58    template <typename c> void populate_maltlab_array(c *const mdata) const       "save_tiff(): Failed to stream for writing.",    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg_instance);    
64    template <typename c> void populate_maltlab_array(c *const mdata) const       return *this;    
61    template <typename c> void populate_maltlab_array(c *const mdata) const      CImg<T>& load_tiff(std::istream* tiffInStream,    
63    template <typename c> void populate_maltlab_array(c *const mdata) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
59    template <typename c> void populate_maltlab_array(c *const mdata) const       const unsigned int step_frame=1)    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       const unsigned int    
58    template <typename c> void populate_maltlab_array(c *const mdata) const       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
57    template <typename c> void populate_maltlab_array(c *const mdata) const       nstep_frame = step_frame?step_frame:1;    
64    template <typename c> void populate_maltlab_array(c *const mdata) const       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
63    template <typename c> void populate_maltlab_array(c *const mdata) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
66    template <typename c> void populate_maltlab_array(c *const mdata) const       if (tif)    
60    template <typename c> void populate_maltlab_array(c *const mdata) const       unsigned int nb_images = 0;    
68    template <typename c> void populate_maltlab_array(c *const mdata) const       do     
65    template <typename c> void populate_maltlab_array(c *const mdata) const       ++nb_images;    
61    template <typename c> void populate_maltlab_array(c *const mdata) const        while (TIFFReadDirectory(tif));    
66    template <typename c> void populate_maltlab_array(c *const mdata) const       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
91    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58    template <typename c> void populate_maltlab_array(c *const mdata) const       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       if (nfirst_frame>=nb_images)    
64    template <typename c> void populate_maltlab_array(c *const mdata) const       return assign();    
59    template <typename c> void populate_maltlab_array(c *const mdata) const       if (nlast_frame>=nb_images)    
60    template <typename c> void populate_maltlab_array(c *const mdata) const       nlast_frame = nb_images-1;    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       TIFFSetDirectory(tif,0);    
65    template <typename c> void populate_maltlab_array(c *const mdata) const       CImg<T> frame;    
59    template <typename c> void populate_maltlab_array(c *const mdata) const       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
61    template <typename c> void populate_maltlab_array(c *const mdata) const       frame._load_tiff(tif,l);    
93    template <typename c> void populate_maltlab_array(c *const mdata) const       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    template <typename c> void populate_maltlab_array(c *const mdata) const       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100    template <typename c> void populate_maltlab_array(c *const mdata) const       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
66    template <typename c> void populate_maltlab_array(c *const mdata) const       TIFFClose(tif);    
68    template <typename c> void populate_maltlab_array(c *const mdata) const       else    
61    template <typename c> void populate_maltlab_array(c *const mdata) const       throw CImgIOException(_cimg_instance    
57    template <typename c> void populate_maltlab_array(c *const mdata) const       "load_tiff(): Failed to read data from stream",    
62    template <typename c> void populate_maltlab_array(c *const mdata) const       cimg_instance);    
64    template <typename c> void populate_maltlab_array(c *const mdata) const       return *this;    
61    template <typename c> void populate_maltlab_array(c *const mdata) const      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
63    template <typename c> void populate_maltlab_array(c *const mdata) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
59    template <typename c> void populate_maltlab_array(c *const mdata) const       const unsigned int step_frame=1)    
68    template <typename c> void populate_maltlab_array(c *const mdata) const       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
69    template <typename c> void populate_maltlab_array(c *const mdata) const      #endif    
72    template <typename c> void populate_maltlab_array(c *const mdata) const          


92 / 129

89     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #ifndef cimg_use_tiff    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     error cimg_use_tiff not defined    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #endif    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #ifndef cimg_plugin_tiff_stream    
89     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #define cimg_plugin_tiff_stream    
92     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #include <ios>    
91     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (!tiffOutStream->good())    
84     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      throw CImgArgumentException(_cimg_instance    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      "save_tiff(): tiffstream is not good!",    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg_instance);    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (is_empty())    
84     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      throw CImgArgumentException(_cimg_instance    
80     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      "Not allowed to write empty images to stream",    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg_instance    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      );    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
90     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (tif)    
67     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      tiffOutStream->flush();    
89     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      TIFFClose(tif);    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      else    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      throw CImgIOException(_cimg_instance    
83     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      "save_tiff(): Failed to stream for writing.",    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg_instance);    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      return *this;    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     CImg<T>& load_tiff(std::istream* tiffInStream,    
83     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      const unsigned int step_frame=1)    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      const unsigned int    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      nstep_frame = step_frame?step_frame:1;    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
90     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (tif)    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      unsigned int nb_images = 0;    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      do     
90     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      ++nb_images;    
82     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);       while (TIFFReadDirectory(tif));    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
84     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (nfirst_frame>=nb_images)    
88     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      return assign();    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (nlast_frame>=nb_images)    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      nlast_frame = nb_images-1;    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      TIFFSetDirectory(tif,0);    
91     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      CImg<T> frame;    
83     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
84     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      frame._load_tiff(tif,l);    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
78     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
96     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
89     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      TIFFClose(tif);    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      else    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      throw CImgIOException(_cimg_instance    
82     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      "load_tiff(): Failed to read data from stream",    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      cimg_instance);    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      return *this;    
86     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
83     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
85     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      const unsigned int step_frame=1)    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);     #endif    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (c)(*this)(x,y,z,v);         


93 / 129

52    void populate_maltlab_array(mxLogical *const mdata) const      #ifndef cimg_use_tiff    
48    void populate_maltlab_array(mxLogical *const mdata) const      error cimg_use_tiff not defined    
55    void populate_maltlab_array(mxLogical *const mdata) const      #endif    
50    void populate_maltlab_array(mxLogical *const mdata) const      #ifndef cimg_plugin_tiff_stream    
50    void populate_maltlab_array(mxLogical *const mdata) const      #define cimg_plugin_tiff_stream    
52    void populate_maltlab_array(mxLogical *const mdata) const      #include <ios>    
74    void populate_maltlab_array(mxLogical *const mdata) const      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
47    void populate_maltlab_array(mxLogical *const mdata) const       if (!tiffOutStream->good())    
50    void populate_maltlab_array(mxLogical *const mdata) const       throw CImgArgumentException(_cimg_instance    
47    void populate_maltlab_array(mxLogical *const mdata) const       "save_tiff(): tiffstream is not good!",    
49    void populate_maltlab_array(mxLogical *const mdata) const       cimg_instance);    
50    void populate_maltlab_array(mxLogical *const mdata) const       if (is_empty())    
50    void populate_maltlab_array(mxLogical *const mdata) const       throw CImgArgumentException(_cimg_instance    
49    void populate_maltlab_array(mxLogical *const mdata) const       "Not allowed to write empty images to stream",    
49    void populate_maltlab_array(mxLogical *const mdata) const       cimg_instance    
56    void populate_maltlab_array(mxLogical *const mdata) const       );    
53    void populate_maltlab_array(mxLogical *const mdata) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
53    void populate_maltlab_array(mxLogical *const mdata) const       if (tif)    
59    void populate_maltlab_array(mxLogical *const mdata) const       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
48    void populate_maltlab_array(mxLogical *const mdata) const       tiffOutStream->flush();    
53    void populate_maltlab_array(mxLogical *const mdata) const       TIFFClose(tif);    
54    void populate_maltlab_array(mxLogical *const mdata) const       else    
49    void populate_maltlab_array(mxLogical *const mdata) const       throw CImgIOException(_cimg_instance    
49    void populate_maltlab_array(mxLogical *const mdata) const       "save_tiff(): Failed to stream for writing.",    
49    void populate_maltlab_array(mxLogical *const mdata) const       cimg_instance);    
50    void populate_maltlab_array(mxLogical *const mdata) const       return *this;    
51    void populate_maltlab_array(mxLogical *const mdata) const      CImg<T>& load_tiff(std::istream* tiffInStream,    
59    void populate_maltlab_array(mxLogical *const mdata) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
50    void populate_maltlab_array(mxLogical *const mdata) const       const unsigned int step_frame=1)    
49    void populate_maltlab_array(mxLogical *const mdata) const       const unsigned int    
53    void populate_maltlab_array(mxLogical *const mdata) const       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
47    void populate_maltlab_array(mxLogical *const mdata) const       nstep_frame = step_frame?step_frame:1;    
60    void populate_maltlab_array(mxLogical *const mdata) const       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
53    void populate_maltlab_array(mxLogical *const mdata) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
53    void populate_maltlab_array(mxLogical *const mdata) const       if (tif)    
48    void populate_maltlab_array(mxLogical *const mdata) const       unsigned int nb_images = 0;    
54    void populate_maltlab_array(mxLogical *const mdata) const       do     
51    void populate_maltlab_array(mxLogical *const mdata) const       ++nb_images;    
50    void populate_maltlab_array(mxLogical *const mdata) const        while (TIFFReadDirectory(tif));    
63    void populate_maltlab_array(mxLogical *const mdata) const       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
92    void populate_maltlab_array(mxLogical *const mdata) const       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
48    void populate_maltlab_array(mxLogical *const mdata) const       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
47    void populate_maltlab_array(mxLogical *const mdata) const       if (nfirst_frame>=nb_images)    
50    void populate_maltlab_array(mxLogical *const mdata) const       return assign();    
45    void populate_maltlab_array(mxLogical *const mdata) const       if (nlast_frame>=nb_images)    
46    void populate_maltlab_array(mxLogical *const mdata) const       nlast_frame = nb_images-1;    
50    void populate_maltlab_array(mxLogical *const mdata) const       TIFFSetDirectory(tif,0);    
53    void populate_maltlab_array(mxLogical *const mdata) const       CImg<T> frame;    
56    void populate_maltlab_array(mxLogical *const mdata) const       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
48    void populate_maltlab_array(mxLogical *const mdata) const       frame._load_tiff(tif,l);    
96    void populate_maltlab_array(mxLogical *const mdata) const       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
67    void populate_maltlab_array(mxLogical *const mdata) const       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101    void populate_maltlab_array(mxLogical *const mdata) const       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
51    void populate_maltlab_array(mxLogical *const mdata) const       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
53    void populate_maltlab_array(mxLogical *const mdata) const       TIFFClose(tif);    
54    void populate_maltlab_array(mxLogical *const mdata) const       else    
49    void populate_maltlab_array(mxLogical *const mdata) const       throw CImgIOException(_cimg_instance    
50    void populate_maltlab_array(mxLogical *const mdata) const       "load_tiff(): Failed to read data from stream",    
49    void populate_maltlab_array(mxLogical *const mdata) const       cimg_instance);    
50    void populate_maltlab_array(mxLogical *const mdata) const       return *this;    
53    void populate_maltlab_array(mxLogical *const mdata) const      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59    void populate_maltlab_array(mxLogical *const mdata) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
50    void populate_maltlab_array(mxLogical *const mdata) const       const unsigned int step_frame=1)    
66    void populate_maltlab_array(mxLogical *const mdata) const       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
55    void populate_maltlab_array(mxLogical *const mdata) const      #endif    
58    void populate_maltlab_array(mxLogical *const mdata) const          


94 / 129

101     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #ifndef cimg_use_tiff    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     error cimg_use_tiff not defined    
108     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #endif    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #ifndef cimg_plugin_tiff_stream    
101     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #define cimg_plugin_tiff_stream    
104     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #include <ios>    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (!tiffOutStream->good())    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      throw CImgArgumentException(_cimg_instance    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      "save_tiff(): tiffstream is not good!",    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg_instance);    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (is_empty())    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      throw CImgArgumentException(_cimg_instance    
91     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      "Not allowed to write empty images to stream",    
101     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg_instance    
108     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      );    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
103     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (tif)    
78     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      tiffOutStream->flush();    
102     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      TIFFClose(tif);    
107     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      else    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      throw CImgIOException(_cimg_instance    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      "save_tiff(): Failed to stream for writing.",    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg_instance);    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      return *this;    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     CImg<T>& load_tiff(std::istream* tiffInStream,    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      const unsigned int step_frame=1)    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      const unsigned int    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      nstep_frame = step_frame?step_frame:1;    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
103     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (tif)    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      unsigned int nb_images = 0;    
108     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      do     
102     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      ++nb_images;    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);       while (TIFFReadDirectory(tif));    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
96     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (nfirst_frame>=nb_images)    
101     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      return assign();    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (nlast_frame>=nb_images)    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      nlast_frame = nb_images-1;    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      TIFFSetDirectory(tif,0);    
104     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      CImg<T> frame;    
94     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
96     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      frame._load_tiff(tif,l);    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
87     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
102     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      TIFFClose(tif);    
107     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      else    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      throw CImgIOException(_cimg_instance    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      "load_tiff(): Failed to read data from stream",    
99     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      cimg_instance);    
100     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      return *this;    
98     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
95     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
97     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      const unsigned int step_frame=1)    
96     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
108     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);     #endif    
111     cimg_forXYZC(*this,x,y,z,v) mdata[((v*_depth + z)*_width + x)*_height + y] = (mxLogical)((*this)(x,y,z,v)!=0);         


95 / 129

19    public:     #ifndef cimg_use_tiff    
29    public:     error cimg_use_tiff not defined    
6    public:     #endif    
28    public:     #ifndef cimg_plugin_tiff_stream    
28    public:     #define cimg_plugin_tiff_stream    
12    public:     #include <ios>    
96    public:     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
27    public:      if (!tiffOutStream->good())    
40    public:      throw CImgArgumentException(_cimg_instance    
38    public:      "save_tiff(): tiffstream is not good!",    
14    public:      cimg_instance);    
15    public:      if (is_empty())    
40    public:      throw CImgArgumentException(_cimg_instance    
45    public:      "Not allowed to write empty images to stream",    
12    public:      cimg_instance    
7    public:      );    
52    public:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
8    public:      if (tif)    
65    public:      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
22    public:      tiffOutStream->flush();    
14    public:      TIFFClose(tif);    
6    public:      else    
34    public:      throw CImgIOException(_cimg_instance    
44    public:      "save_tiff(): Failed to stream for writing.",    
14    public:      cimg_instance);    
12    public:      return *this;    
43    public:     CImg<T>& load_tiff(std::istream* tiffInStream,    
66    public:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31    public:      const unsigned int step_frame=1)    
17    public:      const unsigned int    
59    public:      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
37    public:      nstep_frame = step_frame?step_frame:1;    
70    public:      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
51    public:      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
8    public:      if (tif)    
25    public:      unsigned int nb_images = 0;    
7    public:      do     
11    public:      ++nb_images;    
30    public:       while (TIFFReadDirectory(tif));    
74    public:      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
109    public:      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
46    public:      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27    public:      if (nfirst_frame>=nb_images)    
15    public:      return assign();    
26    public:      if (nlast_frame>=nb_images)    
25    public:      nlast_frame = nb_images-1;    
23    public:      TIFFSetDirectory(tif,0);    
15    public:      CImg<T> frame;    
66    public:      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    public:      frame._load_tiff(tif,l);    
111    public:      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
76    public:      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
114    public:      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
50    public:      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
14    public:      TIFFClose(tif);    
6    public:      else    
34    public:      throw CImgIOException(_cimg_instance    
46    public:      "load_tiff(): Failed to read data from stream",    
14    public:      cimg_instance);    
12    public:      return *this;    
53    public:     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
66    public:      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31    public:      const unsigned int step_frame=1)    
73    public:      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
6    public:     #endif    
7    public:         


96 / 129

77    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #ifndef cimg_use_tiff    
70    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      error cimg_use_tiff not defined    
82    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #endif    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #ifndef cimg_plugin_tiff_stream    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #define cimg_plugin_tiff_stream    
78    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #include <ios>    
77    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (!tiffOutStream->good())    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       throw CImgArgumentException(_cimg_instance    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       "save_tiff(): tiffstream is not good!",    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg_instance);    
78    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (is_empty())    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       throw CImgArgumentException(_cimg_instance    
71    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       "Not allowed to write empty images to stream",    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg_instance    
82    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       );    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (tif)    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       tiffOutStream->flush();    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       TIFFClose(tif);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       else    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       throw CImgIOException(_cimg_instance    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       "save_tiff(): Failed to stream for writing.",    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg_instance);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       return *this;    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      CImg<T>& load_tiff(std::istream* tiffInStream,    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
71    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       const unsigned int step_frame=1)    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       const unsigned int    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       nstep_frame = step_frame?step_frame:1;    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (tif)    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       unsigned int nb_images = 0;    
81    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       do     
78    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       ++nb_images;    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const        while (TIFFReadDirectory(tif));    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
69    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (nfirst_frame>=nb_images)    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       return assign();    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (nlast_frame>=nb_images)    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       nlast_frame = nb_images-1;    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       TIFFSetDirectory(tif,0);    
77    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       CImg<T> frame;    
73    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       frame._load_tiff(tif,l);    
96    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
75    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
103    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
71    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       TIFFClose(tif);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       else    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       throw CImgIOException(_cimg_instance    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       "load_tiff(): Failed to read data from stream",    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       cimg_instance);    
79    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       return *this;    
74    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
72    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
71    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       const unsigned int step_frame=1)    
76    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
82    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const      #endif    
84    mxArray *toMatlab(mxClassID classID=mxDOUBLE_CLASS, const bool squeeze=false) const          


97 / 129

30     if (!isNumericalClassID(classID))      #ifndef cimg_use_tiff    
34     if (!isNumericalClassID(classID))      error cimg_use_tiff not defined    
34     if (!isNumericalClassID(classID))      #endif    
30     if (!isNumericalClassID(classID))      #ifndef cimg_plugin_tiff_stream    
31     if (!isNumericalClassID(classID))      #define cimg_plugin_tiff_stream    
31     if (!isNumericalClassID(classID))      #include <ios>    
84     if (!isNumericalClassID(classID))      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     if (!isNumericalClassID(classID))       if (!tiffOutStream->good())    
36     if (!isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
36     if (!isNumericalClassID(classID))       "save_tiff(): tiffstream is not good!",    
28     if (!isNumericalClassID(classID))       cimg_instance);    
24     if (!isNumericalClassID(classID))       if (is_empty())    
36     if (!isNumericalClassID(classID))       throw CImgArgumentException(_cimg_instance    
41     if (!isNumericalClassID(classID))       "Not allowed to write empty images to stream",    
29     if (!isNumericalClassID(classID))       cimg_instance    
33     if (!isNumericalClassID(classID))       );    
47     if (!isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
28     if (!isNumericalClassID(classID))       if (tif)    
53     if (!isNumericalClassID(classID))       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
28     if (!isNumericalClassID(classID))       tiffOutStream->flush();    
29     if (!isNumericalClassID(classID))       TIFFClose(tif);    
31     if (!isNumericalClassID(classID))       else    
34     if (!isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
40     if (!isNumericalClassID(classID))       "save_tiff(): Failed to stream for writing.",    
28     if (!isNumericalClassID(classID))       cimg_instance);    
31     if (!isNumericalClassID(classID))       return *this;    
43     if (!isNumericalClassID(classID))      CImg<T>& load_tiff(std::istream* tiffInStream,    
57     if (!isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     if (!isNumericalClassID(classID))       const unsigned int step_frame=1)    
32     if (!isNumericalClassID(classID))       const unsigned int    
49     if (!isNumericalClassID(classID))       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     if (!isNumericalClassID(classID))       nstep_frame = step_frame?step_frame:1;    
59     if (!isNumericalClassID(classID))       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
46     if (!isNumericalClassID(classID))       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
28     if (!isNumericalClassID(classID))       if (tif)    
31     if (!isNumericalClassID(classID))       unsigned int nb_images = 0;    
33     if (!isNumericalClassID(classID))       do     
30     if (!isNumericalClassID(classID))       ++nb_images;    
30     if (!isNumericalClassID(classID))        while (TIFFReadDirectory(tif));    
59     if (!isNumericalClassID(classID))       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     if (!isNumericalClassID(classID))       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     if (!isNumericalClassID(classID))       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     if (!isNumericalClassID(classID))       if (nfirst_frame>=nb_images)    
28     if (!isNumericalClassID(classID))       return assign();    
26     if (!isNumericalClassID(classID))       if (nlast_frame>=nb_images)    
30     if (!isNumericalClassID(classID))       nlast_frame = nb_images-1;    
30     if (!isNumericalClassID(classID))       TIFFSetDirectory(tif,0);    
32     if (!isNumericalClassID(classID))       CImg<T> frame;    
54     if (!isNumericalClassID(classID))       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
28     if (!isNumericalClassID(classID))       frame._load_tiff(tif,l);    
95     if (!isNumericalClassID(classID))       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
67     if (!isNumericalClassID(classID))       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     if (!isNumericalClassID(classID))       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     if (!isNumericalClassID(classID))       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
29     if (!isNumericalClassID(classID))       TIFFClose(tif);    
31     if (!isNumericalClassID(classID))       else    
34     if (!isNumericalClassID(classID))       throw CImgIOException(_cimg_instance    
40     if (!isNumericalClassID(classID))       "load_tiff(): Failed to read data from stream",    
28     if (!isNumericalClassID(classID))       cimg_instance);    
31     if (!isNumericalClassID(classID))       return *this;    
49     if (!isNumericalClassID(classID))      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     if (!isNumericalClassID(classID))       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     if (!isNumericalClassID(classID))       const unsigned int step_frame=1)    
63     if (!isNumericalClassID(classID))       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
34     if (!isNumericalClassID(classID))      #endif    
35     if (!isNumericalClassID(classID))          


98 / 129

11    #if cimg_debug>1     #ifndef cimg_use_tiff    
23    #if cimg_debug>1     error cimg_use_tiff not defined    
14    #if cimg_debug>1     #endif    
21    #if cimg_debug>1     #ifndef cimg_plugin_tiff_stream    
22    #if cimg_debug>1     #define cimg_plugin_tiff_stream    
12    #if cimg_debug>1     #include <ios>    
91    #if cimg_debug>1     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
22    #if cimg_debug>1      if (!tiffOutStream->good())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
34    #if cimg_debug>1      "save_tiff(): tiffstream is not good!",    
13    #if cimg_debug>1      cimg_instance);    
12    #if cimg_debug>1      if (is_empty())    
37    #if cimg_debug>1      throw CImgArgumentException(_cimg_instance    
42    #if cimg_debug>1      "Not allowed to write empty images to stream",    
11    #if cimg_debug>1      cimg_instance    
15    #if cimg_debug>1      );    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13    #if cimg_debug>1      if (tif)    
62    #if cimg_debug>1      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20    #if cimg_debug>1      tiffOutStream->flush();    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
40    #if cimg_debug>1      "save_tiff(): Failed to stream for writing.",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
42    #if cimg_debug>1     CImg<T>& load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
17    #if cimg_debug>1      const unsigned int    
55    #if cimg_debug>1      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34    #if cimg_debug>1      nstep_frame = step_frame?step_frame:1;    
67    #if cimg_debug>1      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48    #if cimg_debug>1      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13    #if cimg_debug>1      if (tif)    
24    #if cimg_debug>1      unsigned int nb_images = 0;    
14    #if cimg_debug>1      do     
14    #if cimg_debug>1      ++nb_images;    
29    #if cimg_debug>1       while (TIFFReadDirectory(tif));    
67    #if cimg_debug>1      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103    #if cimg_debug>1      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42    #if cimg_debug>1      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
21    #if cimg_debug>1      if (nfirst_frame>=nb_images)    
17    #if cimg_debug>1      return assign();    
21    #if cimg_debug>1      if (nlast_frame>=nb_images)    
23    #if cimg_debug>1      nlast_frame = nb_images-1;    
23    #if cimg_debug>1      TIFFSetDirectory(tif,0);    
15    #if cimg_debug>1      CImg<T> frame;    
63    #if cimg_debug>1      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23    #if cimg_debug>1      frame._load_tiff(tif,l);    
103    #if cimg_debug>1      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69    #if cimg_debug>1      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107    #if cimg_debug>1      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
47    #if cimg_debug>1      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16    #if cimg_debug>1      TIFFClose(tif);    
14    #if cimg_debug>1      else    
31    #if cimg_debug>1      throw CImgIOException(_cimg_instance    
43    #if cimg_debug>1      "load_tiff(): Failed to read data from stream",    
13    #if cimg_debug>1      cimg_instance);    
16    #if cimg_debug>1      return *this;    
49    #if cimg_debug>1     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62    #if cimg_debug>1      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28    #if cimg_debug>1      const unsigned int step_frame=1)    
70    #if cimg_debug>1      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
14    #if cimg_debug>1     #endif    
16    #if cimg_debug>1         


99 / 129

44     cimg::warn("Invalid MATLAB Class Id Specified.");     #ifndef cimg_use_tiff    
42     cimg::warn("Invalid MATLAB Class Id Specified.");     error cimg_use_tiff not defined    
46     cimg::warn("Invalid MATLAB Class Id Specified.");     #endif    
45     cimg::warn("Invalid MATLAB Class Id Specified.");     #ifndef cimg_plugin_tiff_stream    
46     cimg::warn("Invalid MATLAB Class Id Specified.");     #define cimg_plugin_tiff_stream    
44     cimg::warn("Invalid MATLAB Class Id Specified.");     #include <ios>    
83     cimg::warn("Invalid MATLAB Class Id Specified.");     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
43     cimg::warn("Invalid MATLAB Class Id Specified.");      if (!tiffOutStream->good())    
46     cimg::warn("Invalid MATLAB Class Id Specified.");      throw CImgArgumentException(_cimg_instance    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      "save_tiff(): tiffstream is not good!",    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg_instance);    
43     cimg::warn("Invalid MATLAB Class Id Specified.");      if (is_empty())    
46     cimg::warn("Invalid MATLAB Class Id Specified.");      throw CImgArgumentException(_cimg_instance    
43     cimg::warn("Invalid MATLAB Class Id Specified.");      "Not allowed to write empty images to stream",    
41     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg_instance    
47     cimg::warn("Invalid MATLAB Class Id Specified.");      );    
48     cimg::warn("Invalid MATLAB Class Id Specified.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      if (tif)    
55     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
43     cimg::warn("Invalid MATLAB Class Id Specified.");      tiffOutStream->flush();    
41     cimg::warn("Invalid MATLAB Class Id Specified.");      TIFFClose(tif);    
46     cimg::warn("Invalid MATLAB Class Id Specified.");      else    
45     cimg::warn("Invalid MATLAB Class Id Specified.");      throw CImgIOException(_cimg_instance    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      "save_tiff(): Failed to stream for writing.",    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg_instance);    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      return *this;    
45     cimg::warn("Invalid MATLAB Class Id Specified.");     CImg<T>& load_tiff(std::istream* tiffInStream,    
57     cimg::warn("Invalid MATLAB Class Id Specified.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      const unsigned int step_frame=1)    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      const unsigned int    
54     cimg::warn("Invalid MATLAB Class Id Specified.");      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      nstep_frame = step_frame?step_frame:1;    
62     cimg::warn("Invalid MATLAB Class Id Specified.");      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
48     cimg::warn("Invalid MATLAB Class Id Specified.");      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      if (tif)    
41     cimg::warn("Invalid MATLAB Class Id Specified.");      unsigned int nb_images = 0;    
47     cimg::warn("Invalid MATLAB Class Id Specified.");      do     
44     cimg::warn("Invalid MATLAB Class Id Specified.");      ++nb_images;    
41     cimg::warn("Invalid MATLAB Class Id Specified.");       while (TIFFReadDirectory(tif));    
65     cimg::warn("Invalid MATLAB Class Id Specified.");      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
80     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
43     cimg::warn("Invalid MATLAB Class Id Specified.");      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      if (nfirst_frame>=nb_images)    
40     cimg::warn("Invalid MATLAB Class Id Specified.");      return assign();    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      if (nlast_frame>=nb_images)    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      nlast_frame = nb_images-1;    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      TIFFSetDirectory(tif,0);    
42     cimg::warn("Invalid MATLAB Class Id Specified.");      CImg<T> frame;    
57     cimg::warn("Invalid MATLAB Class Id Specified.");      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
42     cimg::warn("Invalid MATLAB Class Id Specified.");      frame._load_tiff(tif,l);    
97     cimg::warn("Invalid MATLAB Class Id Specified.");      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     cimg::warn("Invalid MATLAB Class Id Specified.");      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     cimg::warn("Invalid MATLAB Class Id Specified.");      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
41     cimg::warn("Invalid MATLAB Class Id Specified.");      TIFFClose(tif);    
46     cimg::warn("Invalid MATLAB Class Id Specified.");      else    
45     cimg::warn("Invalid MATLAB Class Id Specified.");      throw CImgIOException(_cimg_instance    
41     cimg::warn("Invalid MATLAB Class Id Specified.");      "load_tiff(): Failed to read data from stream",    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      cimg_instance);    
44     cimg::warn("Invalid MATLAB Class Id Specified.");      return *this;    
50     cimg::warn("Invalid MATLAB Class Id Specified.");     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     cimg::warn("Invalid MATLAB Class Id Specified.");      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
39     cimg::warn("Invalid MATLAB Class Id Specified.");      const unsigned int step_frame=1)    
61     cimg::warn("Invalid MATLAB Class Id Specified.");      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
46     cimg::warn("Invalid MATLAB Class Id Specified.");     #endif    
50     cimg::warn("Invalid MATLAB Class Id Specified.");         


100 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


101 / 129

19     return 0;     #ifndef cimg_use_tiff    
26     return 0;     error cimg_use_tiff not defined    
8     return 0;     #endif    
28     return 0;     #ifndef cimg_plugin_tiff_stream    
28     return 0;     #define cimg_plugin_tiff_stream    
12     return 0;     #include <ios>    
90     return 0;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     return 0;      if (!tiffOutStream->good())    
38     return 0;      throw CImgArgumentException(_cimg_instance    
34     return 0;      "save_tiff(): tiffstream is not good!",    
13     return 0;      cimg_instance);    
14     return 0;      if (is_empty())    
38     return 0;      throw CImgArgumentException(_cimg_instance    
42     return 0;      "Not allowed to write empty images to stream",    
12     return 0;      cimg_instance    
8     return 0;      );    
47     return 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
9     return 0;      if (tif)    
61     return 0;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
19     return 0;      tiffOutStream->flush();    
14     return 0;      TIFFClose(tif);    
8     return 0;      else    
32     return 0;      throw CImgIOException(_cimg_instance    
41     return 0;      "save_tiff(): Failed to stream for writing.",    
13     return 0;      cimg_instance);    
5     return 0;      return *this;    
41     return 0;     CImg<T>& load_tiff(std::istream* tiffInStream,    
61     return 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     return 0;      const unsigned int step_frame=1)    
14     return 0;      const unsigned int    
57     return 0;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     return 0;      nstep_frame = step_frame?step_frame:1;    
68     return 0;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     return 0;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
9     return 0;      if (tif)    
22     return 0;      unsigned int nb_images = 0;    
8     return 0;      do     
11     return 0;      ++nb_images;    
27     return 0;       while (TIFFReadDirectory(tif));    
70     return 0;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
105     return 0;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
42     return 0;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     return 0;      if (nfirst_frame>=nb_images)    
8     return 0;      return assign();    
24     return 0;      if (nlast_frame>=nb_images)    
22     return 0;      nlast_frame = nb_images-1;    
18     return 0;      TIFFSetDirectory(tif,0);    
12     return 0;      CImg<T> frame;    
62     return 0;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     return 0;      frame._load_tiff(tif,l);    
107     return 0;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
73     return 0;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
109     return 0;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45     return 0;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
14     return 0;      TIFFClose(tif);    
8     return 0;      else    
32     return 0;      throw CImgIOException(_cimg_instance    
42     return 0;      "load_tiff(): Failed to read data from stream",    
13     return 0;      cimg_instance);    
5     return 0;      return *this;    
51     return 0;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
61     return 0;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     return 0;      const unsigned int step_frame=1)    
67     return 0;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
8     return 0;     #endif    
10     return 0;         


102 / 129

17     mwSize dims[4];     #ifndef cimg_use_tiff    
27     mwSize dims[4];     error cimg_use_tiff not defined    
13     mwSize dims[4];     #endif    
27     mwSize dims[4];     #ifndef cimg_plugin_tiff_stream    
25     mwSize dims[4];     #define cimg_plugin_tiff_stream    
13     mwSize dims[4];     #include <ios>    
90     mwSize dims[4];     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     mwSize dims[4];      if (!tiffOutStream->good())    
37     mwSize dims[4];      throw CImgArgumentException(_cimg_instance    
34     mwSize dims[4];      "save_tiff(): tiffstream is not good!",    
14     mwSize dims[4];      cimg_instance);    
15     mwSize dims[4];      if (is_empty())    
37     mwSize dims[4];      throw CImgArgumentException(_cimg_instance    
39     mwSize dims[4];      "Not allowed to write empty images to stream",    
13     mwSize dims[4];      cimg_instance    
14     mwSize dims[4];      );    
48     mwSize dims[4];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13     mwSize dims[4];      if (tif)    
59     mwSize dims[4];      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
19     mwSize dims[4];      tiffOutStream->flush();    
14     mwSize dims[4];      TIFFClose(tif);    
13     mwSize dims[4];      else    
31     mwSize dims[4];      throw CImgIOException(_cimg_instance    
41     mwSize dims[4];      "save_tiff(): Failed to stream for writing.",    
14     mwSize dims[4];      cimg_instance);    
13     mwSize dims[4];      return *this;    
41     mwSize dims[4];     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     mwSize dims[4];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     mwSize dims[4];      const unsigned int step_frame=1)    
17     mwSize dims[4];      const unsigned int    
55     mwSize dims[4];      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     mwSize dims[4];      nstep_frame = step_frame?step_frame:1;    
66     mwSize dims[4];      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     mwSize dims[4];      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13     mwSize dims[4];      if (tif)    
20     mwSize dims[4];      unsigned int nb_images = 0;    
14     mwSize dims[4];      do     
12     mwSize dims[4];      ++nb_images;    
25     mwSize dims[4];       while (TIFFReadDirectory(tif));    
70     mwSize dims[4];      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
102     mwSize dims[4];      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
43     mwSize dims[4];      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     mwSize dims[4];      if (nfirst_frame>=nb_images)    
14     mwSize dims[4];      return assign();    
24     mwSize dims[4];      if (nlast_frame>=nb_images)    
21     mwSize dims[4];      nlast_frame = nb_images-1;    
20     mwSize dims[4];      TIFFSetDirectory(tif,0);    
14     mwSize dims[4];      CImg<T> frame;    
61     mwSize dims[4];      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     mwSize dims[4];      frame._load_tiff(tif,l);    
105     mwSize dims[4];      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
71     mwSize dims[4];      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
108     mwSize dims[4];      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     mwSize dims[4];      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
14     mwSize dims[4];      TIFFClose(tif);    
13     mwSize dims[4];      else    
31     mwSize dims[4];      throw CImgIOException(_cimg_instance    
41     mwSize dims[4];      "load_tiff(): Failed to read data from stream",    
14     mwSize dims[4];      cimg_instance);    
13     mwSize dims[4];      return *this;    
50     mwSize dims[4];     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     mwSize dims[4];      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     mwSize dims[4];      const unsigned int step_frame=1)    
68     mwSize dims[4];      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
13     mwSize dims[4];     #endif    
16     mwSize dims[4];         


103 / 129

21     dims[0] = (mwSize)_height;     #ifndef cimg_use_tiff    
28     dims[0] = (mwSize)_height;     error cimg_use_tiff not defined    
25     dims[0] = (mwSize)_height;     #endif    
28     dims[0] = (mwSize)_height;     #ifndef cimg_plugin_tiff_stream    
28     dims[0] = (mwSize)_height;     #define cimg_plugin_tiff_stream    
24     dims[0] = (mwSize)_height;     #include <ios>    
88     dims[0] = (mwSize)_height;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     dims[0] = (mwSize)_height;      if (!tiffOutStream->good())    
37     dims[0] = (mwSize)_height;      throw CImgArgumentException(_cimg_instance    
34     dims[0] = (mwSize)_height;      "save_tiff(): tiffstream is not good!",    
21     dims[0] = (mwSize)_height;      cimg_instance);    
22     dims[0] = (mwSize)_height;      if (is_empty())    
37     dims[0] = (mwSize)_height;      throw CImgArgumentException(_cimg_instance    
39     dims[0] = (mwSize)_height;      "Not allowed to write empty images to stream",    
23     dims[0] = (mwSize)_height;      cimg_instance    
24     dims[0] = (mwSize)_height;      );    
44     dims[0] = (mwSize)_height;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
21     dims[0] = (mwSize)_height;      if (tif)    
55     dims[0] = (mwSize)_height;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     dims[0] = (mwSize)_height;      tiffOutStream->flush();    
22     dims[0] = (mwSize)_height;      TIFFClose(tif);    
24     dims[0] = (mwSize)_height;      else    
32     dims[0] = (mwSize)_height;      throw CImgIOException(_cimg_instance    
39     dims[0] = (mwSize)_height;      "save_tiff(): Failed to stream for writing.",    
21     dims[0] = (mwSize)_height;      cimg_instance);    
22     dims[0] = (mwSize)_height;      return *this;    
40     dims[0] = (mwSize)_height;     CImg<T>& load_tiff(std::istream* tiffInStream,    
59     dims[0] = (mwSize)_height;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[0] = (mwSize)_height;      const unsigned int step_frame=1)    
21     dims[0] = (mwSize)_height;      const unsigned int    
51     dims[0] = (mwSize)_height;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     dims[0] = (mwSize)_height;      nstep_frame = step_frame?step_frame:1;    
60     dims[0] = (mwSize)_height;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     dims[0] = (mwSize)_height;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
21     dims[0] = (mwSize)_height;      if (tif)    
24     dims[0] = (mwSize)_height;      unsigned int nb_images = 0;    
24     dims[0] = (mwSize)_height;      do     
23     dims[0] = (mwSize)_height;      ++nb_images;    
27     dims[0] = (mwSize)_height;       while (TIFFReadDirectory(tif));    
66     dims[0] = (mwSize)_height;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     dims[0] = (mwSize)_height;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
39     dims[0] = (mwSize)_height;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     dims[0] = (mwSize)_height;      if (nfirst_frame>=nb_images)    
23     dims[0] = (mwSize)_height;      return assign();    
25     dims[0] = (mwSize)_height;      if (nlast_frame>=nb_images)    
23     dims[0] = (mwSize)_height;      nlast_frame = nb_images-1;    
25     dims[0] = (mwSize)_height;      TIFFSetDirectory(tif,0);    
21     dims[0] = (mwSize)_height;      CImg<T> frame;    
60     dims[0] = (mwSize)_height;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
24     dims[0] = (mwSize)_height;      frame._load_tiff(tif,l);    
98     dims[0] = (mwSize)_height;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     dims[0] = (mwSize)_height;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     dims[0] = (mwSize)_height;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     dims[0] = (mwSize)_height;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
22     dims[0] = (mwSize)_height;      TIFFClose(tif);    
24     dims[0] = (mwSize)_height;      else    
32     dims[0] = (mwSize)_height;      throw CImgIOException(_cimg_instance    
42     dims[0] = (mwSize)_height;      "load_tiff(): Failed to read data from stream",    
21     dims[0] = (mwSize)_height;      cimg_instance);    
22     dims[0] = (mwSize)_height;      return *this;    
48     dims[0] = (mwSize)_height;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59     dims[0] = (mwSize)_height;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[0] = (mwSize)_height;      const unsigned int step_frame=1)    
67     dims[0] = (mwSize)_height;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
25     dims[0] = (mwSize)_height;     #endif    
27     dims[0] = (mwSize)_height;         


104 / 129

20     dims[1] = (mwSize)_width;     #ifndef cimg_use_tiff    
28     dims[1] = (mwSize)_width;     error cimg_use_tiff not defined    
24     dims[1] = (mwSize)_width;     #endif    
27     dims[1] = (mwSize)_width;     #ifndef cimg_plugin_tiff_stream    
27     dims[1] = (mwSize)_width;     #define cimg_plugin_tiff_stream    
23     dims[1] = (mwSize)_width;     #include <ios>    
88     dims[1] = (mwSize)_width;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     dims[1] = (mwSize)_width;      if (!tiffOutStream->good())    
37     dims[1] = (mwSize)_width;      throw CImgArgumentException(_cimg_instance    
34     dims[1] = (mwSize)_width;      "save_tiff(): tiffstream is not good!",    
20     dims[1] = (mwSize)_width;      cimg_instance);    
21     dims[1] = (mwSize)_width;      if (is_empty())    
37     dims[1] = (mwSize)_width;      throw CImgArgumentException(_cimg_instance    
40     dims[1] = (mwSize)_width;      "Not allowed to write empty images to stream",    
22     dims[1] = (mwSize)_width;      cimg_instance    
23     dims[1] = (mwSize)_width;      );    
45     dims[1] = (mwSize)_width;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
20     dims[1] = (mwSize)_width;      if (tif)    
56     dims[1] = (mwSize)_width;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     dims[1] = (mwSize)_width;      tiffOutStream->flush();    
21     dims[1] = (mwSize)_width;      TIFFClose(tif);    
23     dims[1] = (mwSize)_width;      else    
32     dims[1] = (mwSize)_width;      throw CImgIOException(_cimg_instance    
39     dims[1] = (mwSize)_width;      "save_tiff(): Failed to stream for writing.",    
20     dims[1] = (mwSize)_width;      cimg_instance);    
22     dims[1] = (mwSize)_width;      return *this;    
40     dims[1] = (mwSize)_width;     CImg<T>& load_tiff(std::istream* tiffInStream,    
60     dims[1] = (mwSize)_width;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[1] = (mwSize)_width;      const unsigned int step_frame=1)    
20     dims[1] = (mwSize)_width;      const unsigned int    
52     dims[1] = (mwSize)_width;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     dims[1] = (mwSize)_width;      nstep_frame = step_frame?step_frame:1;    
61     dims[1] = (mwSize)_width;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     dims[1] = (mwSize)_width;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
20     dims[1] = (mwSize)_width;      if (tif)    
24     dims[1] = (mwSize)_width;      unsigned int nb_images = 0;    
23     dims[1] = (mwSize)_width;      do     
22     dims[1] = (mwSize)_width;      ++nb_images;    
27     dims[1] = (mwSize)_width;       while (TIFFReadDirectory(tif));    
68     dims[1] = (mwSize)_width;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
101     dims[1] = (mwSize)_width;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     dims[1] = (mwSize)_width;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     dims[1] = (mwSize)_width;      if (nfirst_frame>=nb_images)    
22     dims[1] = (mwSize)_width;      return assign();    
26     dims[1] = (mwSize)_width;      if (nlast_frame>=nb_images)    
23     dims[1] = (mwSize)_width;      nlast_frame = nb_images-1;    
24     dims[1] = (mwSize)_width;      TIFFSetDirectory(tif,0);    
20     dims[1] = (mwSize)_width;      CImg<T> frame;    
60     dims[1] = (mwSize)_width;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23     dims[1] = (mwSize)_width;      frame._load_tiff(tif,l);    
101     dims[1] = (mwSize)_width;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     dims[1] = (mwSize)_width;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
105     dims[1] = (mwSize)_width;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     dims[1] = (mwSize)_width;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
21     dims[1] = (mwSize)_width;      TIFFClose(tif);    
23     dims[1] = (mwSize)_width;      else    
32     dims[1] = (mwSize)_width;      throw CImgIOException(_cimg_instance    
42     dims[1] = (mwSize)_width;      "load_tiff(): Failed to read data from stream",    
20     dims[1] = (mwSize)_width;      cimg_instance);    
22     dims[1] = (mwSize)_width;      return *this;    
48     dims[1] = (mwSize)_width;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     dims[1] = (mwSize)_width;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[1] = (mwSize)_width;      const unsigned int step_frame=1)    
67     dims[1] = (mwSize)_width;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
24     dims[1] = (mwSize)_width;     #endif    
26     dims[1] = (mwSize)_width;         


105 / 129

21     dims[2] = (mwSize)_depth;     #ifndef cimg_use_tiff    
27     dims[2] = (mwSize)_depth;     error cimg_use_tiff not defined    
24     dims[2] = (mwSize)_depth;     #endif    
28     dims[2] = (mwSize)_depth;     #ifndef cimg_plugin_tiff_stream    
27     dims[2] = (mwSize)_depth;     #define cimg_plugin_tiff_stream    
23     dims[2] = (mwSize)_depth;     #include <ios>    
88     dims[2] = (mwSize)_depth;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     dims[2] = (mwSize)_depth;      if (!tiffOutStream->good())    
38     dims[2] = (mwSize)_depth;      throw CImgArgumentException(_cimg_instance    
35     dims[2] = (mwSize)_depth;      "save_tiff(): tiffstream is not good!",    
20     dims[2] = (mwSize)_depth;      cimg_instance);    
20     dims[2] = (mwSize)_depth;      if (is_empty())    
38     dims[2] = (mwSize)_depth;      throw CImgArgumentException(_cimg_instance    
40     dims[2] = (mwSize)_depth;      "Not allowed to write empty images to stream",    
22     dims[2] = (mwSize)_depth;      cimg_instance    
23     dims[2] = (mwSize)_depth;      );    
45     dims[2] = (mwSize)_depth;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
20     dims[2] = (mwSize)_depth;      if (tif)    
55     dims[2] = (mwSize)_depth;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
23     dims[2] = (mwSize)_depth;      tiffOutStream->flush();    
21     dims[2] = (mwSize)_depth;      TIFFClose(tif);    
23     dims[2] = (mwSize)_depth;      else    
33     dims[2] = (mwSize)_depth;      throw CImgIOException(_cimg_instance    
40     dims[2] = (mwSize)_depth;      "save_tiff(): Failed to stream for writing.",    
20     dims[2] = (mwSize)_depth;      cimg_instance);    
22     dims[2] = (mwSize)_depth;      return *this;    
40     dims[2] = (mwSize)_depth;     CImg<T>& load_tiff(std::istream* tiffInStream,    
59     dims[2] = (mwSize)_depth;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[2] = (mwSize)_depth;      const unsigned int step_frame=1)    
21     dims[2] = (mwSize)_depth;      const unsigned int    
51     dims[2] = (mwSize)_depth;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     dims[2] = (mwSize)_depth;      nstep_frame = step_frame?step_frame:1;    
61     dims[2] = (mwSize)_depth;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     dims[2] = (mwSize)_depth;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
20     dims[2] = (mwSize)_depth;      if (tif)    
24     dims[2] = (mwSize)_depth;      unsigned int nb_images = 0;    
23     dims[2] = (mwSize)_depth;      do     
22     dims[2] = (mwSize)_depth;      ++nb_images;    
27     dims[2] = (mwSize)_depth;       while (TIFFReadDirectory(tif));    
68     dims[2] = (mwSize)_depth;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
100     dims[2] = (mwSize)_depth;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     dims[2] = (mwSize)_depth;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     dims[2] = (mwSize)_depth;      if (nfirst_frame>=nb_images)    
22     dims[2] = (mwSize)_depth;      return assign();    
26     dims[2] = (mwSize)_depth;      if (nlast_frame>=nb_images)    
22     dims[2] = (mwSize)_depth;      nlast_frame = nb_images-1;    
24     dims[2] = (mwSize)_depth;      TIFFSetDirectory(tif,0);    
20     dims[2] = (mwSize)_depth;      CImg<T> frame;    
60     dims[2] = (mwSize)_depth;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23     dims[2] = (mwSize)_depth;      frame._load_tiff(tif,l);    
99     dims[2] = (mwSize)_depth;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     dims[2] = (mwSize)_depth;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
104     dims[2] = (mwSize)_depth;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     dims[2] = (mwSize)_depth;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
21     dims[2] = (mwSize)_depth;      TIFFClose(tif);    
23     dims[2] = (mwSize)_depth;      else    
33     dims[2] = (mwSize)_depth;      throw CImgIOException(_cimg_instance    
41     dims[2] = (mwSize)_depth;      "load_tiff(): Failed to read data from stream",    
20     dims[2] = (mwSize)_depth;      cimg_instance);    
22     dims[2] = (mwSize)_depth;      return *this;    
49     dims[2] = (mwSize)_depth;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59     dims[2] = (mwSize)_depth;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     dims[2] = (mwSize)_depth;      const unsigned int step_frame=1)    
66     dims[2] = (mwSize)_depth;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
24     dims[2] = (mwSize)_depth;     #endif    
26     dims[2] = (mwSize)_depth;         


106 / 129

23     dims[3] = (mwSize)_spectrum;     #ifndef cimg_use_tiff    
30     dims[3] = (mwSize)_spectrum;     error cimg_use_tiff not defined    
28     dims[3] = (mwSize)_spectrum;     #endif    
27     dims[3] = (mwSize)_spectrum;     #ifndef cimg_plugin_tiff_stream    
26     dims[3] = (mwSize)_spectrum;     #define cimg_plugin_tiff_stream    
25     dims[3] = (mwSize)_spectrum;     #include <ios>    
87     dims[3] = (mwSize)_spectrum;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     dims[3] = (mwSize)_spectrum;      if (!tiffOutStream->good())    
38     dims[3] = (mwSize)_spectrum;      throw CImgArgumentException(_cimg_instance    
34     dims[3] = (mwSize)_spectrum;      "save_tiff(): tiffstream is not good!",    
23     dims[3] = (mwSize)_spectrum;      cimg_instance);    
22     dims[3] = (mwSize)_spectrum;      if (is_empty())    
38     dims[3] = (mwSize)_spectrum;      throw CImgArgumentException(_cimg_instance    
37     dims[3] = (mwSize)_spectrum;      "Not allowed to write empty images to stream",    
23     dims[3] = (mwSize)_spectrum;      cimg_instance    
26     dims[3] = (mwSize)_spectrum;      );    
42     dims[3] = (mwSize)_spectrum;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23     dims[3] = (mwSize)_spectrum;      if (tif)    
54     dims[3] = (mwSize)_spectrum;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     dims[3] = (mwSize)_spectrum;      tiffOutStream->flush();    
24     dims[3] = (mwSize)_spectrum;      TIFFClose(tif);    
25     dims[3] = (mwSize)_spectrum;      else    
33     dims[3] = (mwSize)_spectrum;      throw CImgIOException(_cimg_instance    
39     dims[3] = (mwSize)_spectrum;      "save_tiff(): Failed to stream for writing.",    
23     dims[3] = (mwSize)_spectrum;      cimg_instance);    
24     dims[3] = (mwSize)_spectrum;      return *this;    
39     dims[3] = (mwSize)_spectrum;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     dims[3] = (mwSize)_spectrum;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[3] = (mwSize)_spectrum;      const unsigned int step_frame=1)    
24     dims[3] = (mwSize)_spectrum;      const unsigned int    
49     dims[3] = (mwSize)_spectrum;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     dims[3] = (mwSize)_spectrum;      nstep_frame = step_frame?step_frame:1;    
59     dims[3] = (mwSize)_spectrum;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
41     dims[3] = (mwSize)_spectrum;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23     dims[3] = (mwSize)_spectrum;      if (tif)    
24     dims[3] = (mwSize)_spectrum;      unsigned int nb_images = 0;    
26     dims[3] = (mwSize)_spectrum;      do     
24     dims[3] = (mwSize)_spectrum;      ++nb_images;    
27     dims[3] = (mwSize)_spectrum;       while (TIFFReadDirectory(tif));    
67     dims[3] = (mwSize)_spectrum;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     dims[3] = (mwSize)_spectrum;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     dims[3] = (mwSize)_spectrum;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27     dims[3] = (mwSize)_spectrum;      if (nfirst_frame>=nb_images)    
25     dims[3] = (mwSize)_spectrum;      return assign();    
27     dims[3] = (mwSize)_spectrum;      if (nlast_frame>=nb_images)    
24     dims[3] = (mwSize)_spectrum;      nlast_frame = nb_images-1;    
26     dims[3] = (mwSize)_spectrum;      TIFFSetDirectory(tif,0);    
23     dims[3] = (mwSize)_spectrum;      CImg<T> frame;    
58     dims[3] = (mwSize)_spectrum;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
26     dims[3] = (mwSize)_spectrum;      frame._load_tiff(tif,l);    
94     dims[3] = (mwSize)_spectrum;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
62     dims[3] = (mwSize)_spectrum;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     dims[3] = (mwSize)_spectrum;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
38     dims[3] = (mwSize)_spectrum;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24     dims[3] = (mwSize)_spectrum;      TIFFClose(tif);    
25     dims[3] = (mwSize)_spectrum;      else    
33     dims[3] = (mwSize)_spectrum;      throw CImgIOException(_cimg_instance    
40     dims[3] = (mwSize)_spectrum;      "load_tiff(): Failed to read data from stream",    
23     dims[3] = (mwSize)_spectrum;      cimg_instance);    
24     dims[3] = (mwSize)_spectrum;      return *this;    
47     dims[3] = (mwSize)_spectrum;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     dims[3] = (mwSize)_spectrum;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[3] = (mwSize)_spectrum;      const unsigned int step_frame=1)    
64     dims[3] = (mwSize)_spectrum;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
28     dims[3] = (mwSize)_spectrum;     #endif    
29     dims[3] = (mwSize)_spectrum;         


107 / 129

24     if (squeeze && _depth == 1)      #ifndef cimg_use_tiff    
28     if (squeeze && _depth == 1)      error cimg_use_tiff not defined    
27     if (squeeze && _depth == 1)      #endif    
28     if (squeeze && _depth == 1)      #ifndef cimg_plugin_tiff_stream    
30     if (squeeze && _depth == 1)      #define cimg_plugin_tiff_stream    
24     if (squeeze && _depth == 1)      #include <ios>    
84     if (squeeze && _depth == 1)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
23     if (squeeze && _depth == 1)       if (!tiffOutStream->good())    
37     if (squeeze && _depth == 1)       throw CImgArgumentException(_cimg_instance    
34     if (squeeze && _depth == 1)       "save_tiff(): tiffstream is not good!",    
25     if (squeeze && _depth == 1)       cimg_instance);    
20     if (squeeze && _depth == 1)       if (is_empty())    
37     if (squeeze && _depth == 1)       throw CImgArgumentException(_cimg_instance    
37     if (squeeze && _depth == 1)       "Not allowed to write empty images to stream",    
26     if (squeeze && _depth == 1)       cimg_instance    
27     if (squeeze && _depth == 1)       );    
44     if (squeeze && _depth == 1)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
22     if (squeeze && _depth == 1)       if (tif)    
57     if (squeeze && _depth == 1)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
24     if (squeeze && _depth == 1)       tiffOutStream->flush();    
25     if (squeeze && _depth == 1)       TIFFClose(tif);    
26     if (squeeze && _depth == 1)       else    
33     if (squeeze && _depth == 1)       throw CImgIOException(_cimg_instance    
37     if (squeeze && _depth == 1)       "save_tiff(): Failed to stream for writing.",    
25     if (squeeze && _depth == 1)       cimg_instance);    
24     if (squeeze && _depth == 1)       return *this;    
39     if (squeeze && _depth == 1)      CImg<T>& load_tiff(std::istream* tiffInStream,    
59     if (squeeze && _depth == 1)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     if (squeeze && _depth == 1)       const unsigned int step_frame=1)    
25     if (squeeze && _depth == 1)       const unsigned int    
53     if (squeeze && _depth == 1)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
33     if (squeeze && _depth == 1)       nstep_frame = step_frame?step_frame:1;    
65     if (squeeze && _depth == 1)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     if (squeeze && _depth == 1)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
22     if (squeeze && _depth == 1)       if (tif)    
24     if (squeeze && _depth == 1)       unsigned int nb_images = 0;    
26     if (squeeze && _depth == 1)       do     
27     if (squeeze && _depth == 1)       ++nb_images;    
27     if (squeeze && _depth == 1)        while (TIFFReadDirectory(tif));    
61     if (squeeze && _depth == 1)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     if (squeeze && _depth == 1)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     if (squeeze && _depth == 1)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     if (squeeze && _depth == 1)       if (nfirst_frame>=nb_images)    
25     if (squeeze && _depth == 1)       return assign();    
23     if (squeeze && _depth == 1)       if (nlast_frame>=nb_images)    
24     if (squeeze && _depth == 1)       nlast_frame = nb_images-1;    
25     if (squeeze && _depth == 1)       TIFFSetDirectory(tif,0);    
26     if (squeeze && _depth == 1)       CImg<T> frame;    
55     if (squeeze && _depth == 1)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
24     if (squeeze && _depth == 1)       frame._load_tiff(tif,l);    
100     if (squeeze && _depth == 1)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     if (squeeze && _depth == 1)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
105     if (squeeze && _depth == 1)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
45     if (squeeze && _depth == 1)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
25     if (squeeze && _depth == 1)       TIFFClose(tif);    
26     if (squeeze && _depth == 1)       else    
33     if (squeeze && _depth == 1)       throw CImgIOException(_cimg_instance    
37     if (squeeze && _depth == 1)       "load_tiff(): Failed to read data from stream",    
25     if (squeeze && _depth == 1)       cimg_instance);    
24     if (squeeze && _depth == 1)       return *this;    
49     if (squeeze && _depth == 1)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
59     if (squeeze && _depth == 1)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     if (squeeze && _depth == 1)       const unsigned int step_frame=1)    
66     if (squeeze && _depth == 1)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
27     if (squeeze && _depth == 1)      #endif    
29     if (squeeze && _depth == 1)          


108 / 129

23     dims[2] = (mwSize)_spectrum;     #ifndef cimg_use_tiff    
30     dims[2] = (mwSize)_spectrum;     error cimg_use_tiff not defined    
28     dims[2] = (mwSize)_spectrum;     #endif    
27     dims[2] = (mwSize)_spectrum;     #ifndef cimg_plugin_tiff_stream    
26     dims[2] = (mwSize)_spectrum;     #define cimg_plugin_tiff_stream    
25     dims[2] = (mwSize)_spectrum;     #include <ios>    
87     dims[2] = (mwSize)_spectrum;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     dims[2] = (mwSize)_spectrum;      if (!tiffOutStream->good())    
38     dims[2] = (mwSize)_spectrum;      throw CImgArgumentException(_cimg_instance    
34     dims[2] = (mwSize)_spectrum;      "save_tiff(): tiffstream is not good!",    
23     dims[2] = (mwSize)_spectrum;      cimg_instance);    
22     dims[2] = (mwSize)_spectrum;      if (is_empty())    
38     dims[2] = (mwSize)_spectrum;      throw CImgArgumentException(_cimg_instance    
37     dims[2] = (mwSize)_spectrum;      "Not allowed to write empty images to stream",    
23     dims[2] = (mwSize)_spectrum;      cimg_instance    
26     dims[2] = (mwSize)_spectrum;      );    
42     dims[2] = (mwSize)_spectrum;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
23     dims[2] = (mwSize)_spectrum;      if (tif)    
54     dims[2] = (mwSize)_spectrum;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     dims[2] = (mwSize)_spectrum;      tiffOutStream->flush();    
24     dims[2] = (mwSize)_spectrum;      TIFFClose(tif);    
25     dims[2] = (mwSize)_spectrum;      else    
33     dims[2] = (mwSize)_spectrum;      throw CImgIOException(_cimg_instance    
39     dims[2] = (mwSize)_spectrum;      "save_tiff(): Failed to stream for writing.",    
23     dims[2] = (mwSize)_spectrum;      cimg_instance);    
24     dims[2] = (mwSize)_spectrum;      return *this;    
39     dims[2] = (mwSize)_spectrum;     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     dims[2] = (mwSize)_spectrum;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[2] = (mwSize)_spectrum;      const unsigned int step_frame=1)    
24     dims[2] = (mwSize)_spectrum;      const unsigned int    
49     dims[2] = (mwSize)_spectrum;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     dims[2] = (mwSize)_spectrum;      nstep_frame = step_frame?step_frame:1;    
59     dims[2] = (mwSize)_spectrum;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
41     dims[2] = (mwSize)_spectrum;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
23     dims[2] = (mwSize)_spectrum;      if (tif)    
24     dims[2] = (mwSize)_spectrum;      unsigned int nb_images = 0;    
26     dims[2] = (mwSize)_spectrum;      do     
24     dims[2] = (mwSize)_spectrum;      ++nb_images;    
27     dims[2] = (mwSize)_spectrum;       while (TIFFReadDirectory(tif));    
67     dims[2] = (mwSize)_spectrum;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     dims[2] = (mwSize)_spectrum;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     dims[2] = (mwSize)_spectrum;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27     dims[2] = (mwSize)_spectrum;      if (nfirst_frame>=nb_images)    
25     dims[2] = (mwSize)_spectrum;      return assign();    
27     dims[2] = (mwSize)_spectrum;      if (nlast_frame>=nb_images)    
24     dims[2] = (mwSize)_spectrum;      nlast_frame = nb_images-1;    
26     dims[2] = (mwSize)_spectrum;      TIFFSetDirectory(tif,0);    
23     dims[2] = (mwSize)_spectrum;      CImg<T> frame;    
58     dims[2] = (mwSize)_spectrum;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
26     dims[2] = (mwSize)_spectrum;      frame._load_tiff(tif,l);    
94     dims[2] = (mwSize)_spectrum;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
62     dims[2] = (mwSize)_spectrum;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     dims[2] = (mwSize)_spectrum;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
38     dims[2] = (mwSize)_spectrum;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
24     dims[2] = (mwSize)_spectrum;      TIFFClose(tif);    
25     dims[2] = (mwSize)_spectrum;      else    
33     dims[2] = (mwSize)_spectrum;      throw CImgIOException(_cimg_instance    
40     dims[2] = (mwSize)_spectrum;      "load_tiff(): Failed to read data from stream",    
23     dims[2] = (mwSize)_spectrum;      cimg_instance);    
24     dims[2] = (mwSize)_spectrum;      return *this;    
47     dims[2] = (mwSize)_spectrum;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     dims[2] = (mwSize)_spectrum;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[2] = (mwSize)_spectrum;      const unsigned int step_frame=1)    
64     dims[2] = (mwSize)_spectrum;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
28     dims[2] = (mwSize)_spectrum;     #endif    
29     dims[2] = (mwSize)_spectrum;         


109 / 129

19     dims[3] = (mwSize)1;     #ifndef cimg_use_tiff    
26     dims[3] = (mwSize)1;     error cimg_use_tiff not defined    
20     dims[3] = (mwSize)1;     #endif    
28     dims[3] = (mwSize)1;     #ifndef cimg_plugin_tiff_stream    
28     dims[3] = (mwSize)1;     #define cimg_plugin_tiff_stream    
18     dims[3] = (mwSize)1;     #include <ios>    
88     dims[3] = (mwSize)1;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     dims[3] = (mwSize)1;      if (!tiffOutStream->good())    
38     dims[3] = (mwSize)1;      throw CImgArgumentException(_cimg_instance    
35     dims[3] = (mwSize)1;      "save_tiff(): tiffstream is not good!",    
15     dims[3] = (mwSize)1;      cimg_instance);    
17     dims[3] = (mwSize)1;      if (is_empty())    
38     dims[3] = (mwSize)1;      throw CImgArgumentException(_cimg_instance    
41     dims[3] = (mwSize)1;      "Not allowed to write empty images to stream",    
17     dims[3] = (mwSize)1;      cimg_instance    
18     dims[3] = (mwSize)1;      );    
45     dims[3] = (mwSize)1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
15     dims[3] = (mwSize)1;      if (tif)    
58     dims[3] = (mwSize)1;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     dims[3] = (mwSize)1;      tiffOutStream->flush();    
16     dims[3] = (mwSize)1;      TIFFClose(tif);    
18     dims[3] = (mwSize)1;      else    
32     dims[3] = (mwSize)1;      throw CImgIOException(_cimg_instance    
39     dims[3] = (mwSize)1;      "save_tiff(): Failed to stream for writing.",    
15     dims[3] = (mwSize)1;      cimg_instance);    
17     dims[3] = (mwSize)1;      return *this;    
39     dims[3] = (mwSize)1;     CImg<T>& load_tiff(std::istream* tiffInStream,    
61     dims[3] = (mwSize)1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[3] = (mwSize)1;      const unsigned int step_frame=1)    
18     dims[3] = (mwSize)1;      const unsigned int    
53     dims[3] = (mwSize)1;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     dims[3] = (mwSize)1;      nstep_frame = step_frame?step_frame:1;    
64     dims[3] = (mwSize)1;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     dims[3] = (mwSize)1;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
15     dims[3] = (mwSize)1;      if (tif)    
23     dims[3] = (mwSize)1;      unsigned int nb_images = 0;    
18     dims[3] = (mwSize)1;      do     
17     dims[3] = (mwSize)1;      ++nb_images;    
27     dims[3] = (mwSize)1;       while (TIFFReadDirectory(tif));    
67     dims[3] = (mwSize)1;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
100     dims[3] = (mwSize)1;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     dims[3] = (mwSize)1;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
25     dims[3] = (mwSize)1;      if (nfirst_frame>=nb_images)    
17     dims[3] = (mwSize)1;      return assign();    
25     dims[3] = (mwSize)1;      if (nlast_frame>=nb_images)    
19     dims[3] = (mwSize)1;      nlast_frame = nb_images-1;    
22     dims[3] = (mwSize)1;      TIFFSetDirectory(tif,0);    
15     dims[3] = (mwSize)1;      CImg<T> frame;    
61     dims[3] = (mwSize)1;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
21     dims[3] = (mwSize)1;      frame._load_tiff(tif,l);    
103     dims[3] = (mwSize)1;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
71     dims[3] = (mwSize)1;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
107     dims[3] = (mwSize)1;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
43     dims[3] = (mwSize)1;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16     dims[3] = (mwSize)1;      TIFFClose(tif);    
18     dims[3] = (mwSize)1;      else    
32     dims[3] = (mwSize)1;      throw CImgIOException(_cimg_instance    
41     dims[3] = (mwSize)1;      "load_tiff(): Failed to read data from stream",    
15     dims[3] = (mwSize)1;      cimg_instance);    
17     dims[3] = (mwSize)1;      return *this;    
49     dims[3] = (mwSize)1;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
61     dims[3] = (mwSize)1;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
27     dims[3] = (mwSize)1;      const unsigned int step_frame=1)    
68     dims[3] = (mwSize)1;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
20     dims[3] = (mwSize)1;     #endif    
21     dims[3] = (mwSize)1;         


110 / 129

71     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #ifndef cimg_use_tiff    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     error cimg_use_tiff not defined    
73     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #endif    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #ifndef cimg_plugin_tiff_stream    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #define cimg_plugin_tiff_stream    
71     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #include <ios>    
85     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (!tiffOutStream->good())    
62     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      throw CImgArgumentException(_cimg_instance    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      "save_tiff(): tiffstream is not good!",    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg_instance);    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (is_empty())    
62     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      throw CImgArgumentException(_cimg_instance    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      "Not allowed to write empty images to stream",    
70     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg_instance    
73     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      );    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
71     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (tif)    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      tiffOutStream->flush();    
69     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      TIFFClose(tif);    
72     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      else    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      throw CImgIOException(_cimg_instance    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      "save_tiff(): Failed to stream for writing.",    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg_instance);    
67     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      return *this;    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     CImg<T>& load_tiff(std::istream* tiffInStream,    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      const unsigned int step_frame=1)    
69     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      const unsigned int    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      nstep_frame = step_frame?step_frame:1;    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
71     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (tif)    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      unsigned int nb_images = 0;    
74     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      do     
69     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      ++nb_images;    
61     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);       while (TIFFReadDirectory(tif));    
71     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
60     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (nfirst_frame>=nb_images)    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      return assign();    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (nlast_frame>=nb_images)    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      nlast_frame = nb_images-1;    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      TIFFSetDirectory(tif,0);    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      CImg<T> frame;    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
63     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      frame._load_tiff(tif,l);    
93     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
97     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
60     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
69     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      TIFFClose(tif);    
72     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      else    
64     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      throw CImgIOException(_cimg_instance    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      "load_tiff(): Failed to read data from stream",    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      cimg_instance);    
67     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      return *this;    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
65     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
66     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      const unsigned int step_frame=1)    
68     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
73     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);     #endif    
76     mxArray *matlabArray = mxCreateNumericArray((mwSize)4,dims,classID,mxREAL);         


111 / 129

27     if (classID==mxLOGICAL_CLASS)      #ifndef cimg_use_tiff    
31     if (classID==mxLOGICAL_CLASS)      error cimg_use_tiff not defined    
31     if (classID==mxLOGICAL_CLASS)      #endif    
29     if (classID==mxLOGICAL_CLASS)      #ifndef cimg_plugin_tiff_stream    
30     if (classID==mxLOGICAL_CLASS)      #define cimg_plugin_tiff_stream    
28     if (classID==mxLOGICAL_CLASS)      #include <ios>    
88     if (classID==mxLOGICAL_CLASS)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     if (classID==mxLOGICAL_CLASS)       if (!tiffOutStream->good())    
39     if (classID==mxLOGICAL_CLASS)       throw CImgArgumentException(_cimg_instance    
35     if (classID==mxLOGICAL_CLASS)       "save_tiff(): tiffstream is not good!",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
23     if (classID==mxLOGICAL_CLASS)       if (is_empty())    
39     if (classID==mxLOGICAL_CLASS)       throw CImgArgumentException(_cimg_instance    
43     if (classID==mxLOGICAL_CLASS)       "Not allowed to write empty images to stream",    
28     if (classID==mxLOGICAL_CLASS)       cimg_instance    
29     if (classID==mxLOGICAL_CLASS)       );    
46     if (classID==mxLOGICAL_CLASS)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
25     if (classID==mxLOGICAL_CLASS)       if (tif)    
60     if (classID==mxLOGICAL_CLASS)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
27     if (classID==mxLOGICAL_CLASS)       tiffOutStream->flush();    
27     if (classID==mxLOGICAL_CLASS)       TIFFClose(tif);    
28     if (classID==mxLOGICAL_CLASS)       else    
34     if (classID==mxLOGICAL_CLASS)       throw CImgIOException(_cimg_instance    
40     if (classID==mxLOGICAL_CLASS)       "save_tiff(): Failed to stream for writing.",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
30     if (classID==mxLOGICAL_CLASS)       return *this;    
41     if (classID==mxLOGICAL_CLASS)      CImg<T>& load_tiff(std::istream* tiffInStream,    
62     if (classID==mxLOGICAL_CLASS)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30     if (classID==mxLOGICAL_CLASS)       const unsigned int step_frame=1)    
28     if (classID==mxLOGICAL_CLASS)       const unsigned int    
54     if (classID==mxLOGICAL_CLASS)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
35     if (classID==mxLOGICAL_CLASS)       nstep_frame = step_frame?step_frame:1;    
65     if (classID==mxLOGICAL_CLASS)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
45     if (classID==mxLOGICAL_CLASS)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
25     if (classID==mxLOGICAL_CLASS)       if (tif)    
30     if (classID==mxLOGICAL_CLASS)       unsigned int nb_images = 0;    
29     if (classID==mxLOGICAL_CLASS)       do     
29     if (classID==mxLOGICAL_CLASS)       ++nb_images;    
30     if (classID==mxLOGICAL_CLASS)        while (TIFFReadDirectory(tif));    
66     if (classID==mxLOGICAL_CLASS)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103     if (classID==mxLOGICAL_CLASS)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
40     if (classID==mxLOGICAL_CLASS)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
24     if (classID==mxLOGICAL_CLASS)       if (nfirst_frame>=nb_images)    
27     if (classID==mxLOGICAL_CLASS)       return assign();    
21     if (classID==mxLOGICAL_CLASS)       if (nlast_frame>=nb_images)    
26     if (classID==mxLOGICAL_CLASS)       nlast_frame = nb_images-1;    
28     if (classID==mxLOGICAL_CLASS)       TIFFSetDirectory(tif,0);    
28     if (classID==mxLOGICAL_CLASS)       CImg<T> frame;    
58     if (classID==mxLOGICAL_CLASS)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
27     if (classID==mxLOGICAL_CLASS)       frame._load_tiff(tif,l);    
102     if (classID==mxLOGICAL_CLASS)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     if (classID==mxLOGICAL_CLASS)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
108     if (classID==mxLOGICAL_CLASS)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     if (classID==mxLOGICAL_CLASS)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
27     if (classID==mxLOGICAL_CLASS)       TIFFClose(tif);    
28     if (classID==mxLOGICAL_CLASS)       else    
34     if (classID==mxLOGICAL_CLASS)       throw CImgIOException(_cimg_instance    
42     if (classID==mxLOGICAL_CLASS)       "load_tiff(): Failed to read data from stream",    
27     if (classID==mxLOGICAL_CLASS)       cimg_instance);    
30     if (classID==mxLOGICAL_CLASS)       return *this;    
50     if (classID==mxLOGICAL_CLASS)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     if (classID==mxLOGICAL_CLASS)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
30     if (classID==mxLOGICAL_CLASS)       const unsigned int step_frame=1)    
67     if (classID==mxLOGICAL_CLASS)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
31     if (classID==mxLOGICAL_CLASS)      #endif    
31     if (classID==mxLOGICAL_CLASS)          


112 / 129

40     mxLogical *mdata = mxGetLogicals(matlabArray);     #ifndef cimg_use_tiff    
41     mxLogical *mdata = mxGetLogicals(matlabArray);     error cimg_use_tiff not defined    
45     mxLogical *mdata = mxGetLogicals(matlabArray);     #endif    
39     mxLogical *mdata = mxGetLogicals(matlabArray);     #ifndef cimg_plugin_tiff_stream    
39     mxLogical *mdata = mxGetLogicals(matlabArray);     #define cimg_plugin_tiff_stream    
41     mxLogical *mdata = mxGetLogicals(matlabArray);     #include <ios>    
84     mxLogical *mdata = mxGetLogicals(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
39     mxLogical *mdata = mxGetLogicals(matlabArray);      if (!tiffOutStream->good())    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgArgumentException(_cimg_instance    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      "save_tiff(): tiffstream is not good!",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      if (is_empty())    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgArgumentException(_cimg_instance    
37     mxLogical *mdata = mxGetLogicals(matlabArray);      "Not allowed to write empty images to stream",    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      );    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      if (tif)    
56     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      tiffOutStream->flush();    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFClose(tif);    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      else    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgIOException(_cimg_instance    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      "save_tiff(): Failed to stream for writing.",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return *this;    
42     mxLogical *mdata = mxGetLogicals(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int step_frame=1)    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int    
50     mxLogical *mdata = mxGetLogicals(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      nstep_frame = step_frame?step_frame:1;    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      if (tif)    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      unsigned int nb_images = 0;    
44     mxLogical *mdata = mxGetLogicals(matlabArray);      do     
40     mxLogical *mdata = mxGetLogicals(matlabArray);      ++nb_images;    
38     mxLogical *mdata = mxGetLogicals(matlabArray);       while (TIFFReadDirectory(tif));    
63     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
93     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     mxLogical *mdata = mxGetLogicals(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nfirst_frame>=nb_images)    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return assign();    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      if (nlast_frame>=nb_images)    
37     mxLogical *mdata = mxGetLogicals(matlabArray);      nlast_frame = nb_images-1;    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFSetDirectory(tif,0);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      CImg<T> frame;    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
38     mxLogical *mdata = mxGetLogicals(matlabArray);      frame._load_tiff(tif,l);    
96     mxLogical *mdata = mxGetLogicals(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
65     mxLogical *mdata = mxGetLogicals(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     mxLogical *mdata = mxGetLogicals(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     mxLogical *mdata = mxGetLogicals(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      TIFFClose(tif);    
43     mxLogical *mdata = mxGetLogicals(matlabArray);      else    
39     mxLogical *mdata = mxGetLogicals(matlabArray);      throw CImgIOException(_cimg_instance    
42     mxLogical *mdata = mxGetLogicals(matlabArray);      "load_tiff(): Failed to read data from stream",    
38     mxLogical *mdata = mxGetLogicals(matlabArray);      cimg_instance);    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      return *this;    
49     mxLogical *mdata = mxGetLogicals(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
55     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
40     mxLogical *mdata = mxGetLogicals(matlabArray);      const unsigned int step_frame=1)    
62     mxLogical *mdata = mxGetLogicals(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
45     mxLogical *mdata = mxGetLogicals(matlabArray);     #endif    
47     mxLogical *mdata = mxGetLogicals(matlabArray);         


113 / 129

28     populate_maltlab_array(mdata);     #ifndef cimg_use_tiff    
30     populate_maltlab_array(mdata);     error cimg_use_tiff not defined    
29     populate_maltlab_array(mdata);     #endif    
29     populate_maltlab_array(mdata);     #ifndef cimg_plugin_tiff_stream    
29     populate_maltlab_array(mdata);     #define cimg_plugin_tiff_stream    
29     populate_maltlab_array(mdata);     #include <ios>    
88     populate_maltlab_array(mdata);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25     populate_maltlab_array(mdata);      if (!tiffOutStream->good())    
35     populate_maltlab_array(mdata);      throw CImgArgumentException(_cimg_instance    
34     populate_maltlab_array(mdata);      "save_tiff(): tiffstream is not good!",    
25     populate_maltlab_array(mdata);      cimg_instance);    
24     populate_maltlab_array(mdata);      if (is_empty())    
35     populate_maltlab_array(mdata);      throw CImgArgumentException(_cimg_instance    
38     populate_maltlab_array(mdata);      "Not allowed to write empty images to stream",    
27     populate_maltlab_array(mdata);      cimg_instance    
28     populate_maltlab_array(mdata);      );    
44     populate_maltlab_array(mdata);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
28     populate_maltlab_array(mdata);      if (tif)    
56     populate_maltlab_array(mdata);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
25     populate_maltlab_array(mdata);      tiffOutStream->flush();    
26     populate_maltlab_array(mdata);      TIFFClose(tif);    
28     populate_maltlab_array(mdata);      else    
32     populate_maltlab_array(mdata);      throw CImgIOException(_cimg_instance    
39     populate_maltlab_array(mdata);      "save_tiff(): Failed to stream for writing.",    
25     populate_maltlab_array(mdata);      cimg_instance);    
26     populate_maltlab_array(mdata);      return *this;    
38     populate_maltlab_array(mdata);     CImg<T>& load_tiff(std::istream* tiffInStream,    
58     populate_maltlab_array(mdata);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     populate_maltlab_array(mdata);      const unsigned int step_frame=1)    
27     populate_maltlab_array(mdata);      const unsigned int    
47     populate_maltlab_array(mdata);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
31     populate_maltlab_array(mdata);      nstep_frame = step_frame?step_frame:1;    
58     populate_maltlab_array(mdata);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
43     populate_maltlab_array(mdata);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
28     populate_maltlab_array(mdata);      if (tif)    
24     populate_maltlab_array(mdata);      unsigned int nb_images = 0;    
29     populate_maltlab_array(mdata);      do     
25     populate_maltlab_array(mdata);      ++nb_images;    
26     populate_maltlab_array(mdata);       while (TIFFReadDirectory(tif));    
63     populate_maltlab_array(mdata);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
99     populate_maltlab_array(mdata);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
38     populate_maltlab_array(mdata);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
27     populate_maltlab_array(mdata);      if (nfirst_frame>=nb_images)    
25     populate_maltlab_array(mdata);      return assign();    
25     populate_maltlab_array(mdata);      if (nlast_frame>=nb_images)    
25     populate_maltlab_array(mdata);      nlast_frame = nb_images-1;    
23     populate_maltlab_array(mdata);      TIFFSetDirectory(tif,0);    
25     populate_maltlab_array(mdata);      CImg<T> frame;    
55     populate_maltlab_array(mdata);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
22     populate_maltlab_array(mdata);      frame._load_tiff(tif,l);    
95     populate_maltlab_array(mdata);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
68     populate_maltlab_array(mdata);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
102     populate_maltlab_array(mdata);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     populate_maltlab_array(mdata);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
26     populate_maltlab_array(mdata);      TIFFClose(tif);    
28     populate_maltlab_array(mdata);      else    
32     populate_maltlab_array(mdata);      throw CImgIOException(_cimg_instance    
38     populate_maltlab_array(mdata);      "load_tiff(): Failed to read data from stream",    
25     populate_maltlab_array(mdata);      cimg_instance);    
26     populate_maltlab_array(mdata);      return *this;    
47     populate_maltlab_array(mdata);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
58     populate_maltlab_array(mdata);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     populate_maltlab_array(mdata);      const unsigned int step_frame=1)    
61     populate_maltlab_array(mdata);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
29     populate_maltlab_array(mdata);     #endif    
31     populate_maltlab_array(mdata);         


114 / 129

18      else      #ifndef cimg_use_tiff    
27      else      error cimg_use_tiff not defined    
6      else      #endif    
27      else      #ifndef cimg_plugin_tiff_stream    
27      else      #define cimg_plugin_tiff_stream    
11      else      #include <ios>    
93      else      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
25      else       if (!tiffOutStream->good())    
39      else       throw CImgArgumentException(_cimg_instance    
35      else       "save_tiff(): tiffstream is not good!",    
13      else       cimg_instance);    
12      else       if (is_empty())    
39      else       throw CImgArgumentException(_cimg_instance    
42      else       "Not allowed to write empty images to stream",    
12      else       cimg_instance    
6      else       );    
49      else       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
7      else       if (tif)    
62      else       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20      else       tiffOutStream->flush();    
12      else       TIFFClose(tif);    
2      else       else    


115 / 129

31     void *mdata = mxGetPr(matlabArray);     #ifndef cimg_use_tiff    
34     void *mdata = mxGetPr(matlabArray);     error cimg_use_tiff not defined    
35     void *mdata = mxGetPr(matlabArray);     #endif    
31     void *mdata = mxGetPr(matlabArray);     #ifndef cimg_plugin_tiff_stream    
32     void *mdata = mxGetPr(matlabArray);     #define cimg_plugin_tiff_stream    
33     void *mdata = mxGetPr(matlabArray);     #include <ios>    
84     void *mdata = mxGetPr(matlabArray);     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
28     void *mdata = mxGetPr(matlabArray);      if (!tiffOutStream->good())    
35     void *mdata = mxGetPr(matlabArray);      throw CImgArgumentException(_cimg_instance    
36     void *mdata = mxGetPr(matlabArray);      "save_tiff(): tiffstream is not good!",    
29     void *mdata = mxGetPr(matlabArray);      cimg_instance);    
29     void *mdata = mxGetPr(matlabArray);      if (is_empty())    
35     void *mdata = mxGetPr(matlabArray);      throw CImgArgumentException(_cimg_instance    
35     void *mdata = mxGetPr(matlabArray);      "Not allowed to write empty images to stream",    
31     void *mdata = mxGetPr(matlabArray);      cimg_instance    
33     void *mdata = mxGetPr(matlabArray);      );    
42     void *mdata = mxGetPr(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
30     void *mdata = mxGetPr(matlabArray);      if (tif)    
57     void *mdata = mxGetPr(matlabArray);      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
28     void *mdata = mxGetPr(matlabArray);      tiffOutStream->flush();    
30     void *mdata = mxGetPr(matlabArray);      TIFFClose(tif);    
33     void *mdata = mxGetPr(matlabArray);      else    
33     void *mdata = mxGetPr(matlabArray);      throw CImgIOException(_cimg_instance    
38     void *mdata = mxGetPr(matlabArray);      "save_tiff(): Failed to stream for writing.",    
29     void *mdata = mxGetPr(matlabArray);      cimg_instance);    
30     void *mdata = mxGetPr(matlabArray);      return *this;    
39     void *mdata = mxGetPr(matlabArray);     CImg<T>& load_tiff(std::istream* tiffInStream,    
54     void *mdata = mxGetPr(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     void *mdata = mxGetPr(matlabArray);      const unsigned int step_frame=1)    
31     void *mdata = mxGetPr(matlabArray);      const unsigned int    
47     void *mdata = mxGetPr(matlabArray);      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
29     void *mdata = mxGetPr(matlabArray);      nstep_frame = step_frame?step_frame:1;    
53     void *mdata = mxGetPr(matlabArray);      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
41     void *mdata = mxGetPr(matlabArray);      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
30     void *mdata = mxGetPr(matlabArray);      if (tif)    
30     void *mdata = mxGetPr(matlabArray);      unsigned int nb_images = 0;    
33     void *mdata = mxGetPr(matlabArray);      do     
31     void *mdata = mxGetPr(matlabArray);      ++nb_images;    
30     void *mdata = mxGetPr(matlabArray);       while (TIFFReadDirectory(tif));    
62     void *mdata = mxGetPr(matlabArray);      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
97     void *mdata = mxGetPr(matlabArray);      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
37     void *mdata = mxGetPr(matlabArray);      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
30     void *mdata = mxGetPr(matlabArray);      if (nfirst_frame>=nb_images)    
29     void *mdata = mxGetPr(matlabArray);      return assign();    
28     void *mdata = mxGetPr(matlabArray);      if (nlast_frame>=nb_images)    
28     void *mdata = mxGetPr(matlabArray);      nlast_frame = nb_images-1;    
29     void *mdata = mxGetPr(matlabArray);      TIFFSetDirectory(tif,0);    
30     void *mdata = mxGetPr(matlabArray);      CImg<T> frame;    
53     void *mdata = mxGetPr(matlabArray);      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
30     void *mdata = mxGetPr(matlabArray);      frame._load_tiff(tif,l);    
96     void *mdata = mxGetPr(matlabArray);      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
66     void *mdata = mxGetPr(matlabArray);      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
101     void *mdata = mxGetPr(matlabArray);      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
41     void *mdata = mxGetPr(matlabArray);      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
30     void *mdata = mxGetPr(matlabArray);      TIFFClose(tif);    
33     void *mdata = mxGetPr(matlabArray);      else    
33     void *mdata = mxGetPr(matlabArray);      throw CImgIOException(_cimg_instance    
37     void *mdata = mxGetPr(matlabArray);      "load_tiff(): Failed to read data from stream",    
29     void *mdata = mxGetPr(matlabArray);      cimg_instance);    
30     void *mdata = mxGetPr(matlabArray);      return *this;    
46     void *mdata = mxGetPr(matlabArray);     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
54     void *mdata = mxGetPr(matlabArray);      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
31     void *mdata = mxGetPr(matlabArray);      const unsigned int step_frame=1)    
60     void *mdata = mxGetPr(matlabArray);      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
35     void *mdata = mxGetPr(matlabArray);     #endif    
36     void *mdata = mxGetPr(matlabArray);         


116 / 129

19     switch (classID)      #ifndef cimg_use_tiff    
27     switch (classID)      error cimg_use_tiff not defined    
18     switch (classID)      #endif    
28     switch (classID)      #ifndef cimg_plugin_tiff_stream    
27     switch (classID)      #define cimg_plugin_tiff_stream    
16     switch (classID)      #include <ios>    
88     switch (classID)      const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     switch (classID)       if (!tiffOutStream->good())    
36     switch (classID)       throw CImgArgumentException(_cimg_instance    
33     switch (classID)       "save_tiff(): tiffstream is not good!",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       if (is_empty())    
36     switch (classID)       throw CImgArgumentException(_cimg_instance    
40     switch (classID)       "Not allowed to write empty images to stream",    
15     switch (classID)       cimg_instance    
16     switch (classID)       );    
49     switch (classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
13     switch (classID)       if (tif)    
59     switch (classID)       cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     switch (classID)       tiffOutStream->flush();    
16     switch (classID)       TIFFClose(tif);    
15     switch (classID)       else    
31     switch (classID)       throw CImgIOException(_cimg_instance    
39     switch (classID)       "save_tiff(): Failed to stream for writing.",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       return *this;    
41     switch (classID)      CImg<T>& load_tiff(std::istream* tiffInStream,    
60     switch (classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (classID)       const unsigned int step_frame=1)    
17     switch (classID)       const unsigned int    
54     switch (classID)       nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
34     switch (classID)       nstep_frame = step_frame?step_frame:1;    
65     switch (classID)       unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
47     switch (classID)       TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
13     switch (classID)       if (tif)    
22     switch (classID)       unsigned int nb_images = 0;    
16     switch (classID)       do     
16     switch (classID)       ++nb_images;    
27     switch (classID)        while (TIFFReadDirectory(tif));    
67     switch (classID)       if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103     switch (classID)       cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
41     switch (classID)       nfirst_frame,nlast_frame,nstep_frame,nb_images);    
26     switch (classID)       if (nfirst_frame>=nb_images)    
14     switch (classID)       return assign();    
25     switch (classID)       if (nlast_frame>=nb_images)    
23     switch (classID)       nlast_frame = nb_images-1;    
21     switch (classID)       TIFFSetDirectory(tif,0);    
16     switch (classID)       CImg<T> frame;    
58     switch (classID)       for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
23     switch (classID)       frame._load_tiff(tif,l);    
102     switch (classID)       if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     switch (classID)       if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
105     switch (classID)       resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
44     switch (classID)       draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
16     switch (classID)       TIFFClose(tif);    
15     switch (classID)       else    
31     switch (classID)       throw CImgIOException(_cimg_instance    
42     switch (classID)       "load_tiff(): Failed to read data from stream",    
14     switch (classID)       cimg_instance);    
15     switch (classID)       return *this;    
48     switch (classID)      static CImg<T> get_load_tiff(std::istream* tiffInStream,    
60     switch (classID)       const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
28     switch (classID)       const unsigned int step_frame=1)    
68     switch (classID)       return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
18     switch (classID)      #endif    
18     switch (classID)          


117 / 129

65     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #ifndef cimg_use_tiff    
63     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     error cimg_use_tiff not defined    
69     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #endif    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
68     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #include <ios>    
86     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (!tiffOutStream->good())    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg_instance);    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (is_empty())    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
59     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      "Not allowed to write empty images to stream",    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg_instance    
68     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      );    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
67     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (tif)    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      tiffOutStream->flush();    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      TIFFClose(tif);    
67     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      else    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
59     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg_instance);    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      return *this;    
59     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
65     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      const unsigned int    
58     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
57     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
67     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (tif)    
61     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      unsigned int nb_images = 0;    
68     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      do     
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      ++nb_images;    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
68     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
96     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      return assign();    
58     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (nlast_frame>=nb_images)    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      nlast_frame = nb_images-1;    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
63     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      CImg<T> frame;    
63     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      frame._load_tiff(tif,l);    
94     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
59     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      TIFFClose(tif);    
67     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      else    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
57     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
62     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      cimg_instance);    
64     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      return *this;    
59     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
65     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
69     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;     #endif    
71     case mxDOUBLE_CLASS : populate_maltlab_array((real64_T*)mdata); break;         


118 / 129

65     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #ifndef cimg_use_tiff    
63     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     error cimg_use_tiff not defined    
69     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #endif    
61     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
68     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #include <ios>    
86     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
61     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (!tiffOutStream->good())    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg_instance);    
61     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (is_empty())    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
59     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      "Not allowed to write empty images to stream",    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg_instance    
68     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      );    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
67     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (tif)    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      tiffOutStream->flush();    
63     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      TIFFClose(tif);    
67     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      else    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
59     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg_instance);    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      return *this;    
59     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
65     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      const unsigned int    
58     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
57     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
67     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (tif)    
61     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      unsigned int nb_images = 0;    
68     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      do     
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      ++nb_images;    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
68     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
96     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      return assign();    
58     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (nlast_frame>=nb_images)    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      nlast_frame = nb_images-1;    
61     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
63     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      CImg<T> frame;    
63     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      frame._load_tiff(tif,l);    
94     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
100     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
59     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
63     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      TIFFClose(tif);    
67     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      else    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
57     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
62     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      cimg_instance);    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      return *this;    
59     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
65     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
69     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;     #endif    
71     case mxSINGLE_CLASS : populate_maltlab_array((real32_T*)mdata); break;         


119 / 129

61     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #ifndef cimg_use_tiff    
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     error cimg_use_tiff not defined    
64     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #endif    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #define cimg_plugin_tiff_stream    
63     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #include <ios>    
84     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (!tiffOutStream->good())    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg_instance);    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (is_empty())    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
55     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      "Not allowed to write empty images to stream",    
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg_instance    
64     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      );    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
62     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (tif)    
60     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
59     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      tiffOutStream->flush();    
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      TIFFClose(tif);    
63     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      else    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg_instance);    
59     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      return *this;    
55     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
61     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      const unsigned int step_frame=1)    
60     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      const unsigned int    
54     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
53     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
59     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
62     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (tif)    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      unsigned int nb_images = 0;    
64     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      do     
59     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      ++nb_images;    
55     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;       while (TIFFReadDirectory(tif));    
66     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
54     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (nfirst_frame>=nb_images)    
60     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      return assign();    
54     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (nlast_frame>=nb_images)    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      nlast_frame = nb_images-1;    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      TIFFSetDirectory(tif,0);    
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      CImg<T> frame;    
62     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      frame._load_tiff(tif,l);    
92     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
58     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      TIFFClose(tif);    
63     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      else    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
53     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
57     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      cimg_instance);    
59     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      return *this;    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
61     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
56     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
64     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;     #endif    
67     case mxINT8_CLASS : populate_maltlab_array((int8_T*)mdata); break;         


120 / 129

63     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #ifndef cimg_use_tiff    
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     error cimg_use_tiff not defined    
66     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #endif    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #define cimg_plugin_tiff_stream    
65     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #include <ios>    
84     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (!tiffOutStream->good())    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg_instance);    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (is_empty())    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      "Not allowed to write empty images to stream",    
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg_instance    
66     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      );    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
64     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (tif)    
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      tiffOutStream->flush();    
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      TIFFClose(tif);    
65     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      else    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg_instance);    
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      return *this;    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
62     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      const unsigned int step_frame=1)    
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      const unsigned int    
55     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
55     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
64     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (tif)    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      unsigned int nb_images = 0;    
66     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      do     
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      ++nb_images;    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;       while (TIFFReadDirectory(tif));    
67     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (nfirst_frame>=nb_images)    
62     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      return assign();    
56     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (nlast_frame>=nb_images)    
57     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      nlast_frame = nb_images-1;    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      TIFFSetDirectory(tif,0);    
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      CImg<T> frame;    
62     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      frame._load_tiff(tif,l);    
93     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
60     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      TIFFClose(tif);    
65     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      else    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
59     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      cimg_instance);    
61     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      return *this;    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
62     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      const unsigned int step_frame=1)    
64     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
66     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;     #endif    
69     case mxUINT8_CLASS : populate_maltlab_array((uint8_T*)mdata); break;         


121 / 129

63     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #ifndef cimg_use_tiff    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     error cimg_use_tiff not defined    
66     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #endif    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #define cimg_plugin_tiff_stream    
65     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #include <ios>    
84     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (!tiffOutStream->good())    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg_instance);    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (is_empty())    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
57     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      "Not allowed to write empty images to stream",    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg_instance    
66     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      );    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
64     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (tif)    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
61     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      tiffOutStream->flush();    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      else    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg_instance);    
61     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      return *this;    
56     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
63     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      const unsigned int step_frame=1)    
62     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      const unsigned int    
56     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
64     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (tif)    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      unsigned int nb_images = 0;    
66     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      do     
61     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      ++nb_images;    
57     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;       while (TIFFReadDirectory(tif));    
67     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (nfirst_frame>=nb_images)    
62     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      return assign();    
56     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (nlast_frame>=nb_images)    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      nlast_frame = nb_images-1;    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      TIFFSetDirectory(tif,0);    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      CImg<T> frame;    
62     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      frame._load_tiff(tif,l);    
92     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
57     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
60     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      else    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
59     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      cimg_instance);    
61     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      return *this;    
57     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
63     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
66     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;     #endif    
69     case mxINT16_CLASS : populate_maltlab_array((int16_T*)mdata); break;         


122 / 129

65     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #ifndef cimg_use_tiff    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     error cimg_use_tiff not defined    
68     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #endif    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #define cimg_plugin_tiff_stream    
67     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #include <ios>    
84     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (!tiffOutStream->good())    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg_instance);    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (is_empty())    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      "Not allowed to write empty images to stream",    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg_instance    
68     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      );    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
66     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (tif)    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
63     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      tiffOutStream->flush();    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      else    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg_instance);    
63     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      return *this;    
58     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
64     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      const unsigned int step_frame=1)    
63     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      const unsigned int    
57     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
56     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
66     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (tif)    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      unsigned int nb_images = 0;    
68     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      do     
63     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      ++nb_images;    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;       while (TIFFReadDirectory(tif));    
68     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (nfirst_frame>=nb_images)    
64     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      return assign();    
58     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (nlast_frame>=nb_images)    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      nlast_frame = nb_images-1;    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      TIFFSetDirectory(tif,0);    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      CImg<T> frame;    
64     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      frame._load_tiff(tif,l);    
93     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
98     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
62     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      else    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      throw CImgIOException(_cimg_instance    
57     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
61     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      cimg_instance);    
63     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      return *this;    
59     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
68     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;     #endif    
71     case mxUINT16_CLASS : populate_maltlab_array((uint16_T*)mdata); break;         


123 / 129

63     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #ifndef cimg_use_tiff    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     error cimg_use_tiff not defined    
66     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #endif    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
65     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #include <ios>    
84     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (!tiffOutStream->good())    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg_instance);    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (is_empty())    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
57     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      "Not allowed to write empty images to stream",    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg_instance    
66     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      );    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
64     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (tif)    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
61     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      tiffOutStream->flush();    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      else    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg_instance);    
61     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      return *this;    
56     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
63     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      const unsigned int step_frame=1)    
62     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      const unsigned int    
56     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
64     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (tif)    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      unsigned int nb_images = 0;    
66     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      do     
61     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      ++nb_images;    
57     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
67     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
62     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      return assign();    
56     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (nlast_frame>=nb_images)    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      nlast_frame = nb_images-1;    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      CImg<T> frame;    
62     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      frame._load_tiff(tif,l);    
92     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
57     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
60     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      else    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
59     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      cimg_instance);    
61     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      return *this;    
57     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
63     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
66     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;     #endif    
69     case mxINT32_CLASS : populate_maltlab_array((int32_T*)mdata); break;         


124 / 129

65     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #ifndef cimg_use_tiff    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     error cimg_use_tiff not defined    
68     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #endif    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #define cimg_plugin_tiff_stream    
67     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #include <ios>    
84     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (!tiffOutStream->good())    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg_instance);    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (is_empty())    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      "Not allowed to write empty images to stream",    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg_instance    
68     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      );    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
66     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (tif)    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
63     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      tiffOutStream->flush();    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      else    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg_instance);    
63     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      return *this;    
58     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
64     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      const unsigned int step_frame=1)    
63     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      const unsigned int    
57     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
56     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
66     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (tif)    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      unsigned int nb_images = 0;    
68     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      do     
63     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      ++nb_images;    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;       while (TIFFReadDirectory(tif));    
68     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (nfirst_frame>=nb_images)    
64     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      return assign();    
58     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (nlast_frame>=nb_images)    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      nlast_frame = nb_images-1;    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      TIFFSetDirectory(tif,0);    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      CImg<T> frame;    
64     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      frame._load_tiff(tif,l);    
93     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
62     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      else    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      throw CImgIOException(_cimg_instance    
57     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
61     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      cimg_instance);    
63     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      return *this;    
59     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
68     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;     #endif    
71     case mxUINT32_CLASS : populate_maltlab_array((uint32_T*)mdata); break;         


125 / 129

63     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #ifndef cimg_use_tiff    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     error cimg_use_tiff not defined    
66     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #endif    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
65     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #include <ios>    
84     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (!tiffOutStream->good())    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg_instance);    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (is_empty())    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
57     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      "Not allowed to write empty images to stream",    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg_instance    
66     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      );    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
64     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (tif)    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
61     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      tiffOutStream->flush();    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      else    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg_instance);    
61     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      return *this;    
56     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
63     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      const unsigned int step_frame=1)    
62     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      const unsigned int    
56     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
54     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
64     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (tif)    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      unsigned int nb_images = 0;    
66     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      do     
61     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      ++nb_images;    
57     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
67     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
95     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
56     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
62     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      return assign();    
56     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (nlast_frame>=nb_images)    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      nlast_frame = nb_images-1;    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      CImg<T> frame;    
62     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      frame._load_tiff(tif,l);    
92     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
57     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
60     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      TIFFClose(tif);    
65     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      else    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
55     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
59     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      cimg_instance);    
61     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      return *this;    
57     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
63     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
58     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
66     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;     #endif    
69     case mxINT64_CLASS : populate_maltlab_array((int64_T*)mdata); break;         


126 / 129

65     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #ifndef cimg_use_tiff    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     error cimg_use_tiff not defined    
68     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #endif    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #ifndef cimg_plugin_tiff_stream    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #define cimg_plugin_tiff_stream    
67     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #include <ios>    
84     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (!tiffOutStream->good())    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      "save_tiff(): tiffstream is not good!",    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg_instance);    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (is_empty())    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      throw CImgArgumentException(_cimg_instance    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      "Not allowed to write empty images to stream",    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg_instance    
68     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      );    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
66     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (tif)    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
63     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      tiffOutStream->flush();    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      else    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      "save_tiff(): Failed to stream for writing.",    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg_instance);    
63     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      return *this;    
58     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     CImg<T>& load_tiff(std::istream* tiffInStream,    
64     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      const unsigned int step_frame=1)    
63     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      const unsigned int    
57     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
56     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      nstep_frame = step_frame?step_frame:1;    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
66     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (tif)    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      unsigned int nb_images = 0;    
68     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      do     
63     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      ++nb_images;    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;       while (TIFFReadDirectory(tif));    
68     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
94     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
58     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (nfirst_frame>=nb_images)    
64     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      return assign();    
58     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (nlast_frame>=nb_images)    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      nlast_frame = nb_images-1;    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      TIFFSetDirectory(tif,0);    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      CImg<T> frame;    
64     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      frame._load_tiff(tif,l);    
93     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
70     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
99     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
62     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      TIFFClose(tif);    
67     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      else    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      throw CImgIOException(_cimg_instance    
57     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      "load_tiff(): Failed to read data from stream",    
61     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      cimg_instance);    
63     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      return *this;    
59     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
64     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
60     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      const unsigned int step_frame=1)    
65     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
68     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;     #endif    
71     case mxUINT64_CLASS : populate_maltlab_array((uint64_T*)mdata); break;         


127 / 129

20     return matlabArray;     #ifndef cimg_use_tiff    
27     return matlabArray;     error cimg_use_tiff not defined    
18     return matlabArray;     #endif    
27     return matlabArray;     #ifndef cimg_plugin_tiff_stream    
26     return matlabArray;     #define cimg_plugin_tiff_stream    
19     return matlabArray;     #include <ios>    
88     return matlabArray;     const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
24     return matlabArray;      if (!tiffOutStream->good())    
37     return matlabArray;      throw CImgArgumentException(_cimg_instance    
34     return matlabArray;      "save_tiff(): tiffstream is not good!",    
16     return matlabArray;      cimg_instance);    
18     return matlabArray;      if (is_empty())    
37     return matlabArray;      throw CImgArgumentException(_cimg_instance    
37     return matlabArray;      "Not allowed to write empty images to stream",    
17     return matlabArray;      cimg_instance    
18     return matlabArray;      );    
45     return matlabArray;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffOutStream);    
17     return matlabArray;      if (tif)    
58     return matlabArray;      cimg_forZ(*this,z) get_slice(z)._save_tiff(tif,z,compression_type);    
20     return matlabArray;      tiffOutStream->flush();    
18     return matlabArray;      TIFFClose(tif);    
17     return matlabArray;      else    
31     return matlabArray;      throw CImgIOException(_cimg_instance    
37     return matlabArray;      "save_tiff(): Failed to stream for writing.",    
16     return matlabArray;      cimg_instance);    
10     return matlabArray;      return *this;    
39     return matlabArray;     CImg<T>& load_tiff(std::istream* tiffInStream,    
57     return matlabArray;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     return matlabArray;      const unsigned int step_frame=1)    
18     return matlabArray;      const unsigned int    
50     return matlabArray;      nfirst_frame = first_frame<last_frame?first_frame:last_frame,    
30     return matlabArray;      nstep_frame = step_frame?step_frame:1;    
60     return matlabArray;      unsigned int nlast_frame = first_frame<last_frame?last_frame:first_frame;    
44     return matlabArray;      TIFF *tif = TIFFStreamOpen("MemTiff", tiffInStream);    
17     return matlabArray;      if (tif)    
21     return matlabArray;      unsigned int nb_images = 0;    
18     return matlabArray;      do     
16     return matlabArray;      ++nb_images;    
27     return matlabArray;       while (TIFFReadDirectory(tif));    
65     return matlabArray;      if (nfirst_frame>=nb_images || (nlast_frame!=~0U && nlast_frame>=nb_images))    
103     return matlabArray;      cimg::warn("load_tiff(): Invalid specified frame range is [%u,%u] (step %u) since stream contains %u image(s).",    
38     return matlabArray;      nfirst_frame,nlast_frame,nstep_frame,nb_images);    
23     return matlabArray;      if (nfirst_frame>=nb_images)    
10     return matlabArray;      return assign();    
23     return matlabArray;      if (nlast_frame>=nb_images)    
21     return matlabArray;      nlast_frame = nb_images-1;    
20     return matlabArray;      TIFFSetDirectory(tif,0);    
16     return matlabArray;      CImg<T> frame;    
58     return matlabArray;      for (unsigned int l = nfirst_frame; l<=nlast_frame; l+=nstep_frame)     
20     return matlabArray;      frame._load_tiff(tif,l);    
100     return matlabArray;      if (l==nfirst_frame) assign(frame._width,frame._height,1+(nlast_frame-nfirst_frame)/nstep_frame,frame._spectrum);    
69     return matlabArray;      if (frame._width>_width || frame._height>_height || frame._spectrum>_spectrum)    
106     return matlabArray;      resize(cimg::max(frame._width,_width),cimg::max(frame._height,_height),-100,cimg::max(frame._spectrum,_spectrum),0);    
42     return matlabArray;      draw_image(0,0,(l-nfirst_frame)/nstep_frame,frame);    
18     return matlabArray;      TIFFClose(tif);    
17     return matlabArray;      else    
31     return matlabArray;      throw CImgIOException(_cimg_instance    
38     return matlabArray;      "load_tiff(): Failed to read data from stream",    
16     return matlabArray;      cimg_instance);    
10     return matlabArray;      return *this;    
48     return matlabArray;     static CImg<T> get_load_tiff(std::istream* tiffInStream,    
57     return matlabArray;      const unsigned int first_frame=0, const unsigned int last_frame=~0U,    
25     return matlabArray;      const unsigned int step_frame=1)    
59     return matlabArray;      return CImg<T>().load_tiff(tiffInStream,first_frame,last_frame,step_frame);    
18     return matlabArray;     #endif    
20     return matlabArray;         


128 / 129

16    #endif     #ifndef cimg_use_tiff    
27    #endif     error cimg_use_tiff not defined    
0    #endif     #endif    


129 / 129

21         #ifndef cimg_use_tiff    
31         error cimg_use_tiff not defined    
6         #endif    
31         #ifndef cimg_plugin_tiff_stream    
31         #define cimg_plugin_tiff_stream    
14         #include <ios>    
99         const CImg<T>& save_tiff(std::ostream *tiffOutStream, const unsigned int compression_type=0) const     
28          if (!tiffOutStream->good())    
43          throw CImgArgumentException(_cimg_instance    
40          "save_tiff(): tiffstream is not good!",    
16          cimg_instance);    
16          if (is_empty())    
43          throw CImgArgumentException(_cimg_instance    
47          "Not allowed to write empty images to stream",    
14          cimg_instance    
3          );    

LineByLine_Plagiarised Lines : 
Line:0  0
Line:1  0
Line:2  0
Line:3  0
Line:4  0
Line:5  0
Line:6  0
Line:7  1
Line:8  0
Line:9  0
Line:10  1
Line:11  0
Line:12  0
Line:13  1
Line:14  0
Line:15  0
Line:16  0
Line:17  0
Line:18  0
Line:19  0
Line:20  0
Line:21  0
Line:22  0
Line:23  0
Line:24  0
Line:25  0
Line:26  0
Line:27  0
Line:28  0
Line:29  0
Line:30  0
Line:31  0
Line:32  0
Line:33  1
Line:34  0
Line:35  0
Line:36  0
Line:37  0
Line:38  0
Line:39  0
Line:40  0
Line:41  0
Line:42  0
Line:43  0
Line:44  0
Line:45  0
Line:46  0
Line:47  0
Line:48  0
Line:49  1
Line:50  0
Line:51  0
Line:52  0
Line:53  0
Line:54  0
Line:55  0
Line:56  0
Line:57  0
Line:58  0
Line:59  0
Line:60  1
Line:61  1
Line:62  0
Line:63  0
Line:64  0
Line:65  0
Line:66  0
Line:67  0
Line:68  0
Line:69  0
Line:70  0
Line:71  0
Line:72  1
Line:73  0
Line:74  0
Line:75  0
Line:76  0
Line:77  0
Line:78  0
Line:79  0
Line:80  1
Line:81  1
Line:82  0
Line:83  0
Line:84  0
Line:85  0
Line:86  0
Line:87  0
Line:88  0
Line:89  0
Line:90  0
Line:91  0
Line:92  0
Line:93  0
Line:94  0
Line:95  0
Line:96  0
Line:97  0
Line:98  0
Line:99  0
Line:100  0
Line:101  1
Line:102  0
Line:103  0
Line:104  0
Line:105  0
Line:106  0
Line:107  0
Line:108  0
Line:109  0
Line:110  0
Line:111  0
Line:112  0
Line:113  0
Line:114  0
Line:115  1
Line:116  0
Line:117  0
Line:118  0
Line:119  0
Line:120  0
Line:121  0
Line:122  0
Line:123  0
Line:124  0
Line:125  0
Line:126  0
Line:127  0
Line:128  0
